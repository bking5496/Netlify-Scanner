<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#2563EB">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Stock Scanner</title>
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' rx='20' fill='%232563EB'/><path d='M25 30h10v40H25zM40 30h5v40h-5zM50 30h10v40H50zM65 30h5v40h-5zM75 30h5v40h-5z' fill='white'/></svg>">
    <link rel="apple-touch-icon"
        href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' rx='20' fill='%232563EB'/><path d='M25 30h10v40H25zM40 30h5v40h-5zM50 30h10v40H50zM65 30h5v40h-5zM75 30h5v40h-5z' fill='white'/></svg>">
    <!-- Preconnect to CDNs for faster loading -->
    <link rel="preconnect" href="https://cdn.tailwindcss.com">
    <link rel="preconnect" href="https://cdn.jsdelivr.net">
    <link rel="dns-prefetch" href="https://exltxjvzsefmaxlgxyio.supabase.co">
    <!-- Critical CSS inline, external scripts deferred where possible -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>
    <!-- XLSX loaded async - only needed for import/export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js" async></script>
    <!-- QRCode.js for generating location QR codes -->
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js" async></script>
    <style>
        /* Critical CSS - inline for faster first paint */
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
        }

        /* iOS camera fixes */
        #scanner video {
            object-fit: cover !important;
            width: 100% !important;
            height: 100% !important;
        }

        #scanner {
            overflow: hidden;
            border-radius: 12px;
        }

        /* Responsive adjustments */
        @media (min-width: 768px) {

            /* Tablet and desktop: better spacing */
            .scan-list-grid {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 1rem;
            }
        }

        @media (min-width: 1024px) {

            /* Desktop: 3 column grid for scan items */
            .scan-list-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        /* Better touch targets on mobile */
        @media (max-width: 640px) {

            button,
            input,
            select {
                min-height: 44px;
            }
        }

        /* Desktop hover effects */
        @media (hover: hover) {
            .hover-lift:hover {
                transform: translateY(-2px);
                box-shadow: 0 10px 25px -5px rgb(0 0 0 / 0.1);
            }
        }

        /* Larger screens: increase max width of app container */
        @media (min-width: 1280px) {
            #app {
                max-width: 72rem;
                /* xl:max-w-6xl equivalent */
            }
        }

        @media (min-width: 1024px) {
            #app {
                max-width: 64rem;
                /* lg:max-w-5xl equivalent */
            }
        }

        /* Performance: GPU acceleration for animated elements */
        .animate-pulse,
        .animate-spin,
        .hover-lift,
        #scanner video {
            will-change: transform;
            transform: translateZ(0);
        }

        /* Reduce paint on scroll */
        #app {
            contain: layout style;
        }

        /* Smooth animations */
        .animate-fade-in {
            animation: fadeIn 0.15s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }
    </style>
</head>

<body
    class="bg-slate-100 text-slate-900 min-h-screen font-sans antialiased selection:bg-blue-100 selection:text-blue-700">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <div id="app" class="max-w-4xl mx-auto min-h-screen bg-white shadow-2xl shadow-slate-200 overflow-hidden relative">
    </div>
    <div id="modal-root" class="relative z-50"></div>
    <!-- Floating Scan Button - Rendered outside #app for true fixed positioning -->
    <div id="floating-buttons"></div>

    <script>
        // ===========================================
        // DATABASE CONFIGURATION
        // ===========================================

        // Supabase Configuration
        const SUPABASE_URL = 'https://exltxjvzsefmaxlgxyio.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImV4bHR4anZ6c2VmbWF4bGd4eWlvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ0NTQ2MjcsImV4cCI6MjA4MDAzMDYyN30.kc5RFVrN5orQ7AqPd51ot-sK1xbWsy_58ToowCvYhZw';
        const HEARTBEAT_INTERVAL_MS = 15000;
        const HEARTBEAT_GRACE_MS = 45000;

        const SUPABASE_PLACEHOLDER_URL = 'https://YOUR_PROJECT_ID.supabase.co';
        const SUPABASE_PLACEHOLDER_KEY = 'YOUR_SUPABASE_ANON_KEY';
        const supabaseCredentialsConfigured = Boolean(window.supabase?.createClient)
            && Boolean(SUPABASE_URL)
            && Boolean(SUPABASE_ANON_KEY)
            && SUPABASE_URL !== SUPABASE_PLACEHOLDER_URL
            && !SUPABASE_URL.includes('YOUR_PROJECT_ID')
            && SUPABASE_ANON_KEY !== SUPABASE_PLACEHOLDER_KEY
            && !SUPABASE_ANON_KEY.includes('YOUR_SUPABASE_ANON_KEY');

        // Initialize Supabase client whenever credentials exist
        let supabase = null;
        if (supabaseCredentialsConfigured) {
            supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
            try {
                const cachedSession = JSON.parse(localStorage.getItem('supabaseSessionCache') || 'null');
                if (cachedSession?.access_token && cachedSession?.refresh_token) {
                    supabase.auth.setSession({
                        access_token: cachedSession.access_token,
                        refresh_token: cachedSession.refresh_token
                    }).catch(() => localStorage.removeItem('supabaseSessionCache'));
                }
                supabase.auth.onAuthStateChange((_event, session) => {
                    if (session?.access_token && session?.refresh_token) {
                        localStorage.setItem('supabaseSessionCache', JSON.stringify({
                            access_token: session.access_token,
                            refresh_token: session.refresh_token,
                            expires_at: session.expires_at
                        }));
                    }
                });
            } catch (err) {
                console.warn('Supabase session cache error', err);
            }
        }

        // Database helper - uses Supabase or localStorage fallback
        const db = {
            connected: false,
            mode: 'localStorage', // 'supabase' or 'localStorage'

            async init() {
                // Try Supabase
                if (supabase) {
                    try {
                        const { error } = await supabase.from('stock_scans').select('id').limit(1);
                        if (!error || error.code === 'PGRST116') { // Table might be empty
                            this.connected = true;
                            this.mode = 'supabase';
                            console.log('Connected to Supabase');
                            return true;
                        }
                        console.log('Supabase error:', error);
                    } catch (err) {
                        console.log('Supabase not available:', err.message);
                    }
                }

                // Fallback to localStorage
                this.connected = false;
                this.mode = 'localStorage';
                console.log('Using localStorage for data storage');
                return false;
            },

            async insertStockTake(date) {
                if (this.mode === 'supabase') {
                    const { error } = await supabase.from('stock_takes').upsert({
                        take_date: date,
                        status: 'active'
                    }, { onConflict: 'take_date' });
                    return !error;
                }
                return false;
            },

            async getStockScans(date) {
                if (this.mode === 'supabase') {
                    const { data, error } = await supabase
                        .from('stock_scans')
                        .select('*')
                        .eq('take_date', date)
                        .order('scanned_at', { ascending: false });
                    return error ? [] : data;
                }
                return [];
            },

            async insertStockScan(scan) {
                if (this.mode === 'supabase') {
                    const { error } = await supabase.from('stock_scans').insert({
                        take_date: scan.take_date,
                        batch_number: scan.batch_number,
                        pallet_number: scan.pallet_number,
                        cases_on_pallet: scan.cases_on_pallet,
                        actual_cases: scan.actual_cases,
                        stock_code: scan.stock_code,
                        description: scan.description,
                        raw_code: scan.raw_code,
                        device_id: scan.device_id,
                        scanned_by: scan.scanned_by || 'Unknown'
                    });
                    return !error;
                }
                return false;
            },

            async checkDuplicate(date, batchNumber, palletNumber) {
                if (this.mode === 'supabase') {
                    const { data, error } = await supabase
                        .from('stock_scans')
                        .select('*')
                        .eq('take_date', date)
                        .eq('batch_number', batchNumber)
                        .eq('pallet_number', palletNumber)
                        .limit(1)
                        .single();
                    return error ? null : data;
                }
                return null;
            },

            async deleteStockScan(id) {
                if (this.mode === 'supabase') {
                    const { error } = await supabase.from('stock_scans').delete().eq('id', id);
                    return !error;
                }
                return false;
            }
        };

        // Local storage fallback
        const localStorage_db = {
            get: (key) => {
                const value = localStorage.getItem(key);
                return value ? JSON.parse(value) : null;
            },
            set: (key, value) => {
                localStorage.setItem(key, JSON.stringify(value));
            },
            delete: (key) => {
                localStorage.removeItem(key);
            },
            list: (prefix) => {
                return Object.keys(localStorage)
                    .filter(k => k.startsWith(prefix))
                    .map(k => {
                        const val = localStorage.getItem(k);
                        return val ? JSON.parse(val) : null;
                    })
                    .filter(Boolean);
            }
        };

        const clearLocalScanStorage = () => {
            Object.keys(localStorage)
                .filter(key => key.startsWith('scan:'))
                .forEach(key => localStorage.removeItem(key));
        };

        // ===== OFFLINE SYNC QUEUE =====
        // Stores scans that were made offline and need to be synced when back online
        const offlineSyncQueue = {
            QUEUE_KEY: 'offlineSyncQueue',

            // Get all pending scans from queue
            getQueue() {
                const queue = localStorage.getItem(this.QUEUE_KEY);
                return queue ? JSON.parse(queue) : [];
            },

            // Add a scan to the offline queue
            addToQueue(scanData) {
                const queue = this.getQueue();
                const queueItem = {
                    id: 'offline_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                    timestamp: Date.now(),
                    data: scanData,
                    retryCount: 0
                };
                queue.push(queueItem);
                localStorage.setItem(this.QUEUE_KEY, JSON.stringify(queue));
                console.log('Added scan to offline queue:', queueItem.id);
                return queueItem.id;
            },

            // Remove a scan from the queue (after successful sync)
            removeFromQueue(queueId) {
                const queue = this.getQueue();
                const newQueue = queue.filter(item => item.id !== queueId);
                localStorage.setItem(this.QUEUE_KEY, JSON.stringify(newQueue));
                console.log('Removed scan from offline queue:', queueId);
            },

            // Update retry count for a queued item
            incrementRetry(queueId) {
                const queue = this.getQueue();
                const item = queue.find(i => i.id === queueId);
                if (item) {
                    item.retryCount++;
                    item.lastRetry = Date.now();
                    localStorage.setItem(this.QUEUE_KEY, JSON.stringify(queue));
                }
            },

            // Get count of pending items
            getPendingCount() {
                return this.getQueue().length;
            },

            // Clear the entire queue
            clearQueue() {
                localStorage.removeItem(this.QUEUE_KEY);
            }
        };

        // Sync all offline scans to Supabase
        async function syncOfflineScans() {
            if (!supabase || !navigator.onLine) {
                console.log('Cannot sync - offline or no Supabase');
                return { synced: 0, failed: 0 };
            }

            const queue = offlineSyncQueue.getQueue();
            if (queue.length === 0) {
                console.log('No offline scans to sync');
                return { synced: 0, failed: 0, skippedDuplicates: 0 };
            }

            console.log(`Syncing ${queue.length} offline scans...`);
            let synced = 0;
            let failed = 0;
            let skippedDuplicates = 0;

            for (const item of queue) {
                // Skip items that have failed too many times
                if (item.retryCount >= 5) {
                    console.warn('Skipping item with too many retries:', item.id);
                    failed++;
                    continue;
                }

                try {
                    const record = item.data;

                    // Check for FP 13-digit duplicates (has pallet_number)
                    if (record.session_type === 'FP' && record.pallet_number) {
                        const existingDup = await checkDuplicateInSupabase(
                            record.session_id,
                            record.batch_number,
                            record.pallet_number
                        );
                        if (existingDup) {
                            console.log('Offline scan is duplicate FP pallet, skipping:', item.id, record.batch_number, record.pallet_number);
                            offlineSyncQueue.removeFromQueue(item.id);
                            skippedDuplicates++;
                            continue;
                        }
                    }

                    const { data, error } = await supabase
                        .from('stock_scans')
                        .insert([record])
                        .select();

                    if (error) {
                        // Check if this is a unique constraint violation (race condition duplicate)
                        // PostgreSQL error code 23505 = unique_violation
                        const isDuplicateError = error.code === '23505' ||
                            error.message?.includes('duplicate') ||
                            error.message?.includes('unique constraint');

                        if (isDuplicateError && record.session_type === 'FP' && record.pallet_number) {
                            // Another device synced this pallet first - not an error, just skip
                            console.log('Race condition duplicate detected, skipping:', item.id, record.batch_number, record.pallet_number);
                            offlineSyncQueue.removeFromQueue(item.id);
                            skippedDuplicates++;
                        } else {
                            console.error('Failed to sync offline scan:', error);
                            offlineSyncQueue.incrementRetry(item.id);
                            failed++;
                        }
                    } else {
                        console.log('Successfully synced offline scan:', item.id);
                        offlineSyncQueue.removeFromQueue(item.id);
                        synced++;
                    }
                } catch (err) {
                    console.error('Error syncing offline scan:', err);
                    offlineSyncQueue.incrementRetry(item.id);
                    failed++;
                }
            }

            console.log(`Offline sync complete: ${synced} synced, ${failed} failed, ${skippedDuplicates} duplicates skipped`);
            return { synced, failed, skippedDuplicates };
        }

        // Product Database - loaded from Supabase or localStorage cache
        // FP = Finished Products (keyed by batchNumber)
        let productDatabase = JSON.parse(localStorage.getItem('productDatabase') || '{}');
        let productsLoadedFromDB = false;

        // RM = Raw Materials Database (keyed by stockCode)
        // Structure: { stockCode: { description, batches: { batchNumber: { expiryDates: [date1, date2, ...] } } } }
        // Multiple expiry dates are allowed per stock_code + batch_number combination
        let rawMaterialsDatabase = JSON.parse(localStorage.getItem('rawMaterialsDatabase') || '{}');
        let rmProductsLoadedFromDB = false;

        // Product Type Database - determines if product is ingredient (kg) or not (units)
        // Structure: { stockCodePrefix: { productType: 'Ingredient' | 'Non-Ingredient', unitType: 'kg' | 'units' } }
        // RM* products = Ingredient = kg
        // PM* products = Non-Ingredient = units
        let productTypeDatabase = JSON.parse(localStorage.getItem('productTypeDatabase') || '{}');
        let productTypesLoadedFromDB = false;

        // Load FP products from Supabase
        let _productsLoadPromise = null;
        async function loadProductsFromSupabase(forceReload = false) {
            // Return cached promise if already loading
            if (_productsLoadPromise && !forceReload) return _productsLoadPromise;

            // Skip if already loaded and not forcing reload
            if (productsLoadedFromDB && !forceReload) {
                return true;
            }

            if (!supabase) {
                console.log('Supabase not available, using cached products');
                return false;
            }

            _productsLoadPromise = (async () => {
                try {
                    console.log('Loading FP products from Supabase...');
                    const { data, error } = await supabase
                        .from('products')
                        .select('batch_number,stock_code,description'); // Only select needed fields

                    if (error) {
                        console.error('Error loading products:', error);
                        return false;
                    }

                    if (data && data.length > 0) {
                        // Convert array to object keyed by batch_number
                        productDatabase = {};
                        data.forEach(product => {
                            const batchNum = product.batch_number || product.BatchNumber || product.batchnumber;
                            const stockCode = product.stock_code || product.StockCode || product.stockcode;
                            const description = product.description || product.Description;
                            if (batchNum) {
                                productDatabase[batchNum] = {
                                    stockCode: stockCode || '',
                                    description: description || ''
                                };
                            }
                        });
                        // Cache in localStorage for offline use
                        localStorage.setItem('productDatabase', JSON.stringify(productDatabase));
                        productsLoadedFromDB = true;
                        console.log(`Loaded ${Object.keys(productDatabase).length} FP products from Supabase`);
                        return true;
                    }
                    return false;
                } catch (err) {
                    console.error('Failed to load products from Supabase:', err);
                    return false;
                }
            })();

            return _productsLoadPromise;
        }

        // Load RM products from Supabase
        let _rmProductsLoadPromise = null;
        async function loadRawMaterialsFromSupabase(forceReload = false) {
            // Return cached promise if already loading
            if (_rmProductsLoadPromise && !forceReload) return _rmProductsLoadPromise;

            // Skip if already loaded and not forcing reload
            if (rmProductsLoadedFromDB && !forceReload) {
                return true;
            }

            if (!supabase) {
                console.log('Supabase not available, using cached raw materials');
                return false;
            }

            _rmProductsLoadPromise = (async () => {
                try {
                    console.log('Loading RM products from Supabase...');
                    const { data, error } = await supabase
                        .from('raw_materials')
                        .select('*');

                    if (error) {
                        console.error('Error loading raw materials:', error);
                        return false;
                    }

                    if (data && data.length > 0) {
                        // Convert array to object keyed by stock_code
                        // Support multiple expiry dates per stock_code + batch_number
                        rawMaterialsDatabase = {};
                        data.forEach(product => {
                            const stockCode = product.stock_code || product.StockCode || product.stockcode;
                            const description = product.description || product.Description;
                            const batchNumber = product.batch_number || product.BatchNumber || product.batchnumber;
                            const expiryDate = product.expiry_date || product.ExpiryDate || product.expirydate || null;

                            if (stockCode) {
                                if (!rawMaterialsDatabase[stockCode]) {
                                    rawMaterialsDatabase[stockCode] = {
                                        description: description || '',
                                        batches: {}
                                    };
                                }
                                if (batchNumber) {
                                    if (!rawMaterialsDatabase[stockCode].batches[batchNumber]) {
                                        rawMaterialsDatabase[stockCode].batches[batchNumber] = {
                                            expiryDates: []
                                        };
                                    }
                                    // Add expiry date if not already in the array
                                    if (expiryDate && !rawMaterialsDatabase[stockCode].batches[batchNumber].expiryDates.includes(expiryDate)) {
                                        rawMaterialsDatabase[stockCode].batches[batchNumber].expiryDates.push(expiryDate);
                                    }
                                }
                            }
                        });
                        // Cache in localStorage for offline use
                        localStorage.setItem('rawMaterialsDatabase', JSON.stringify(rawMaterialsDatabase));
                        rmProductsLoadedFromDB = true;
                        console.log(`Loaded ${Object.keys(rawMaterialsDatabase).length} RM products from Supabase`);
                        return true;
                    }
                    return false;
                } catch (err) {
                    console.error('Failed to load raw materials from Supabase:', err);
                    return false;
                }
            })();

            return _rmProductsLoadPromise;
        }

        // Load product types from Supabase
        // Table structure: type (column A), stock_code (column B), description (column C)
        let _productTypesLoadPromise = null;
        async function loadProductTypesFromSupabase(forceReload = false) {
            // Return cached promise if already loading
            if (_productTypesLoadPromise && !forceReload) return _productTypesLoadPromise;

            // Skip if already loaded and not forcing reload
            if (productTypesLoadedFromDB && !forceReload) {
                return true;
            }

            if (!supabase) {
                console.log('Supabase not available, using cached product types');
                return false;
            }

            _productTypesLoadPromise = (async () => {
                try {
                    console.log('Loading product types from Supabase...');
                    const { data, error } = await supabase
                        .from('product_types')
                        .select('type,stock_code,description'); // Only select needed fields

                    if (error) {
                        console.error('Error loading product types:', error);
                        return false;
                    }

                    if (data && data.length > 0) {
                        productTypeDatabase = {};
                        data.forEach(item => {
                            // Column mapping: type (A), stock_code (B), description (C)
                            const stockCode = (item.stock_code || '').toUpperCase();
                            const productType = item.type || 'Non-Ingredient';
                            const description = item.description || '';
                            if (stockCode) {
                                // Check if type is "ingredient" or "ingredients" (case-insensitive)
                                const isIngredient = productType.toLowerCase().startsWith('ingredient');
                                productTypeDatabase[stockCode] = {
                                    productType: productType,
                                    description: description,
                                    unitType: isIngredient ? 'kg' : 'units'
                                };
                            }
                        });
                        localStorage.setItem('productTypeDatabase', JSON.stringify(productTypeDatabase));
                        productTypesLoadedFromDB = true;
                        console.log(`Loaded ${Object.keys(productTypeDatabase).length} product types from Supabase`);
                        return true;
                    }
                    return false;
                } catch (err) {
                    console.error('Failed to load product types from Supabase:', err);
                    return false;
                }
            })();

            return _productTypesLoadPromise;
        }

        // Live duplicate check against Supabase - checks ALL devices in the session
        async function checkDuplicateInSupabase(sessionId, sessionType, batchNumber, stockCode, expiryDate = null, palletNumber = null) {
            if (!supabase || !sessionId) return null;

            console.log('checkDuplicateInSupabase called:', { sessionId, sessionType, batchNumber, stockCode, expiryDate, palletNumber });

            try {
                // All scans are in stock_scans table - select fields needed for duplicate display
                const cleanBatch = String(batchNumber).trim();
                let query = supabase
                    .from('stock_scans')
                    .select('id,scanned_at,scanned_by,device_id,actual_cases')
                    .eq('session_id', sessionId)
                    .eq('batch_number', cleanBatch);

                // For RM, check stock_code and optionally expiry_date
                if (sessionType === 'RM') {
                    query = query.eq('stock_code', stockCode);
                    if (expiryDate) {
                        query = query.eq('expiry_date', expiryDate);
                    }
                } else {
                    // For FP, check pallet_number
                    if (palletNumber) {
                        const cleanPallet = String(palletNumber).trim();
                        console.log('Adding pallet_number filter:', cleanPallet);
                        query = query.eq('pallet_number', cleanPallet);
                    }
                }

                const { data, error } = await query.limit(1);

                console.log('Duplicate check query result:', { data, error });

                if (error) {
                    console.error('Error checking duplicate:', error);
                    return null;
                }
                if (data && data.length > 0) {
                    await logClientEvent('duplicate-detected', 'warning', sessionId, {
                        batchNumber,
                        stockCode,
                        sessionType
                    });
                    return data[0];
                }
                return null;
            } catch (err) {
                console.error('Failed to check duplicate in Supabase:', err);
                return null;
            }
        }

        // Check if RM item with same stock code, batch, expiry AND quantity already exists
        async function checkRMDuplicateQuantity(sessionId, stockCode, batchNumber, expiryDate, quantity) {
            if (!supabase || !sessionId) return null;

            try {
                let query = supabase
                    .from('stock_scans')
                    .select('id,scanned_at,scanned_by,device_id,actual_cases,location')
                    .eq('session_id', sessionId)
                    .eq('stock_code', stockCode)
                    .eq('batch_number', batchNumber)
                    .eq('actual_cases', quantity);

                if (expiryDate) {
                    query = query.eq('expiry_date', expiryDate);
                }

                const { data, error } = await query.limit(1);

                if (error) {
                    console.error('Error checking RM duplicate quantity:', error);
                    return null;
                }

                if (data && data.length > 0) {
                    return data[0];
                }
                return null;
            } catch (err) {
                console.error('Failed to check RM duplicate quantity:', err);
                return null;
            }
        }

        // Check if FP 5-digit manual entry with same batch AND quantity already exists
        // (5-digit entries don't have pallet numbers, so we check batch + quantity)
        async function checkFPManualDuplicateQuantity(sessionId, batchNumber, quantity) {
            if (!supabase || !sessionId) return null;

            try {
                const cleanBatch = String(batchNumber).trim();
                const { data, error } = await supabase
                    .from('stock_scans')
                    .select('id,scanned_at,scanned_by,device_id,actual_cases,pallet_number')
                    .eq('session_id', sessionId)
                    .eq('batch_number', cleanBatch)
                    .eq('actual_cases', quantity)
                    .is('pallet_number', null)  // Only check manual entries (no pallet number)
                    .limit(1);

                if (error) {
                    console.error('Error checking FP manual duplicate quantity:', error);
                    return null;
                }

                if (data && data.length > 0) {
                    return data[0];
                }
                return null;
            } catch (err) {
                console.error('Failed to check FP manual duplicate quantity:', err);
                return null;
            }
        }

        // Get unit type for a stock code from product_types table
        // If type is "ingredients" -> KG, otherwise -> UN (units)
        function getUnitTypeForStockCode(stockCode) {
            if (!stockCode) return 'units';
            const upperCode = stockCode.toUpperCase();

            // Check product_types database (loaded from Supabase)
            if (productTypeDatabase[upperCode]) {
                return productTypeDatabase[upperCode].unitType; // 'kg' or 'units'
            }

            // Default to units for unknown stock codes
            return 'units';
        }

        // Helper to convert DD/MM/YY to YYYY-MM-DD
        function convertDMYtoYMD(dateStr) {
            if (!dateStr) return null;
            // Check if already in YYYY-MM-DD format
            if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) return dateStr;

            // Check if in DD/MM/YY or DD/MM/YYYY format
            const match = dateStr.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})$/);
            if (match) {
                let [_, day, month, year] = match;
                if (year.length === 2) year = '20' + year;
                return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
            }
            return dateStr; // Return original if format unknown
        }

        function saveProductDatabase() {
            localStorage.setItem('productDatabase', JSON.stringify(productDatabase));
            // Also save to Supabase if available
            if (supabase && productsLoadedFromDB) {
                // For manual product additions, we could sync to Supabase here
                console.log('Product database saved locally');
            }
        }

        function saveRawMaterialsDatabase() {
            localStorage.setItem('rawMaterialsDatabase', JSON.stringify(rawMaterialsDatabase));
            if (supabase && rmProductsLoadedFromDB) {
                console.log('Raw materials database saved locally');
            }
        }

        // Add a new FP product to Supabase
        async function addProductToSupabase(batchNumber, stockCode, description) {
            if (!supabase) return false;
            try {
                const { error } = await supabase
                    .from('products')
                    .upsert({
                        batch_number: batchNumber,
                        stock_code: stockCode,
                        description: description
                    }, { onConflict: 'batch_number' });
                return !error;
            } catch (err) {
                console.error('Failed to add product to Supabase:', err);
                return false;
            }
        }

        // Add a new RM product to Supabase
        // Allows multiple entries with same stock_code + batch_number but different expiry_date
        async function addRawMaterialToSupabase(stockCode, description, batchNumber, expiryDate) {
            if (!supabase) return false;

            // Ensure date is in YYYY-MM-DD format
            const formattedExpiry = convertDMYtoYMD(expiryDate);

            try {
                // First check if this exact combination already exists
                const { data: existing } = await supabase
                    .from('raw_materials')
                    .select('id')
                    .eq('stock_code', stockCode)
                    .eq('batch_number', batchNumber || '')
                    .eq('expiry_date', formattedExpiry || null)
                    .maybeSingle();

                if (existing) {
                    console.log('Raw material entry already exists');
                    return true; // Already exists, no need to add
                }

                // Insert new entry (allows multiple expiry dates for same stock_code + batch)
                const { error } = await supabase
                    .from('raw_materials')
                    .insert({
                        stock_code: stockCode,
                        description: description,
                        batch_number: batchNumber || null,
                        expiry_date: formattedExpiry || null
                    });
                return !error;
            } catch (err) {
                console.error('Failed to add raw material to Supabase:', err);
                return false;
            }
        }

        // Add a new product type to Supabase (only if it doesn't exist)
        async function addProductTypeToSupabase(stockCode, productType, description) {
            if (!supabase) return { success: false, error: 'Supabase not available' };
            try {
                // First check if this stock_code already exists
                const { data: existing, error: checkError } = await supabase
                    .from('product_types')
                    .select('stock_code')
                    .eq('stock_code', stockCode.toUpperCase())
                    .maybeSingle();

                if (checkError) {
                    console.error('Error checking existing product type:', checkError);
                    return { success: false, error: checkError.message };
                }

                if (existing) {
                    console.log('Product type already exists:', stockCode);
                    return { success: false, error: 'Product already exists', exists: true };
                }

                // Insert new entry
                const { error } = await supabase
                    .from('product_types')
                    .insert({
                        stock_code: stockCode.toUpperCase(),
                        type: productType,
                        description: description
                    });

                if (error) {
                    console.error('Error inserting product type:', error);
                    return { success: false, error: error.message };
                }

                // Update local cache
                productTypeDatabase[stockCode.toUpperCase()] = {
                    productType: productType,
                    description: description,
                    unitType: productType.toLowerCase() === 'ingredient' ? 'kg' : 'units'
                };
                localStorage.setItem('productTypeDatabase', JSON.stringify(productTypeDatabase));

                return { success: true };
            } catch (err) {
                console.error('Failed to add product type to Supabase:', err);
                return { success: false, error: err.message };
            }
        }

        // Bulk add product types to Supabase (only adds ones that don't exist)
        async function bulkAddProductTypesToSupabase(products) {
            if (!supabase) return { success: false, error: 'Supabase not available', added: 0, skipped: 0 };

            try {
                // Get all existing stock codes
                const { data: existing, error: fetchError } = await supabase
                    .from('product_types')
                    .select('stock_code');

                if (fetchError) {
                    console.error('Error fetching existing product types:', fetchError);
                    return { success: false, error: fetchError.message, added: 0, skipped: 0 };
                }

                const existingCodes = new Set((existing || []).map(p => p.stock_code?.toUpperCase()));

                // Filter out products that already exist
                const newProducts = products.filter(p => !existingCodes.has(p.stock_code?.toUpperCase()));
                const skippedCount = products.length - newProducts.length;

                if (newProducts.length === 0) {
                    return { success: true, added: 0, skipped: skippedCount, message: 'All products already exist' };
                }

                // Insert new products
                const { error: insertError } = await supabase
                    .from('product_types')
                    .insert(newProducts.map(p => ({
                        stock_code: p.stock_code?.toUpperCase(),
                        type: p.type || 'Non-Ingredient',
                        description: p.description || ''
                    })));

                if (insertError) {
                    console.error('Error bulk inserting product types:', insertError);
                    return { success: false, error: insertError.message, added: 0, skipped: skippedCount };
                }

                // Update local cache
                newProducts.forEach(p => {
                    const stockCode = p.stock_code?.toUpperCase();
                    productTypeDatabase[stockCode] = {
                        productType: p.type || 'Non-Ingredient',
                        description: p.description || '',
                        unitType: (p.type || '').toLowerCase() === 'ingredient' ? 'kg' : 'units'
                    };
                });
                localStorage.setItem('productTypeDatabase', JSON.stringify(productTypeDatabase));

                // Reload from Supabase to ensure consistency
                await loadProductTypesFromSupabase(true);

                return { success: true, added: newProducts.length, skipped: skippedCount };
            } catch (err) {
                console.error('Failed to bulk add product types:', err);
                return { success: false, error: err.message, added: 0, skipped: 0 };
            }
        }

        // ===========================================
        // WAREHOUSE LOCATIONS DATABASE
        // ===========================================

        // Cache for warehouse locations
        let warehouseLocationsCache = JSON.parse(localStorage.getItem('warehouseLocationsCache') || '[]');
        let locationsLoadedFromDB = false;

        // Parse location code (e.g., RACK-01-F-A-3 or FLOOR-A1)
        function parseLocationCode(code) {
            if (!code || typeof code !== 'string') return null;
            code = code.trim().toUpperCase();

            if (code.startsWith('RACK-')) {
                // Format: RACK-{##}-{F/B}-{ROW}-{COL}
                const parts = code.split('-');
                if (parts.length === 5) {
                    return {
                        type: 'rack',
                        rackNumber: parts[1],
                        face: parts[2],      // F or B
                        row: parts[3],       // A, B, C...
                        column: parseInt(parts[4])
                    };
                }
            } else if (code.startsWith('FLOOR-')) {
                // Format: FLOOR-{ZONE}
                const zone = code.replace('FLOOR-', '');
                if (zone) {
                    return {
                        type: 'floor',
                        zone: zone
                    };
                }
            }
            return null;
        }

        // Check if a scanned code is a location code
        function isLocationCode(code) {
            if (!code || typeof code !== 'string') return false;
            const upper = code.trim().toUpperCase();
            return upper.startsWith('RACK-') || upper.startsWith('FLOOR-');
        }

        // Generate location code from components
        function buildLocationCode(type, data) {
            if (type === 'rack') {
                const { rackNumber, face, row, column } = data;
                const paddedRack = String(rackNumber).padStart(2, '0');
                return `RACK-${paddedRack}-${face}-${row}-${column}`;
            } else if (type === 'floor') {
                return `FLOOR-${data.zone}`;
            }
            return '';
        }

        // Load warehouse locations from Supabase
        let _locationsLoadPromise = null;
        async function loadLocationsFromSupabase(forceReload = false) {
            if (_locationsLoadPromise && !forceReload) return _locationsLoadPromise;
            if (locationsLoadedFromDB && !forceReload) return true;
            if (!supabase) {
                console.log('Supabase not available, using cached locations');
                return false;
            }

            _locationsLoadPromise = (async () => {
                try {
                    console.log('Loading warehouse locations from Supabase...');
                    const { data, error } = await supabase
                        .from('warehouse_locations')
                        .select('*')
                        .eq('is_active', true)
                        .order('location_code', { ascending: true });

                    if (error) {
                        console.error('Error loading locations:', error);
                        return false;
                    }

                    if (data) {
                        warehouseLocationsCache = data;
                        localStorage.setItem('warehouseLocationsCache', JSON.stringify(data));
                        locationsLoadedFromDB = true;
                        console.log(`Loaded ${data.length} warehouse locations from Supabase`);
                        return true;
                    }
                    return false;
                } catch (err) {
                    console.error('Failed to load locations from Supabase:', err);
                    return false;
                }
            })();

            return _locationsLoadPromise;
        }

        // Get all locations (from cache)
        function getWarehouseLocations(warehouse = null) {
            let locations = warehouseLocationsCache;
            if (warehouse) {
                locations = locations.filter(l => l.warehouse === warehouse || !l.warehouse);
            }
            return locations;
        }

        // Get location by code
        function getLocationByCode(code) {
            return warehouseLocationsCache.find(l => l.location_code === code.toUpperCase());
        }

        // Add a new warehouse location to Supabase
        async function addLocationToSupabase(locationData) {
            if (!supabase) return { success: false, error: 'Supabase not available' };

            try {
                const locationCode = locationData.location_code.toUpperCase();

                // Check if already exists
                const existing = getLocationByCode(locationCode);
                if (existing) {
                    return { success: false, error: 'Location already exists', exists: true };
                }

                const { data, error } = await supabase
                    .from('warehouse_locations')
                    .insert({
                        location_code: locationCode,
                        location_type: locationData.location_type,
                        rack_number: locationData.rack_number || null,
                        rack_face: locationData.rack_face || null,
                        rack_row: locationData.rack_row || null,
                        rack_column: locationData.rack_column || null,
                        floor_zone: locationData.floor_zone || null,
                        warehouse: locationData.warehouse || null,
                        description: locationData.description || null,
                        created_by: getUserName() || 'Unknown'
                    })
                    .select()
                    .single();

                if (error) {
                    console.error('Error adding location:', error);
                    return { success: false, error: error.message };
                }

                // Update cache
                warehouseLocationsCache.push(data);
                localStorage.setItem('warehouseLocationsCache', JSON.stringify(warehouseLocationsCache));

                return { success: true, data };
            } catch (err) {
                console.error('Failed to add location:', err);
                return { success: false, error: err.message };
            }
        }

        // Update a warehouse location
        async function updateLocationInSupabase(id, updates) {
            if (!supabase) return { success: false, error: 'Supabase not available' };

            try {
                const { data, error } = await supabase
                    .from('warehouse_locations')
                    .update(updates)
                    .eq('id', id)
                    .select()
                    .single();

                if (error) {
                    console.error('Error updating location:', error);
                    return { success: false, error: error.message };
                }

                // Update cache
                const idx = warehouseLocationsCache.findIndex(l => l.id === id);
                if (idx >= 0) {
                    warehouseLocationsCache[idx] = data;
                    localStorage.setItem('warehouseLocationsCache', JSON.stringify(warehouseLocationsCache));
                }

                return { success: true, data };
            } catch (err) {
                console.error('Failed to update location:', err);
                return { success: false, error: err.message };
            }
        }

        // Delete (deactivate) a warehouse location
        async function deleteLocationFromSupabase(id) {
            if (!supabase) return { success: false, error: 'Supabase not available' };

            try {
                // Soft delete by setting is_active to false
                const { error } = await supabase
                    .from('warehouse_locations')
                    .update({ is_active: false })
                    .eq('id', id);

                if (error) {
                    console.error('Error deleting location:', error);
                    return { success: false, error: error.message };
                }

                // Remove from cache
                warehouseLocationsCache = warehouseLocationsCache.filter(l => l.id !== id);
                localStorage.setItem('warehouseLocationsCache', JSON.stringify(warehouseLocationsCache));

                return { success: true };
            } catch (err) {
                console.error('Failed to delete location:', err);
                return { success: false, error: err.message };
            }
        }

        // Bulk add locations to Supabase
        async function bulkAddLocationsToSupabase(locations) {
            if (!supabase) return { success: false, error: 'Supabase not available', added: 0, skipped: 0 };

            try {
                // Get existing location codes
                const existingCodes = new Set(warehouseLocationsCache.map(l => l.location_code));

                // Filter out duplicates
                const newLocations = locations.filter(l => !existingCodes.has(l.location_code.toUpperCase()));
                const skippedCount = locations.length - newLocations.length;

                if (newLocations.length === 0) {
                    return { success: true, added: 0, skipped: skippedCount, message: 'All locations already exist' };
                }

                const { data, error } = await supabase
                    .from('warehouse_locations')
                    .insert(newLocations.map(l => ({
                        location_code: l.location_code.toUpperCase(),
                        location_type: l.location_type,
                        rack_number: l.rack_number || null,
                        rack_face: l.rack_face || null,
                        rack_row: l.rack_row || null,
                        rack_column: l.rack_column || null,
                        floor_zone: l.floor_zone || null,
                        warehouse: l.warehouse || null,
                        description: l.description || null,
                        created_by: getUserName() || 'Unknown'
                    })))
                    .select();

                if (error) {
                    console.error('Error bulk adding locations:', error);
                    return { success: false, error: error.message, added: 0, skipped: skippedCount };
                }

                // Update cache
                warehouseLocationsCache.push(...(data || []));
                localStorage.setItem('warehouseLocationsCache', JSON.stringify(warehouseLocationsCache));

                return { success: true, added: newLocations.length, skipped: skippedCount };
            } catch (err) {
                console.error('Failed to bulk add locations:', err);
                return { success: false, error: err.message, added: 0, skipped: 0 };
            }
        }


        // Generate device ID
        const DEVICE_ID = localStorage.getItem('deviceId') || (() => {
            const id = 'device_' + Math.random().toString(36).substring(2, 15);
            localStorage.setItem('deviceId', id);
            return id;
        })();

        // Get/set user name
        const getUserName = () => localStorage.getItem('userName') || '';
        const setUserName = (name) => localStorage.setItem('userName', name);

        // Warehouse location for all users (PSA or PML)
        // Checks localStorage first, then Supabase cache
        const getUserWarehouse = () => {
            const localWarehouse = localStorage.getItem('userWarehouse');
            if (localWarehouse) return localWarehouse;

            // Check Supabase cached user data
            const name = getUserName();
            if (cachedUserData && cachedUserData.name?.toLowerCase() === name?.toLowerCase()) {
                return cachedUserData.warehouse || '';
            }

            return '';
        };
        const setUserWarehouse = (warehouse) => localStorage.setItem('userWarehouse', warehouse);

        // Role detection based on name suffix (temporary for testing)
        // *** = admin (full access)
        // * = supervisor (can create sessions, see own session history)
        // no suffix = operator (basic scanning only)
        // Now also checks Supabase cached data if available
        const getUserRole = () => {
            const name = getUserName();

            // Check cached Supabase user data first
            if (cachedUserData && cachedUserData.name?.toLowerCase() === name?.toLowerCase()) {
                return cachedUserData.role || 'operator';
            }

            // Fallback to name suffix detection
            if (name.endsWith('***')) return 'admin';
            if (name.endsWith('*')) return 'supervisor';
            return 'operator';
        };

        const getDisplayName = () => {
            const name = getUserName();

            // Use Supabase display name if available
            if (cachedUserData && cachedUserData.name?.toLowerCase() === name?.toLowerCase()) {
                return cachedUserData.display_name || name;
            }

            // Fallback: Remove role suffixes for display
            return name.replace(/\*+$/, '').trim();
        };

        const canCreateSession = () => {
            const role = getUserRole();
            return role === 'admin' || role === 'supervisor';
        };

        const canViewSettings = () => {
            return getUserRole() === 'admin';
        };

        const canViewHistory = () => {
            const role = getUserRole();
            return role === 'admin' || role === 'supervisor';
        };

        const canViewProductDatabase = () => {
            return getUserRole() === 'admin';
        };

        // Check if user needs to select warehouse
        const userNeedsWarehouse = () => {
            const role = getUserRole();
            // Admins don't need warehouse (they see everything)
            if (role === 'admin') return false;
            // Supervisors and operators need warehouse
            return !getUserWarehouse();
        };

        // ===========================================
        // SUPABASE USER & DEVICE SYNC
        // ===========================================

        // Cache for user data from Supabase
        let cachedUserData = null;
        let userDataLastFetched = null;
        const USER_CACHE_TTL_MS = 60000; // 1 minute cache

        // Sync current user to Supabase
        const syncUserToSupabase = async (name, role, warehouse) => {
            if (!supabase || db.mode !== 'supabase') return null;

            try {
                const displayName = name.replace(/\*+$/, '').trim();
                const { data, error } = await supabase.rpc('upsert_app_user', {
                    p_name: name,
                    p_display_name: displayName,
                    p_role: role,
                    p_warehouse: warehouse || null
                });

                if (error) {
                    console.warn('Failed to sync user to Supabase:', error);
                    return null;
                }

                // Update cache
                cachedUserData = data;
                userDataLastFetched = Date.now();

                return data;
            } catch (err) {
                console.error('Error syncing user:', err);
                return null;
            }
        };

        // Sync current device to Supabase
        const syncDeviceToSupabase = async () => {
            if (!supabase || db.mode !== 'supabase') return null;

            try {
                const userName = getUserName();
                const platform = detectPlatform();
                const userAgent = navigator.userAgent;

                const { data, error } = await supabase.rpc('upsert_app_device', {
                    p_device_id: DEVICE_ID,
                    p_user_name: userName || null,
                    p_platform: platform,
                    p_user_agent: userAgent,
                    p_metadata: { screenWidth: window.innerWidth, screenHeight: window.innerHeight }
                });

                if (error) {
                    console.warn('Failed to sync device to Supabase:', error);
                    return null;
                }

                return data;
            } catch (err) {
                console.error('Error syncing device:', err);
                return null;
            }
        };

        // Detect platform from user agent
        const detectPlatform = () => {
            const ua = navigator.userAgent;
            if (/iPad|iPhone|iPod/.test(ua)) return 'iOS';
            if (/Android/.test(ua)) return 'Android';
            if (/Windows/.test(ua)) return 'Windows';
            if (/Mac/.test(ua)) return 'macOS';
            if (/Linux/.test(ua)) return 'Linux';
            return 'Unknown';
        };

        // Get user data from Supabase (with caching)
        const getUserFromSupabase = async (name) => {
            if (!supabase || db.mode !== 'supabase') return null;

            // Check cache
            if (cachedUserData && userDataLastFetched &&
                (Date.now() - userDataLastFetched) < USER_CACHE_TTL_MS &&
                cachedUserData.name?.toLowerCase() === name?.toLowerCase()) {
                return cachedUserData;
            }

            try {
                const { data, error } = await supabase.rpc('get_user_by_name', { p_name: name });

                if (error) {
                    console.warn('Failed to get user from Supabase:', error);
                    return null;
                }

                // Update cache
                cachedUserData = data;
                userDataLastFetched = Date.now();

                return data;
            } catch (err) {
                console.error('Error getting user:', err);
                return null;
            }
        };

        // Get user role from Supabase (fallback to name suffix)
        const getUserRoleFromSupabase = async (name) => {
            if (!name) return 'operator';

            // Try Supabase first
            const userData = await getUserFromSupabase(name);
            if (userData?.role) {
                return userData.role;
            }

            // Fallback to name suffix detection
            if (name.endsWith('***')) return 'admin';
            if (name.endsWith('*')) return 'supervisor';
            return 'operator';
        };

        // List all users from Supabase (for admin)
        const listUsersFromSupabase = async (warehouse = null) => {
            if (!supabase || db.mode !== 'supabase') return [];

            try {
                const { data, error } = await supabase.rpc('list_app_users', {
                    p_warehouse: warehouse
                });

                if (error) {
                    console.warn('Failed to list users from Supabase:', error);
                    return [];
                }

                return data || [];
            } catch (err) {
                console.error('Error listing users:', err);
                return [];
            }
        };

        // List all devices from Supabase (for admin)
        const listDevicesFromSupabase = async (activeOnly = true) => {
            if (!supabase || db.mode !== 'supabase') return [];

            try {
                const { data, error } = await supabase.rpc('list_app_devices', {
                    p_active_only: activeOnly
                });

                if (error) {
                    console.warn('Failed to list devices from Supabase:', error);
                    return [];
                }

                return data || [];
            } catch (err) {
                console.error('Error listing devices:', err);
                return [];
            }
        };

        // ===========================================
        // LIVE SESSIONS FROM SUPABASE
        // ===========================================

        // Get all live (active/paused) sessions from Supabase
        const getLiveSessionsFromSupabase = async (warehouse = null) => {
            if (!supabase || db.mode !== 'supabase') return [];

            try {
                const { data, error } = await supabase.rpc('get_live_sessions', {
                    p_warehouse: warehouse
                });

                if (error) {
                    console.warn('Failed to get live sessions from Supabase:', error);
                    return [];
                }

                return data || [];
            } catch (err) {
                console.error('Error getting live sessions:', err);
                return [];
            }
        };

        // Get session summary with device info and scan counts
        const getSessionSummaryFromSupabase = async (sessionId) => {
            if (!supabase || db.mode !== 'supabase' || !sessionId) return null;

            try {
                const { data, error } = await supabase.rpc('get_session_summary', {
                    p_session_id: sessionId
                });

                if (error) {
                    console.warn('Failed to get session summary from Supabase:', error);
                    return null;
                }

                return data?.[0] || null;
            } catch (err) {
                console.error('Error getting session summary:', err);
                return null;
            }
        };

        // End a session via Supabase (supervisor action)
        const endSessionInSupabase = async (sessionId, endedBy = null) => {
            if (!supabase || db.mode !== 'supabase' || !sessionId) return null;

            try {
                const { data, error } = await supabase.rpc('end_session', {
                    p_session_id: sessionId,
                    p_ended_by: endedBy || getUserName(),
                    p_device_id: DEVICE_ID
                });

                if (error) {
                    console.warn('Failed to end session in Supabase:', error);
                    return null;
                }

                return data;
            } catch (err) {
                console.error('Error ending session:', err);
                return null;
            }
        };

        // Get/set active stock take
        const getActiveStockTake = () => {
            const data = localStorage.getItem('activeStockTake');
            return data ? JSON.parse(data) : null;
        };
        const setActiveStockTake = (stockTake) => {
            localStorage.setItem('activeStockTake', JSON.stringify(stockTake));
        };
        const clearActiveStockTake = () => {
            localStorage.removeItem('activeStockTake');
        };

        // Session settings
        const getSessionSettings = () => {
            const defaults = {
                locationScanningEnabled: false,
                currentLocation: '',
                site: '',
                aisle: '',
                rack: '',
                // Warehouse location system
                warehouseConfig: {
                    name: 'Main Warehouse',
                    racks: [], // Array of rack configs: { id, name, rows, columns, levels }
                    floorLocations: [] // Array of floor location names
                },
                selectedWarehouseLocation: null // { type: 'rack' | 'floor', rackId?, level?, position?, floorId? }
            };
            const data = localStorage.getItem('sessionSettings');
            return data ? { ...defaults, ...JSON.parse(data) } : defaults;
        };
        const saveSessionSettings = (settings) => {
            localStorage.setItem('sessionSettings', JSON.stringify(settings));
        };

        // Generate location code from selection
        const generateLocationCode = (settings) => {
            const loc = settings.selectedWarehouseLocation;
            if (!loc) return '';

            if (loc.type === 'floor') {
                return `FLOOR-${loc.floorId}`;
            } else if (loc.type === 'rack') {
                const rack = settings.warehouseConfig?.racks?.find(r => r.id === loc.rackId);
                const rackName = rack?.name || loc.rackId;
                const level = String.fromCharCode(64 + (loc.level || 1)); // 1=A, 2=B, etc.
                const position = loc.position || 1;
                return `${rackName}-${level}${position}`;
            }
            return '';
        };

        // Session management - track sessions per day
        const getSessionsForDate = (date, sessionType = null) => {
            const data = localStorage.getItem(`sessions_${date}`);
            const sessions = data ? JSON.parse(data) : [];
            if (sessionType) {
                return sessions.filter(s => s.sessionType === sessionType);
            }
            return sessions;
        };
        const saveSessionsForDate = (date, sessions) => {
            localStorage.setItem(`sessions_${date}`, JSON.stringify(sessions));
        };
        const getNextSessionNumber = (date, sessionType = 'FP') => {
            const sessions = getSessionsForDate(date, sessionType);
            return sessions.length + 1;
        };
        const addSession = async (date, session) => {
            session.date = session.date || date;
            const allSessions = getSessionsForDate(date);
            const existingIndex = allSessions.findIndex(s => s.id === session.id);
            if (existingIndex >= 0) {
                allSessions[existingIndex] = session;
            } else {
                allSessions.push(session);
            }
            saveSessionsForDate(date, allSessions);
            await saveSessionToSupabase(session);
        };
        const updateSession = async (date, sessionId, updates) => {
            const sessions = getSessionsForDate(date);
            const idx = sessions.findIndex(s => s.id === sessionId);
            if (idx >= 0) {
                sessions[idx].date = sessions[idx].date || date;
                sessions[idx] = { ...sessions[idx], ...updates };
                saveSessionsForDate(date, sessions);
                await saveSessionToSupabase(sessions[idx]);
            }
        };

        // Get active (non-completed) sessions for joining
        const getActiveSessionsForDate = (date) => {
            const sessions = getSessionsForDate(date);
            const role = getUserRole();
            const userWarehouse = getUserWarehouse();

            return sessions.filter(s => {
                // Must be active
                if (s.status !== 'active') return false;

                // Admins see all sessions
                if (role === 'admin') return true;

                // Non-admins with a warehouse only see matching sessions
                if (userWarehouse) {
                    const sessionWarehouse = s.warehouse || s.metadata?.warehouse || '';
                    return sessionWarehouse === userWarehouse;
                }

                return true;
            });
        };

        // Add a device to an existing session
        const joinSession = async (date, sessionId, deviceId, userName) => {
            const sessions = getSessionsForDate(date);
            const idx = sessions.findIndex(s => s.id === sessionId);
            if (idx >= 0) {
                sessions[idx].date = sessions[idx].date || date;
                if (!sessions[idx].devices) {
                    sessions[idx].devices = [];
                }
                // Check if device already in session
                const existingDevice = sessions[idx].devices.find(d => d.deviceId === deviceId);
                if (existingDevice) {
                    // Reactivate the device
                    existingDevice.status = 'active';
                    existingDevice.userName = userName;
                    existingDevice.rejoinedAt = new Date().toISOString();
                    existingDevice.lastSeen = new Date().toISOString();
                } else {
                    sessions[idx].devices.push({
                        deviceId: deviceId,
                        userName: userName,
                        status: 'active',
                        joinedAt: new Date().toISOString(),
                        lastSeen: new Date().toISOString()
                    });
                }
                saveSessionsForDate(date, sessions);
                await saveSessionToSupabase(sessions[idx]);
                return sessions[idx];
            }
            return null;
        };

        // Mark a device as completed in a session (session stays open until ended manually)
        const markDeviceCompleted = async (date, sessionId, deviceId) => {
            const sessions = getSessionsForDate(date);
            const idx = sessions.findIndex(s => s.id === sessionId);
            if (idx >= 0) {
                sessions[idx].date = sessions[idx].date || date;
                if (sessions[idx].devices) {
                    const device = sessions[idx].devices.find(d => d.deviceId === deviceId);
                    if (device) {
                        device.status = 'completed';
                        device.completedAt = new Date().toISOString();
                        device.lastSeen = new Date().toISOString();
                    }
                }
                saveSessionsForDate(date, sessions);
                await saveSessionToSupabase(sessions[idx]);
                return sessions[idx];
            }
            return null;
        };

        // Get session by ID
        const getSessionById = (date, sessionId) => {
            const sessions = getSessionsForDate(date);
            return sessions.find(s => s.id === sessionId);
        };

        // Supabase session helpers
        const supabaseSessionsEnabled = Boolean(supabase);

        const mapSupabaseSession = (row) => ({
            id: row.id,
            sessionNumber: row.session_number,
            sessionType: row.session_type,
            date: row.take_date,
            startedBy: row.started_by,
            startedAt: row.started_at,
            completedAt: row.completed_at,
            status: row.status || 'active',
            devices: (row.metadata && row.metadata.devices) || [],
            warehouse: (row.metadata && row.metadata.warehouse) || '',
            metadata: row.metadata || {}
        });

        const buildSupabaseSessionPayload = (session) => {
            const fallbackDate = session.startedAt ? new Date(session.startedAt).toISOString().split('T')[0] : new Date().toISOString().split('T')[0];
            // Preserve warehouse from metadata if session.warehouse is not set
            const warehouse = session.warehouse || session.metadata?.warehouse || null;
            return {
                id: session.id,
                session_type: session.sessionType,
                session_number: session.sessionNumber,
                take_date: session.date || fallbackDate,
                status: session.status || 'active',
                started_by: session.startedBy,
                started_at: session.startedAt,
                completed_at: session.completedAt || null,
                metadata: {
                    ...(session.metadata || {}),
                    devices: session.devices || [],
                    warehouse: warehouse,
                    lastUpdatedBy: session.lastUpdatedBy || (session.devices?.find(d => d.deviceId === DEVICE_ID)?.userName || null),
                    lastUpdatedAt: new Date().toISOString()
                }
            };
        };

        async function syncSessionsFromSupabase(date) {
            if (!supabaseSessionsEnabled || !date) return;
            try {
                const { data, error } = await supabase
                    .from('stock_takes')
                    .select('*')
                    .eq('take_date', date)
                    .order('session_number', { ascending: true });
                if (error) throw error;
                let mapped = (data || []).map(mapSupabaseSession);
                const sessionIds = mapped.map(s => s.id).filter(Boolean);
                if (sessionIds.length > 0) {
                    const devicesBySession = await fetchSessionDevicesMap(sessionIds);
                    mapped = mapped.map(session => ({
                        ...session,
                        devices: devicesBySession[session.id] || session.devices || []
                    }));
                }
                saveSessionsForDate(date, mapped);
                return mapped;
            } catch (err) {
                console.error('Failed to sync sessions from Supabase:', err);
                await logClientEvent('session-sync-failed', 'error', null, { date, message: err.message });
                return null;
            }
        }

        async function saveSessionToSupabase(session) {
            if (!supabaseSessionsEnabled || !session) return true;
            const isDuplicateError = (err) => err?.code === '23505' || /duplicate key value/i.test(err?.message || '');

            try {
                // First, check if session already exists to preserve started_by
                const { data: existing } = await supabase
                    .from('stock_takes')
                    .select('started_by, started_at, metadata')
                    .eq('id', session.id)
                    .maybeSingle();

                // Build payload, preserving original started_by and warehouse if they exist
                const payload = buildSupabaseSessionPayload(session);
                if (existing) {
                    // Preserve original creator info - never overwrite started_by
                    payload.started_by = existing.started_by || payload.started_by;
                    payload.started_at = existing.started_at || payload.started_at;
                    // Preserve original warehouse if not in current payload
                    if (!payload.metadata.warehouse && existing.metadata?.warehouse) {
                        payload.metadata.warehouse = existing.metadata.warehouse;
                    }
                }

                const { error } = await supabase
                    .from('stock_takes')
                    .upsert(payload, { onConflict: 'id' });
                if (!error) {
                    return true;
                }

                if (isDuplicateError(error)) {
                    const { error: updateError } = await supabase
                        .from('stock_takes')
                        .update(payload)
                        .eq('id', session.id);
                    if (!updateError) {
                        return true;
                    }
                    throw updateError;
                }

                throw error;
            } catch (err) {
                console.error('Failed to save session to Supabase:', err);
                await logClientEvent('session-save-failed', 'error', session?.id || null, {
                    message: err?.message || 'unknown error',
                    code: err?.code || null,
                    details: err?.details || null
                });
                return false;
            }
        }

        async function fetchSessionDevicesMap(sessionIds = []) {
            if (!supabaseSessionsEnabled || sessionIds.length === 0) return {};
            try {
                const { data, error } = await supabase
                    .from('session_devices')
                    .select('*')
                    .in('session_id', sessionIds);
                if (error) throw error;
                return (data || []).reduce((acc, device) => {
                    if (!acc[device.session_id]) {
                        acc[device.session_id] = [];
                    }
                    acc[device.session_id].push({
                        id: device.id,
                        sessionId: device.session_id,
                        deviceId: device.device_id,
                        userName: device.user_name,
                        role: device.role,
                        status: device.status,
                        lastSeen: device.last_seen,
                        joinedAt: device.joined_at,
                        leftAt: device.left_at
                    });
                    return acc;
                }, {});
            } catch (err) {
                console.error('Failed to load session devices:', err);
                await logClientEvent('session-devices-failed', 'error', null, { ids: sessionIds, message: err.message });
                return {};
            }
        }

        async function upsertSessionDevicePresence(sessionId, status = 'active', sessionSnapshot = null) {
            if (!supabaseSessionsEnabled || !sessionId) return;

            const invokeHeartbeat = async () => {
                const { error } = await supabase.rpc('upsert_session_device', {
                    p_session_id: sessionId,
                    p_device_id: DEVICE_ID,
                    p_user_name: getUserName() || 'Unknown',
                    p_role: 'operator',
                    p_status: status
                });
                if (error) throw error;
            };

            const isMissingSessionError = (err) => {
                if (!err) return false;
                if (err.code === '23503') return true; // foreign key violation
                return typeof err.message === 'string' && err.message.includes('session_devices_session_id_fkey');
            };

            try {
                await invokeHeartbeat();
            } catch (err) {
                if (isMissingSessionError(err) && sessionSnapshot) {
                    console.warn('Heartbeat failed because session is missing in Supabase. Attempting to re-save session before retrying.');
                    const saved = await saveSessionToSupabase(sessionSnapshot);
                    if (saved) {
                        await new Promise((resolve) => setTimeout(resolve, 300));
                        try {
                            await invokeHeartbeat();
                            return;
                        } catch (retryErr) {
                            console.error('Heartbeat retry still failing:', retryErr);
                            await logClientEvent('heartbeat-retry-failed', 'error', sessionId, {
                                status,
                                message: retryErr?.message || 'retry failed',
                                code: retryErr?.code || null
                            });
                            return;
                        }
                    }
                }

                console.error('Heartbeat failed:', err);
                await logClientEvent('heartbeat-failed', 'warning', sessionId, {
                    status,
                    message: err?.message || 'unknown error',
                    code: err?.code || null,
                    details: err?.details || null
                });
            }
        }

        async function changeSessionStatusSupabase(session, nextStatus, reason = '', metadata = {}) {
            if (!supabaseSessionsEnabled || !session?.id) return null;
            try {
                const { data: existing } = await supabase
                    .from('stock_takes')
                    .select('status')
                    .eq('id', session.id)
                    .maybeSingle();
                const timestamps = {
                    paused_at: nextStatus === 'paused' ? new Date().toISOString() : session.paused_at,
                    resumed_at: nextStatus === 'active' ? new Date().toISOString() : session.resumed_at,
                    completed_at: nextStatus === 'completed' ? new Date().toISOString() : session.completed_at
                };
                const { data, error } = await supabase
                    .from('stock_takes')
                    .update({ status: nextStatus, metadata: { ...(session.metadata || {}), ...metadata }, ...timestamps })
                    .eq('id', session.id)
                    .select()
                    .maybeSingle();
                if (error) throw error;
                await supabase
                    .from('session_status_events')
                    .insert({
                        session_id: session.id,
                        previous_status: existing?.status || session.status,
                        next_status: nextStatus,
                        reason,
                        actor: getUserName() || 'Unknown',
                        actor_device_id: DEVICE_ID,
                        metadata
                    });
                await updateSession(session.date, session.id, { status: nextStatus, ...timestamps, metadata: { ...(session.metadata || {}), ...metadata } });
                return data;
            } catch (err) {
                console.error('Failed to update session status:', err);
                await logClientEvent('session-status-failed', 'error', session?.id || null, { nextStatus, reason, message: err.message });
                return null;
            }
        }

        async function logClientEvent(eventType, severity = 'info', sessionId = null, payload = {}) {
            if (!supabase) return;
            try {
                await supabase.rpc('log_event', {
                    p_event_type: eventType,
                    p_severity: severity,
                    p_session_id: sessionId,
                    p_device_id: DEVICE_ID,
                    p_payload: payload
                });
            } catch (err) {
                const unauthorized = err?.code === 'PGRST301' || err?.code === '401' || /Unauthorized/i.test(err?.message || '');
                if (unauthorized) {
                    console.debug('log_event skipped (unauthorized)');
                } else {
                    console.warn('log_event failed', err);
                }
            }
        }

        class ScannerApp {
            constructor() {
                this.scans = [];
                this.scanner = null;
                this.preferredCameraId = null;
                this.isScanning = false;
                this.currentScan = null;
                this.showingCaseEntry = false;
                this.showingProductDB = false;
                this.showingRMProductDB = false;
                this.showingSettings = false;
                this.showingStartStockTake = false;
                this.showingExpirySelection = false;
                this.showingSessionHistory = false;
                this.showingWarehouseSetup = false;
                this.showingLocationPicker = false;
                this.showingLocationManagement = false; // Location management page
                this.showingQRGenerator = false; // QR code generator page
                this.activeLocation = null; // Current scanned location (e.g., RACK-01-F-A-3)
                this.selectedRackForPicker = null;
                this.selectedStockTakeType = null; // 'FP' or 'RM' - selected before session
                this.historySessions = [];
                this.historyScans = [];
                this.historyLoading = false; // Loading state for session history
                this.selectedHistorySession = null;
                this.pendingScan = null;
                this.pendingScanKeys = new Set(); // Track scans being processed to prevent double-capture
                this.currentTakeDate = new Date().toISOString().split('T')[0];
                this.syncInterval = null;
                this.heartbeatInterval = null;
                this.lastHeartbeatAt = 0;
                this.hasPrefetchedReferenceData = false;
                this.activeStockTake = getActiveStockTake();
                this.sessionSettings = getSessionSettings();
                this.lastSessionSync = 0;
                this.isBrowserOnline = navigator.onLine;

                // Modal State
                this.modalState = null; // { title, message, type, fields, onConfirm, onCancel, confirmText, cancelText }

                // Performance optimization
                this._renderScheduled = false;
                this._lastRenderTime = 0;
                this._renderDebounceMs = 16; // ~60fps max
                this._pendingRender = false; // True when render was skipped during input and needs to happen later

                this.init();
            }

            get usingSupabaseDB() {
                return db.mode === 'supabase';
            }

            toggleLocationScanning() {
                this.sessionSettings.locationScanningEnabled = !this.sessionSettings.locationScanningEnabled;
                if (!this.sessionSettings.locationScanningEnabled) {
                    this.sessionSettings.currentLocation = '';
                    this.sessionSettings.site = '';
                    this.sessionSettings.aisle = '';
                    this.sessionSettings.rack = '';
                }
                saveSessionSettings(this.sessionSettings);
                this.render();
            }

            setLocation(location) {
                this.sessionSettings.currentLocation = location;
                saveSessionSettings(this.sessionSettings);
                this.render();
            }

            updateLocationHierarchy(level, value) {
                if (!['site', 'aisle', 'rack'].includes(level)) return;
                this.sessionSettings[level] = value;
                saveSessionSettings(this.sessionSettings);
                // Don't re-render here - it causes the input to lose focus
                // The value is already saved, and the UI will update on next render
            }

            // ===== WAREHOUSE LOCATION SYSTEM =====

            showWarehouseSetup() {
                this.showingWarehouseSetup = true;
                this.render();
            }

            hideWarehouseSetup() {
                this.showingWarehouseSetup = false;
                this.render();
            }

            addRack() {
                this.showModal({
                    title: ' Add New Rack',
                    message: 'Configure the rack dimensions:',
                    type: 'form',
                    fields: [
                        { name: 'name', label: 'Rack Name', placeholder: 'e.g., RACK01, A1', required: true },
                        { name: 'columns', label: 'Columns (left to right)', type: 'number', value: '5', placeholder: '5', required: true },
                        { name: 'levels', label: 'Levels (bottom to top)', type: 'number', value: '4', placeholder: '4', required: true }
                    ],
                    confirmText: 'Add Rack',
                    onConfirm: (data) => {
                        const name = data.name?.trim().toUpperCase();
                        const columns = parseInt(data.columns) || 5;
                        const levels = parseInt(data.levels) || 4;

                        if (!name) {
                            alert('Rack name is required');
                            return;
                        }

                        if (!this.sessionSettings.warehouseConfig) {
                            this.sessionSettings.warehouseConfig = { name: 'Main Warehouse', racks: [], floorLocations: [] };
                        }
                        if (!this.sessionSettings.warehouseConfig.racks) {
                            this.sessionSettings.warehouseConfig.racks = [];
                        }

                        // Check for duplicate
                        if (this.sessionSettings.warehouseConfig.racks.some(r => r.name === name)) {
                            alert('A rack with this name already exists');
                            return;
                        }

                        this.sessionSettings.warehouseConfig.racks.push({
                            id: 'rack_' + Date.now(),
                            name: name,
                            columns: columns,
                            levels: levels
                        });

                        saveSessionSettings(this.sessionSettings);
                        this.render();
                    }
                });
            }

            deleteRack(rackId) {
                if (!confirm('Delete this rack?')) return;

                if (this.sessionSettings.warehouseConfig?.racks) {
                    this.sessionSettings.warehouseConfig.racks = this.sessionSettings.warehouseConfig.racks.filter(r => r.id !== rackId);
                    saveSessionSettings(this.sessionSettings);
                    this.render();
                }
            }

            addFloorLocation() {
                this.showModal({
                    title: ' Add Floor Location',
                    message: 'Enter floor location name:',
                    type: 'input',
                    confirmText: 'Add',
                    onConfirm: (data) => {
                        const name = data.value?.trim().toUpperCase();
                        if (!name) {
                            alert('Name is required');
                            return;
                        }

                        if (!this.sessionSettings.warehouseConfig) {
                            this.sessionSettings.warehouseConfig = { name: 'Main Warehouse', racks: [], floorLocations: [] };
                        }
                        if (!this.sessionSettings.warehouseConfig.floorLocations) {
                            this.sessionSettings.warehouseConfig.floorLocations = [];
                        }

                        if (this.sessionSettings.warehouseConfig.floorLocations.includes(name)) {
                            alert('This floor location already exists');
                            return;
                        }

                        this.sessionSettings.warehouseConfig.floorLocations.push(name);
                        saveSessionSettings(this.sessionSettings);
                        this.render();
                    }
                });
            }

            deleteFloorLocation(name) {
                if (!confirm('Delete this floor location?')) return;

                if (this.sessionSettings.warehouseConfig?.floorLocations) {
                    this.sessionSettings.warehouseConfig.floorLocations = this.sessionSettings.warehouseConfig.floorLocations.filter(f => f !== name);
                    saveSessionSettings(this.sessionSettings);
                    this.render();
                }
            }

            showLocationPicker() {
                this.showingLocationPicker = true;
                this.selectedRackForPicker = null;
                this.render();
            }

            hideLocationPicker() {
                this.showingLocationPicker = false;
                this.selectedRackForPicker = null;
                this.render();
            }

            selectRackForPicker(rackId) {
                this.selectedRackForPicker = rackId;
                this.render();
            }

            selectRackPosition(rackId, level, position) {
                this.sessionSettings.selectedWarehouseLocation = {
                    type: 'rack',
                    rackId: rackId,
                    level: level,
                    position: position
                };
                this.sessionSettings.currentLocation = generateLocationCode(this.sessionSettings);
                saveSessionSettings(this.sessionSettings);
                this.hideLocationPicker();
            }

            selectFloorLocation(floorId) {
                this.sessionSettings.selectedWarehouseLocation = {
                    type: 'floor',
                    floorId: floorId
                };
                this.sessionSettings.currentLocation = generateLocationCode(this.sessionSettings);
                saveSessionSettings(this.sessionSettings);
                this.hideLocationPicker();
            }

            clearLocation() {
                this.activeLocation = null;
                this.sessionSettings.selectedWarehouseLocation = null;
                this.sessionSettings.currentLocation = '';
                this.sessionSettings.locationScanningEnabled = false;
                saveSessionSettings(this.sessionSettings);
                this.render();
            }

            // Show/hide Location Management page
            showLocationManagement() {
                this.showingLocationManagement = true;
                // Load locations from Supabase
                loadLocationsFromSupabase(true).then(() => this.render());
            }

            hideLocationManagement() {
                this.showingLocationManagement = false;
                this.render();
            }

            // Show/hide QR Generator page
            showQRGenerator() {
                this.showingQRGenerator = true;
                this._selectedLocationsForQR = new Set();
                // Ensure locations are loaded
                loadLocationsFromSupabase(true).then(() => this.render());
            }

            hideQRGenerator() {
                this.showingQRGenerator = false;
                this._selectedLocationsForQR = null;
                this.render();
            }

            // Toggle location selection for QR generation
            toggleLocationForQR(locationCode) {
                if (!this._selectedLocationsForQR) this._selectedLocationsForQR = new Set();
                if (this._selectedLocationsForQR.has(locationCode)) {
                    this._selectedLocationsForQR.delete(locationCode);
                } else {
                    this._selectedLocationsForQR.add(locationCode);
                }
                this.render();
            }

            // Select all locations for QR generation
            selectAllLocationsForQR() {
                const locations = getWarehouseLocations();
                this._selectedLocationsForQR = new Set(locations.map(l => l.location_code));
                this.render();
            }

            // Clear all location selections
            clearLocationSelections() {
                this._selectedLocationsForQR = new Set();
                this.render();
            }

            // Generate and show QR codes for printing
            async generateQRCodes() {
                const selectedCodes = Array.from(this._selectedLocationsForQR || []);
                if (selectedCodes.length === 0) {
                    alert('Please select at least one location');
                    return;
                }

                // Generate QR codes and open print window
                const printWindow = window.open('', '_blank');
                if (!printWindow) {
                    alert('Please allow pop-ups to print QR codes');
                    return;
                }

                printWindow.document.write(`
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <title>Location QR Codes</title>
                        <style>
                            * { margin: 0; padding: 0; box-sizing: border-box; }
                            body { font-family: Arial, sans-serif; padding: 20px; }
                            .qr-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; }
                            .qr-item { 
                                border: 2px solid #333; 
                                padding: 15px; 
                                text-align: center;
                                page-break-inside: avoid;
                            }
                            .qr-code { width: 150px; height: 150px; margin: 0 auto 10px; }
                            .qr-label { font-size: 18px; font-weight: bold; }
                            .qr-type { font-size: 12px; color: #666; }
                            @media print {
                                .no-print { display: none; }
                                .qr-grid { gap: 10px; }
                            }
                        </style>
                        <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js"><\/script>
                    </head>
                    <body>
                        <div class="no-print" style="margin-bottom: 20px;">
                            <button onclick="window.print()" style="padding: 10px 20px; font-size: 16px; cursor: pointer;"> Print QR Codes</button>
                            <button onclick="window.close()" style="padding: 10px 20px; font-size: 16px; cursor: pointer; margin-left: 10px;">Close</button>
                        </div>
                        <div class="qr-grid" id="qr-container"></div>
                        <script>
                            const locations = ${JSON.stringify(selectedCodes)};
                            const container = document.getElementById('qr-container');
                            
                            locations.forEach((code, index) => {
                                const item = document.createElement('div');
                                item.className = 'qr-item';
                                
                                const canvas = document.createElement('canvas');
                                canvas.className = 'qr-code';
                                canvas.id = 'qr-' + index;
                                
                                const label = document.createElement('div');
                                label.className = 'qr-label';
                                label.textContent = code;
                                
                                const type = document.createElement('div');
                                type.className = 'qr-type';
                                type.textContent = code.startsWith('RACK-') ? 'Pallet Rack' : 'Floor Space';
                                
                                item.appendChild(canvas);
                                item.appendChild(label);
                                item.appendChild(type);
                                container.appendChild(item);
                                
                                // Generate QR code
                                QRCode.toCanvas(canvas, code, { 
                                    width: 150,
                                    margin: 1,
                                    errorCorrectionLevel: 'H'
                                });
                            });
                        <\/script>
                    </body>
                    </html>
                `);
                printWindow.document.close();
            }

            // Add a new rack location via modal
            async addRackLocation() {
                this.showModal({
                    title: ' Add Rack Location',
                    message: 'Enter rack location details:',
                    type: 'form',
                    fields: [
                        { name: 'rackNumber', label: 'Rack Number (01-99)', placeholder: '01', required: true },
                        { name: 'face', label: 'Face', type: 'select', options: [{ value: 'F', label: 'Front' }, { value: 'B', label: 'Back' }], required: true },
                        { name: 'row', label: 'Row (A-Z)', placeholder: 'A', required: true },
                        { name: 'column', label: 'Column (1-99)', type: 'number', placeholder: '1', required: true },
                        { name: 'warehouse', label: 'Warehouse', type: 'select', options: [{ value: 'PSA', label: 'PSA' }, { value: 'PML', label: 'PML' }] },
                        { name: 'description', label: 'Description (optional)', placeholder: 'e.g., Aisle 1 near dock' }
                    ],
                    confirmText: 'Add Location',
                    onConfirm: async (data) => {
                        const rackNumber = String(data.rackNumber).padStart(2, '0');
                        const face = data.face || 'F';
                        const row = (data.row || 'A').toUpperCase();
                        const column = parseInt(data.column) || 1;
                        const locationCode = buildLocationCode('rack', { rackNumber, face, row, column });

                        const result = await addLocationToSupabase({
                            location_code: locationCode,
                            location_type: 'rack',
                            rack_number: rackNumber,
                            rack_face: face,
                            rack_row: row,
                            rack_column: column,
                            warehouse: data.warehouse || null,
                            description: data.description || null
                        });

                        if (result.success) {
                            this.triggerHaptic('success');
                            this.render();
                        } else {
                            alert(result.error || 'Failed to add location');
                        }
                    }
                });
            }

            // Add a new floor location via modal
            async addFloorLocationDB() {
                this.showModal({
                    title: ' Add Floor Location',
                    message: 'Enter floor location details:',
                    type: 'form',
                    fields: [
                        { name: 'zone', label: 'Zone Code (e.g., A1)', placeholder: 'A1', required: true },
                        { name: 'warehouse', label: 'Warehouse', type: 'select', options: [{ value: 'PSA', label: 'PSA' }, { value: 'PML', label: 'PML' }] },
                        { name: 'description', label: 'Description (optional)', placeholder: 'e.g., Staging area' }
                    ],
                    confirmText: 'Add Location',
                    onConfirm: async (data) => {
                        const zone = (data.zone || '').toUpperCase();
                        if (!zone) {
                            alert('Zone code is required');
                            return;
                        }
                        const locationCode = buildLocationCode('floor', { zone });

                        const result = await addLocationToSupabase({
                            location_code: locationCode,
                            location_type: 'floor',
                            floor_zone: zone,
                            warehouse: data.warehouse || null,
                            description: data.description || null
                        });

                        if (result.success) {
                            this.triggerHaptic('success');
                            this.render();
                        } else {
                            alert(result.error || 'Failed to add location');
                        }
                    }
                });
            }

            // Delete a location from the database
            async deleteLocationDB(id) {
                const confirmed = await new Promise(resolve => {
                    this.showModal({
                        title: 'Delete Location',
                        message: 'Are you sure you want to delete this location?',
                        type: 'confirm',
                        confirmText: 'Delete',
                        cancelText: 'Cancel',
                        onConfirm: () => resolve(true),
                        onCancel: () => resolve(false)
                    });
                });

                if (!confirmed) return;

                const result = await deleteLocationFromSupabase(id);
                if (result.success) {
                    this.triggerHaptic('heavy');
                    this.render();
                } else {
                    alert(result.error || 'Failed to delete location');
                }
            }

            // ===== END WAREHOUSE LOCATION SYSTEM =====

            promptForLocation() {
                // If warehouse config exists with racks or floor locations, use the picker
                const config = this.sessionSettings.warehouseConfig;
                if (config && (config.racks.length > 0 || config.floorLocations.length > 0)) {
                    this.showLocationPicker();
                } else {
                    // Fall back to manual text entry
                    this.showModal({
                        title: 'Set Location',
                        message: 'Enter current location (e.g., Rack A1, Floor 1):',
                        type: 'input',
                        confirmText: 'Set Location',
                        onConfirm: (data) => {
                            this.setLocation(data.value.trim());
                        }
                    });
                    // Pre-fill value
                    setTimeout(() => {
                        const input = document.getElementById('modal-input');
                        if (input) input.value = this.sessionSettings.currentLocation || '';
                    }, 50);
                }
            }

            triggerHaptic(type = 'light') {
                if (!navigator.vibrate) return;
                const patterns = {
                    success: [40, 20, 40],
                    warning: [100, 50, 100],
                    heavy: [200],
                    light: [20]
                };
                navigator.vibrate(patterns[type] || patterns.light);
            }

            async prefetchReferenceData() {
                if (!supabase) return;
                await Promise.all([
                    loadProductsFromSupabase(),
                    loadRawMaterialsFromSupabase(),
                    loadProductTypesFromSupabase()
                ]);
                this.hasPrefetchedReferenceData = true;
            }

            async refreshSessionsFromSupabase(force = false) {
                if (!supabaseSessionsEnabled || !this.isBrowserOnline) return;
                const now = Date.now();
                // Throttle to once per 10 seconds unless forced
                if (!force && this.lastSessionSync && (now - this.lastSessionSync) < 10000) {
                    return;
                }
                await syncSessionsFromSupabase(this.currentTakeDate);
                this.lastSessionSync = Date.now();
            }

            async init() {
                // Initialize database and load data in parallel for speed
                const initPromises = [
                    db.init(),
                    this.refreshSessionsFromSupabase(true)
                ];

                // Load products in parallel if Supabase is available
                if (supabase) {
                    initPromises.push(
                        loadProductsFromSupabase(),
                        loadRawMaterialsFromSupabase(),
                        loadProductTypesFromSupabase()
                    );
                }

                await Promise.all(initPromises);

                // Sync user and device to Supabase after connection is established
                const userName = getUserName();
                if (userName && db.mode === 'supabase') {
                    const role = getUserRole();
                    const warehouse = getUserWarehouse();
                    syncUserToSupabase(userName, role, warehouse);
                    syncDeviceToSupabase();
                }

                // Check if there's an active stock take for today
                if (this.activeStockTake && this.activeStockTake.date === this.currentTakeDate) {
                    // Continue with existing stock take
                    this.startAutoSync();
                    await this.loadScans();
                    if (supabaseSessionsEnabled) {
                        this.startHeartbeat('active');
                    }
                } else {
                    // Show start stock take screen
                    this.showingStartStockTake = true;
                }

                this.render();
            }

            isOfflineMode() {
                if (!this.isBrowserOnline) {
                    return true;
                }
                return !(supabaseSessionsEnabled && this.activeStockTake?.id);
            }

            async handleConnectivityChange(isOnline) {
                this.isBrowserOnline = isOnline;
                if (!isOnline) {
                    if (supabaseSessionsEnabled && this.activeStockTake?.id) {
                        this.stopHeartbeat('offline');
                    }
                    this.render();
                    return;
                }

                // Back online - sync any offline scans first
                const pendingCount = offlineSyncQueue.getPendingCount();
                if (pendingCount > 0) {
                    console.log(`Back online! Syncing ${pendingCount} offline scans...`);
                    this.showModal({
                        title: ' Syncing Offline Data',
                        message: `You're back online. Syncing ${pendingCount} offline scan${pendingCount > 1 ? 's' : ''}...`,
                        type: 'info'
                    });

                    const result = await syncOfflineScans();

                    // Close info modal and show result
                    this.closeModal();

                    if (result.synced > 0 || result.failed > 0 || result.skippedDuplicates > 0) {
                        let message = `Synced ${result.synced} scan${result.synced !== 1 ? 's' : ''}.`;
                        if (result.skippedDuplicates > 0) {
                            message += ` ${result.skippedDuplicates} duplicate${result.skippedDuplicates !== 1 ? 's' : ''} skipped.`;
                        }
                        if (result.failed > 0) {
                            message += ` ${result.failed} failed (will retry).`;
                        }

                        this.showModal({
                            title: result.failed > 0 ? ' Sync Partial' : ' Sync Complete',
                            message: message,
                            type: result.failed > 0 ? 'warning' : 'success'
                        });

                        // Auto-close success modal after 2 seconds
                        if (result.failed === 0) {
                            setTimeout(() => this.closeModal(), 2000);
                        }
                    }
                }

                if (supabaseSessionsEnabled && this.activeStockTake?.id) {
                    const hbStatus = this.activeStockTake.status === 'paused' ? 'paused' : 'active';
                    this.startHeartbeat(hbStatus);
                }

                await this.refreshSessionsFromSupabase(true);
                await this.loadScans();
                this.render();
            }

            async manualSyncOffline() {
                const pendingCount = offlineSyncQueue.getPendingCount();
                if (pendingCount === 0) {
                    this.showModal({
                        title: ' All Synced',
                        message: 'No offline scans to sync.',
                        type: 'success'
                    });
                    setTimeout(() => this.closeModal(), 2000);
                    return;
                }

                if (!navigator.onLine) {
                    this.showModal({
                        title: ' Still Offline',
                        message: `You have ${pendingCount} scan${pendingCount !== 1 ? 's' : ''} waiting.\n\nThey will sync automatically when you're back online.`,
                        type: 'warning'
                    });
                    return;
                }

                this.showModal({
                    title: ' Syncing...',
                    message: `Syncing ${pendingCount} offline scan${pendingCount !== 1 ? 's' : ''}...`,
                    type: 'info'
                });

                const result = await syncOfflineScans();
                this.closeModal();

                if (result.synced > 0 || result.failed > 0 || result.skippedDuplicates > 0) {
                    let message = `Synced ${result.synced} scan${result.synced !== 1 ? 's' : ''}.`;
                    if (result.skippedDuplicates > 0) {
                        message += ` ${result.skippedDuplicates} duplicate${result.skippedDuplicates !== 1 ? 's' : ''} skipped.`;
                    }
                    if (result.failed > 0) {
                        message += ` ${result.failed} failed (will retry).`;
                    }

                    this.showModal({
                        title: result.failed > 0 ? ' Sync Partial' : ' Sync Complete',
                        message: message,
                        type: result.failed > 0 ? 'warning' : 'success'
                    });

                    // Reload scans to show the synced items
                    await this.loadScans();

                    // Auto-close success modal after 2 seconds
                    if (result.failed === 0) {
                        setTimeout(() => this.closeModal(), 2000);
                    }
                }

                this.render();
            }

            async handleNameChange() {
                const name = getUserName();
                const role = getUserRole();
                const warehouse = getUserWarehouse();

                // Sync user and device to Supabase in background
                if (name) {
                    syncUserToSupabase(name, role, warehouse);
                    syncDeviceToSupabase();
                }

                // Admins don't need warehouse selection
                if (role === 'admin') {
                    localStorage.removeItem('userWarehouse');
                    this.render();
                    return;
                }

                // Prompt all non-admin users for warehouse location if not set
                if (!getUserWarehouse()) {
                    const roleLabel = role === 'supervisor' ? 'supervisor' : 'operator';
                    this.showModal({
                        title: ' Select Your Warehouse',
                        message: `As ${role === 'supervisor' ? 'a supervisor' : 'an operator'}, please confirm your warehouse location:`,
                        type: 'confirm',
                        confirmText: 'PSA',
                        cancelText: 'PML',
                        onConfirm: () => {
                            setUserWarehouse('PSA');
                            // Re-sync user with warehouse
                            syncUserToSupabase(name, role, 'PSA');
                            this.render();
                        },
                        onCancel: () => {
                            setUserWarehouse('PML');
                            // Re-sync user with warehouse
                            syncUserToSupabase(name, role, 'PML');
                            this.render();
                        }
                    });
                } else {
                    this.render();
                }
            }

            async selectStockTakeType(type, userName) {
                if (!userName || userName.trim() === '') {
                    alert('Please enter your name');
                    return;
                }
                setUserName(userName.trim());

                // Check if user needs to select warehouse (non-admins)
                const role = getUserRole();
                if (role !== 'admin' && !getUserWarehouse()) {
                    this.showModal({
                        title: 'Select Your Warehouse',
                        message: `Please confirm your warehouse location:`,
                        type: 'confirm',
                        confirmText: 'PSA',
                        cancelText: 'PML',
                        onConfirm: async () => {
                            setUserWarehouse('PSA');
                            // Refresh sessions from Supabase before showing list
                            await this.refreshSessionsFromSupabase(true);
                            this.selectedStockTakeType = type;
                            this.render();
                        },
                        onCancel: async () => {
                            setUserWarehouse('PML');
                            // Refresh sessions from Supabase before showing list
                            await this.refreshSessionsFromSupabase(true);
                            this.selectedStockTakeType = type;
                            this.render();
                        }
                    });
                    return;
                }

                // Refresh sessions from Supabase before showing list
                await this.refreshSessionsFromSupabase(true);
                this.selectedStockTakeType = type;
                this.render();
            }

            async startNewStockTake(userName, sessionType = 'FP') {
                if (!userName || userName.trim() === '') {
                    alert('Please enter your name');
                    return;
                }

                setUserName(userName.trim());
                await this.refreshSessionsFromSupabase(true);
                if (!this.hasPrefetchedReferenceData) {
                    await this.prefetchReferenceData();
                }

                // Get next session number for today (per type)
                const sessionNumber = getNextSessionNumber(this.currentTakeDate, sessionType);
                const sessionId = `${this.currentTakeDate}-${sessionType}-${sessionNumber}`;

                const deviceInfo = {
                    deviceId: DEVICE_ID,
                    userName: userName.trim(),
                    status: 'active',
                    joinedAt: new Date().toISOString(),
                    lastSeen: new Date().toISOString()
                };

                // Get warehouse for session
                const warehouse = getUserWarehouse() || '';

                this.activeStockTake = {
                    id: sessionId,
                    sessionNumber: sessionNumber,
                    sessionType: sessionType, // 'FP' or 'RM'
                    date: this.currentTakeDate,
                    startedBy: userName.trim(),
                    startedAt: new Date().toISOString(),
                    devices: [deviceInfo],
                    status: 'active',
                    warehouse: warehouse
                };

                // Save session to sessions list (with devices)
                await addSession(this.currentTakeDate, {
                    id: sessionId,
                    sessionNumber: sessionNumber,
                    sessionType: sessionType,
                    date: this.currentTakeDate,
                    startedBy: userName.trim(),
                    startedAt: new Date().toISOString(),
                    devices: [deviceInfo],
                    status: 'active',
                    warehouse: warehouse
                });

                setActiveStockTake(this.activeStockTake);
                this.scans = [];
                clearLocalScanStorage();

                this.showingStartStockTake = false;
                this.selectedStockTakeType = null;

                this.startAutoSync();
                if (supabaseSessionsEnabled) {
                    this.startHeartbeat('active');
                }

                this.loadScans();
                this.triggerHaptic('success');
                this.render();
            }

            async joinExistingSession(sessionId, userName) {
                if (!userName || userName.trim() === '') {
                    alert('Please enter your name');
                    return;
                }

                setUserName(userName.trim());
                await this.refreshSessionsFromSupabase();
                if (!this.hasPrefetchedReferenceData) {
                    await this.prefetchReferenceData();
                }

                // Join the session
                const updatedSession = await joinSession(this.currentTakeDate, sessionId, DEVICE_ID, userName.trim());

                if (!updatedSession) {
                    alert('Session not found');
                    return;
                }

                this.activeStockTake = {
                    id: updatedSession.id,
                    sessionNumber: updatedSession.sessionNumber,
                    sessionType: updatedSession.sessionType,
                    date: this.currentTakeDate,
                    startedBy: updatedSession.startedBy,
                    startedAt: updatedSession.startedAt,
                    devices: updatedSession.devices,
                    status: updatedSession.status,
                    warehouse: updatedSession.warehouse || updatedSession.metadata?.warehouse || '',
                    metadata: updatedSession.metadata || {}
                };

                setActiveStockTake(this.activeStockTake);

                // Don't clear scans - we're joining an existing session
                this.showingStartStockTake = false;
                this.selectedStockTakeType = null;

                this.startAutoSync();
                if (supabaseSessionsEnabled) {
                    this.startHeartbeat('active');
                }

                this.loadScans();
                this.triggerHaptic('success');
                this.render();
            }

            async endStockTake() {
                const sessionId = this.activeStockTake?.id;
                const sessionDate = this.activeStockTake?.date || this.currentTakeDate;

                if (!sessionId) {
                    alert('No active stock take to complete.');
                    return;
                }

                const finalizeDeviceWrapUp = async () => {
                    const updatedSession = await markDeviceCompleted(sessionDate, sessionId, DEVICE_ID);
                    if (supabaseSessionsEnabled) {
                        this.stopHeartbeat('inactive');
                    }
                    if (updatedSession) {
                        const remaining = updatedSession.devices?.filter(d => d.status === 'active').length || 0;
                        if (remaining > 0) {
                            alert(`You are marked as completed.\n\n${remaining} device(s) are still counting. When everyone finishes, end the stock take from Session History.`);
                        } else {
                            alert('All devices are now marked complete. End the entire stock take from Session History when you are ready to finalize.');
                        }
                    } else {
                        alert('You are marked as completed. End the stock take from Session History when ready.');
                    }
                    this.stopAutoSync();
                    clearActiveStockTake();
                    this.activeStockTake = null;
                    this.scans = [];
                    this.selectedStockTakeType = null;
                    this.showingStartStockTake = true;
                    this.render();
                };

                if (this.scans.length === 0) {
                    const confirmDone = confirm('No items were scanned on this device. Mark yourself as completed? This will NOT end the overall stock take.');
                    if (!confirmDone) return;
                    await finalizeDeviceWrapUp();
                    return;
                }

                await this.loadScans();

                const currentSession = getSessionById(sessionDate, sessionId);
                const deviceScanCount = this.scans.filter(s => s.deviceId === DEVICE_ID).length;
                const otherActiveDevices = currentSession?.devices?.filter(d => d.status === 'active' && d.deviceId !== DEVICE_ID) || [];
                const completedDevices = currentSession?.devices?.filter(d => d.status === 'completed') || [];

                let summary = `Mark Your Count Complete\n\n` +
                    `Your scans: ${deviceScanCount}\n` +
                    `Total session scans: ${this.scans.length}\n\n`;

                if (otherActiveDevices.length > 0) {
                    summary += ` ${otherActiveDevices.length} other device(s) are still active:\n`;
                    otherActiveDevices.forEach(d => {
                        summary += `   ${d.userName}\n`;
                    });
                    summary += `\nThis only marks your device as completed.\nThe stock take stays open until it is ended from Session History.\n\n`;
                } else if (completedDevices.length > 0) {
                    summary += ` ${completedDevices.length} device(s) already marked done.\n`;
                    summary += `Use Session History to end the stock take for everyone.\n\n`;
                } else {
                    summary += `This will mark only your device as completed.\nEnd the full stock take from Session History when ready.\n\n`;
                }

                summary += `Proceed with marking yourself done?`;
                const proceed = confirm(summary);
                if (!proceed) return;

                const exportData = confirm('Export your scans before marking done? Click OK to export, or Cancel to skip.');
                if (exportData) {
                    this.exportStockCount();
                }

                await finalizeDeviceWrapUp();
            }

            async endSessionFromList(sessionId) {
                // End a session from the session selection list
                this.showModal({
                    title: 'End Session',
                    message: 'Are you sure you want to end this session? All active devices will be marked as completed.',
                    type: 'confirm',
                    confirmText: 'End Session',
                    cancelText: 'Cancel',
                    onConfirm: () => {
                        // Execute the async operation after modal closes
                        this._executeEndSession(sessionId);
                    }
                });
            }

            async _executeEndSession(sessionId) {
                try {
                    console.log('Attempting to end session:', sessionId);

                    if (supabaseSessionsEnabled && supabase) {
                        // First check if the session exists in stock_takes
                        const { data: existingSession, error: fetchError } = await supabase
                            .from('stock_takes')
                            .select('id, status')
                            .eq('id', sessionId)
                            .single();

                        if (fetchError) {
                            console.error('Error fetching session:', fetchError);
                            // Session might not exist in Supabase, just update locally
                            console.log('Session not found in Supabase, updating locally only');
                        } else if (existingSession) {
                            // Update session status in Supabase (use completed_at, not ended_at)
                            const { error: updateError } = await supabase
                                .from('stock_takes')
                                .update({
                                    status: 'completed',
                                    completed_at: new Date().toISOString()
                                })
                                .eq('id', sessionId);

                            if (updateError) {
                                console.error('Error updating session in Supabase:', updateError);
                                // Don't show alert for cloud errors, just log and continue locally
                                console.log('Continuing with local update only');
                            } else {
                                console.log('Session ended in Supabase successfully');
                            }
                        }
                    }

                    // Update local storage
                    const sessionDate = this.currentTakeDate;
                    await updateSession(sessionDate, sessionId, { status: 'completed' });
                    console.log('Session ended in local storage');

                    // Refresh the session list
                    await this.refreshSessionsFromSupabase();
                    this.render();

                    alert('Session ended successfully.');
                } catch (err) {
                    console.error('Error ending session:', err);
                    alert('Failed to end session: ' + (err.message || 'Unknown error'));
                }
            }

            async loadScans() {
                const sessionType = this.activeStockTake?.sessionType || 'FP';
                const sessionId = this.activeStockTake?.id;

                if (supabase && sessionId) {
                    // Load ALL scans from stock_scans table, filtered by session
                    try {
                        // Only select fields we actually need for display
                        const { data, error } = await supabase
                            .from('stock_scans')
                            .select('id,scanned_at,raw_code,batch_number,pallet_number,cases_on_pallet,actual_cases,stock_code,description,device_id,scanned_by,session_type,expiry_date,location,site,aisle,rack,unit_type')
                            .eq('session_id', sessionId)
                            .order('scanned_at', { ascending: false });

                        if (error) {
                            console.error('Error loading scans from Supabase:', error);
                            await logClientEvent('scan-load-failed', 'error', sessionId, { message: error.message });
                            this.scans = [];
                            return;
                        }

                        this.scans = (data || []).map(row => ({
                            id: row.id,
                            timestamp: new Date(row.scanned_at).getTime(),
                            date: new Date(row.scanned_at).toLocaleDateString(),
                            time: new Date(row.scanned_at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
                            raw: row.raw_code,
                            batchNumber: row.batch_number,
                            palletNumber: row.pallet_number || '',
                            casesOnPallet: row.cases_on_pallet || 0,
                            actualCases: row.actual_cases,
                            stockCode: row.stock_code,
                            description: row.description,
                            valid: true,
                            deviceId: row.device_id,
                            scannedBy: row.scanned_by || 'Unknown',
                            sessionType: row.session_type || sessionType,
                            expiryDate: row.expiry_date,
                            location: row.location,
                            site: row.site,
                            aisle: row.aisle,
                            rack: row.rack,
                            unitType: row.unit_type || (sessionType === 'RM' ? getUnitTypeForStockCode(row.stock_code) : 'cases')
                        }));

                        console.log(`Loaded ${this.scans.length} scans from stock_scans for session ${sessionId}`);
                    } catch (err) {
                        console.error('Failed to load scans from Supabase:', err);
                        await logClientEvent('scan-load-failed', 'error', sessionId, { message: err.message });
                        this.scans = [];
                    }
                } else {
                    // Fallback to localStorage
                    const allScans = localStorage_db.list('scan:');
                    // Filter by session type
                    this.scans = allScans.filter(s => !s.sessionType || s.sessionType === sessionType);
                    this.scans.sort((a, b) => b.timestamp - a.timestamp);
                }
            }

            startAutoSync() {
                this.stopAutoSync();
                const canSync = supabaseSessionsEnabled && this.activeStockTake?.id;
                if (!canSync) {
                    return;
                }
                const runSync = async () => {
                    if (!this.isBrowserOnline) return;

                    try {
                        // Always sync data from database - this keeps data in sync
                        if (supabaseSessionsEnabled && this.activeStockTake?.id) {
                            await this.refreshSessionsFromSupabase();
                            await this.loadScans();
                        }

                        // Only render if not in an input state - prevents clearing user input
                        // Data is still synced, just UI update is deferred
                        if (!this.showingCaseEntry && !this.modalState) {
                            this.render();
                        } else {
                            // Mark that we need to render when input is done
                            this._pendingRender = true;
                        }
                    } catch (err) {
                        console.warn('Auto-sync failed', err);
                    }
                };
                runSync();
                // Sync every 10 seconds
                this.syncInterval = setInterval(runSync, 10000);
            }

            stopAutoSync() {
                if (this.syncInterval) {
                    clearInterval(this.syncInterval);
                    this.syncInterval = null;
                }
            }

            startHeartbeat(status = 'active') {
                if (!supabaseSessionsEnabled || !this.activeStockTake?.id || !this.isBrowserOnline) return;
                this.stopHeartbeat();
                const send = async () => {
                    if (!this.isBrowserOnline) return;
                    await upsertSessionDevicePresence(this.activeStockTake.id, status, this.activeStockTake);
                    this.lastHeartbeatAt = Date.now();
                };
                send();
                this.heartbeatInterval = setInterval(send, HEARTBEAT_INTERVAL_MS);
            }

            stopHeartbeat(status = 'inactive') {
                if (this.heartbeatInterval) {
                    clearInterval(this.heartbeatInterval);
                    this.heartbeatInterval = null;
                }
                if (supabaseSessionsEnabled && this.activeStockTake?.id && status && this.isBrowserOnline) {
                    upsertSessionDevicePresence(this.activeStockTake.id, status, this.activeStockTake);
                }
            }

            async getPreferredCameraId() {
                if (this.preferredCameraId) return this.preferredCameraId;
                try {
                    const cameras = await Html5Qrcode.getCameras();
                    if (!cameras || cameras.length === 0) {
                        return null;
                    }
                    const backCamera = cameras.find(cam => /back|rear|environment/i.test(cam.label));
                    this.preferredCameraId = (backCamera || cameras[0]).id;
                    return this.preferredCameraId;
                } catch (err) {
                    console.warn('Camera enumeration failed', err);
                    return null;
                }
            }

            parseQRCode(code) {
                const sessionType = this.activeStockTake?.sessionType || 'FP';

                // FP (Finished Products) - 13 digit numeric code
                // Format: BBBBBPPPPCCCC (5 batch + 4 pallet + 4 cases)
                if (sessionType === 'FP') {
                    if (!/^\d{13}$/.test(code)) {
                        return {
                            valid: false,
                            raw: code,
                            error: 'Not a valid 13-digit FP code'
                        };
                    }

                    const batchNumber = code.substring(0, 5);    // First 5 digits = batch
                    const palletNumber = code.substring(5, 9);   // Next 4 digits = pallet
                    const cases = code.substring(9, 13);         // Last 4 digits = cases

                    const productInfo = productDatabase[batchNumber];
                    const isUnknownProduct = !productInfo;

                    return {
                        valid: true,
                        raw: code,
                        batchNumber: batchNumber,
                        palletNumber: palletNumber,
                        casesOnPallet: parseInt(cases),
                        stockCode: productInfo?.stockCode || 'UNKNOWN',
                        description: productInfo?.description || 'Unknown Product',
                        isUnknownProduct: isUnknownProduct
                    };
                }

                // RM (Raw Materials) - starts with a letter
                // Barcode format: STOCKCODE + BATCH + optional EXPIRY (DD/MM/YY)
                // If stock code not in database, user will be prompted to scan stock code first
                if (sessionType === 'RM') {
                    // Check if it starts with a letter (RM code)
                    if (!/^[A-Za-z]/.test(code)) {
                        return {
                            valid: false,
                            raw: code,
                            error: 'RM code must start with a letter'
                        };
                    }

                    // Try to extract expiry date from end of string (format: DD/MM/YY)
                    const expiryMatch = code.match(/(\d{2}\/\d{2}\/\d{2})$/);
                    let extractedExpiry = null;
                    let codeWithoutExpiry = code;

                    if (expiryMatch) {
                        extractedExpiry = expiryMatch[1];
                        codeWithoutExpiry = code.substring(0, code.length - 8).trim(); // Remove expiry and any trailing space
                    }

                    // Try to find the stock code in database
                    let foundStockCode = null;
                    let batchNumber = null;
                    let batchFromDatabase = false;
                    let needsStockCodeScan = false;
                    let needsBatchConfirmation = false;
                    let needsExpiryConfirmation = false;

                    // First, try to match known stock codes
                    const knownStockCodes = Object.keys(rawMaterialsDatabase).sort((a, b) => b.length - a.length);

                    for (const sc of knownStockCodes) {
                        if (code.toUpperCase().startsWith(sc.toUpperCase())) {
                            foundStockCode = sc;
                            // Extract batch number from remaining string
                            const remaining = code.substring(sc.length);
                            const extractedBatch = remaining.replace(/^[\-_\s]+/, '').trim() || null;

                            // Check if this batch exists in the database for this stock code
                            const rmInfo = rawMaterialsDatabase[sc];
                            if (rmInfo && rmInfo.batches && extractedBatch) {
                                // Try to find a matching batch in the database
                                const knownBatches = Object.keys(rmInfo.batches);
                                // Look for exact match first
                                const exactMatch = knownBatches.find(b => extractedBatch.toUpperCase().includes(b.toUpperCase()) || b.toUpperCase().includes(extractedBatch.toUpperCase()));
                                if (exactMatch) {
                                    batchNumber = exactMatch;
                                    batchFromDatabase = true;
                                } else {
                                    // No match found in database - use extracted batch
                                    batchNumber = extractedBatch;
                                }
                            } else {
                                batchNumber = extractedBatch;
                            }
                            break;
                        }
                    }

                    // If not found in database, mark as needing stock code scan
                    if (!foundStockCode) {
                        // Stock code not in database - user needs to scan stock code first
                        needsStockCodeScan = true;

                        // Try to parse what we can from the code
                        const parts = codeWithoutExpiry.split(/[\-_\s]+/);
                        if (parts.length >= 1) {
                            foundStockCode = parts[0];
                            // Everything after the first part could be batch
                            const potentialBatch = parts.slice(1).join('-') || null;
                            if (potentialBatch) {
                                batchNumber = potentialBatch;
                                needsBatchConfirmation = true;
                            }
                        }
                    }

                    // If we extracted expiry from end of string, use it but need confirmation
                    if (extractedExpiry) {
                        needsExpiryConfirmation = true;
                    }

                    // Also need batch confirmation if batch was extracted but not from database
                    if (batchNumber && !batchFromDatabase) {
                        needsBatchConfirmation = true;
                    }

                    if (!foundStockCode) {
                        return {
                            valid: false,
                            raw: code,
                            error: 'Could not parse stock code from: ' + code
                        };
                    }

                    // Look up product info
                    const rmInfo = rawMaterialsDatabase[foundStockCode] || rawMaterialsDatabase[foundStockCode.toUpperCase()];
                    const description = rmInfo?.description || 'Unknown Raw Material';

                    // Determine unit type based on stock code prefix
                    const unitType = getUnitTypeForStockCode(foundStockCode);

                    // Check for expiry dates if batch number is known from database
                    let expiryDate = extractedExpiry || null;
                    let availableExpiryDates = [];

                    if (rmInfo && batchNumber && rmInfo.batches && rmInfo.batches[batchNumber]) {
                        const batchInfo = rmInfo.batches[batchNumber];
                        // Support both old format (expiryDate) and new format (expiryDates array)
                        if (batchInfo.expiryDates && Array.isArray(batchInfo.expiryDates)) {
                            availableExpiryDates = batchInfo.expiryDates.filter(d => d != null);
                            if (availableExpiryDates.length === 1) {
                                expiryDate = availableExpiryDates[0];
                                needsExpiryConfirmation = false; // Found in database
                            } else if (availableExpiryDates.length > 1) {
                                // Multiple expiry dates - need confirmation
                                needsExpiryConfirmation = true;
                            }
                        } else if (batchInfo.expiryDate) {
                            // Old format - single expiry date
                            expiryDate = batchInfo.expiryDate;
                            availableExpiryDates = [expiryDate];
                            needsExpiryConfirmation = false; // Found in database
                        }
                    }

                    return {
                        valid: true,
                        raw: code,
                        stockCode: foundStockCode,
                        batchNumber: batchNumber || null,
                        palletNumber: null, // RM doesn't use pallets
                        casesOnPallet: 0, // Will be entered as quantity
                        description: description,
                        expiryDate: expiryDate,
                        extractedExpiry: extractedExpiry, // Keep original extracted value
                        availableExpiryDates: availableExpiryDates,
                        needsExpiryConfirmation: needsExpiryConfirmation,
                        needsBatchConfirmation: needsBatchConfirmation,
                        needsStockCodeScan: needsStockCodeScan,
                        isRawMaterial: true,
                        unitType: unitType // 'kg' or 'units'
                    };
                }

                return {
                    valid: false,
                    raw: code,
                    error: 'Unknown session type'
                };
            }

            async checkDuplicate(batchNumber, palletNumber, stockCode = null, expiryDate = null) {
                console.log('checkDuplicate called with:', { batchNumber, palletNumber, stockCode, expiryDate, typeof_pallet: typeof palletNumber });
                if (supabase && this.activeStockTake?.id) {
                    // Live check against Supabase stock_scans for all devices in this session
                    const sessionType = this.activeStockTake?.sessionType || 'FP';
                    return await checkDuplicateInSupabase(
                        this.activeStockTake.id,
                        sessionType,
                        batchNumber,
                        stockCode,
                        expiryDate,
                        palletNumber
                    );
                } else {
                    // Fallback to local check
                    if (this.activeStockTake?.sessionType === 'RM') {
                        return this.scans.find(s =>
                            s.batchNumber === batchNumber &&
                            s.stockCode === stockCode &&
                            (!expiryDate || s.expiryDate === expiryDate)
                        );
                    } else {
                        return this.scans.find(s =>
                            s.batchNumber === batchNumber &&
                            s.palletNumber === palletNumber
                        );
                    }
                }
            }

            async startScanning() {
                this.isScanning = true;
                this.render();

                setTimeout(async () => {
                    try {
                        this.scanner = new Html5Qrcode("scanner", {
                            verbose: false,
                            experimentalFeatures: {
                                useBarCodeDetectorIfSupported: true
                            }
                        });

                        const config = {
                            fps: 10,
                            qrbox: function (viewfinderWidth, viewfinderHeight) {
                                const minEdge = Math.min(viewfinderWidth, viewfinderHeight);
                                const size = Math.floor(minEdge * 0.7);
                                return { width: size, height: size };
                            },
                            aspectRatio: 1.0,
                            showTorchButtonIfSupported: true,
                            showZoomSliderIfSupported: true,
                            defaultZoomValueIfSupported: 2
                        };

                        await this.scanner.start(
                            { facingMode: "environment" },
                            config,
                            (decodedText, decodedResult) => {
                                console.log('SCAN SUCCESS:', decodedText, decodedResult);
                                this.onScanSuccess(decodedText);
                            },
                            (errorMessage) => {
                                // Silent - no QR in frame
                            }
                        );

                        // Fix for mobile browsers: force video element attributes
                        setTimeout(() => {
                            const videoElement = document.querySelector('#scanner video');
                            if (videoElement) {
                                videoElement.setAttribute('playsinline', '');
                                videoElement.setAttribute('webkit-playsinline', '');
                                videoElement.setAttribute('autoplay', '');
                                videoElement.muted = true;
                                videoElement.playsInline = true;
                            }
                        }, 500);

                    } catch (err) {
                        console.error('Camera error:', err);
                        let errorMsg = 'Camera error: ';
                        if (err.name === 'NotAllowedError') {
                            errorMsg += 'Camera permission denied. Please allow camera access in your browser settings.';
                        } else if (err.name === 'NotFoundError') {
                            errorMsg += 'No camera found on this device.';
                        } else if (err.name === 'NotReadableError') {
                            errorMsg += 'Camera is in use by another app.';
                        } else {
                            errorMsg += err.message || err;
                        }
                        alert(errorMsg);
                        this.isScanning = false;
                        this.render();
                    }
                }, 300);
            }

            async stopScanning() {
                if (this.scanner) {
                    try {
                        await this.scanner.stop();
                    } catch (err) {
                        console.log('Stop error:', err);
                    }
                    try {
                        this.scanner.clear();
                    } catch (err) {
                        console.log('Clear error:', err);
                    }
                    this.scanner = null;
                }
                this.isScanning = false;
                this.render();
            }

            // Generate a unique key for a scan to prevent double-capture
            getScanKey(parsed) {
                const sessionType = this.activeStockTake?.sessionType || 'FP';
                if (sessionType === 'RM') {
                    return `${parsed.stockCode}|${parsed.batchNumber}|${parsed.expiryDate || ''}`;
                } else {
                    return `${parsed.batchNumber}|${parsed.palletNumber}`;
                }
            }

            async onScanSuccess(code) {
                const cleanedCode = (code || '').trim();
                if (!cleanedCode) {
                    return;
                }
                if (navigator.vibrate) navigator.vibrate(200);

                this.stopScanning();

                // ===== LOCATION QR CODE DETECTION =====
                // Check if this is a location QR code (RACK-* or FLOOR-*)
                if (isLocationCode(cleanedCode)) {
                    const locationCode = cleanedCode.toUpperCase();
                    const parsed = parseLocationCode(locationCode);

                    if (parsed) {
                        // Set as active location
                        this.activeLocation = locationCode;

                        // Also update session settings for backward compatibility
                        this.sessionSettings.currentLocation = locationCode;
                        this.sessionSettings.locationScanningEnabled = true;
                        saveSessionSettings(this.sessionSettings);

                        // Simple vibrate feedback - no modal, just confirm with haptic
                        this.triggerHaptic('success');

                        // Log location set for debugging
                        console.log(' Location set:', locationCode);

                        // Immediately restart scanner for continuous scanning
                        this.render();
                        setTimeout(() => this.startScanning(), 300);

                        return;
                    }
                }
                // ===== END LOCATION QR CODE DETECTION =====

                // Check if we're waiting for FP stock code scan
                if (this._waitingForFPStockCode && this._unknownFPParsed) {
                    this._waitingForFPStockCode = false;
                    const stockCode = cleanedCode;
                    const parsed = this._unknownFPParsed;

                    // Don't accept a 13-digit code (that's a pallet barcode, not stock code)
                    if (/^\d{13}$/.test(stockCode)) {
                        this.showModal({
                            title: ' Wrong Barcode',
                            message: 'That looks like a pallet barcode, not a stock code.\n\nPlease scan the STOCK CODE barcode.',
                            type: 'alert',
                            confirmText: 'Try Again',
                            onConfirm: () => {
                                this._waitingForFPStockCode = true;
                                this.startScanning();
                            }
                        });
                        return;
                    }

                    // Look up or prompt for product details
                    await this._processFPStockCodeScan(stockCode, parsed);
                    return;
                }

                // Check if we're waiting for a stock code scan (unknown product flow - RM)
                if (this._waitingForStockCodeScan && this._unknownStockParsed) {
                    this._waitingForStockCodeScan = false;
                    const stockCode = cleanedCode;

                    // Don't accept the same code as the original
                    const originalCode = this._unknownStockParsed.raw || '';
                    if (stockCode === originalCode) {
                        this.showModal({
                            title: ' Same Barcode',
                            message: 'You scanned the same barcode again.\n\nPlease scan the separate STOCK CODE barcode.',
                            type: 'alert',
                            confirmText: 'Try Again',
                            onConfirm: () => {
                                this._waitingForStockCodeScan = true;
                                this.startScanning();
                            }
                        });
                        return;
                    }

                    // Process the stock code
                    this.finishUnknownStockScan(stockCode);
                    return;
                }

                const parsed = this.parseQRCode(cleanedCode);

                if (!parsed.valid) {
                    alert(parsed.error);
                    return;
                }

                // Check if this scan is already being processed (prevents rapid double-scan)
                const scanKey = this.getScanKey(parsed);
                if (this.pendingScanKeys.has(scanKey)) {
                    console.log('Scan already in progress:', scanKey);
                    if (navigator.vibrate) navigator.vibrate([100, 50, 100]);
                    alert('This item is already being processed. Please wait.');
                    return;
                }

                // Check if expiry date confirmation is needed (multiple dates available)
                if (parsed.needsExpiryConfirmation && parsed.availableExpiryDates && parsed.availableExpiryDates.length > 1) {
                    // Show expiry date selection dialog
                    this.pendingScan = parsed;
                    this.showingExpirySelection = true;
                    this.render();
                    return;
                }

                const sessionType = this.activeStockTake?.sessionType || 'FP';

                // For FP: Handle unknown product - show search to select product
                if (sessionType === 'FP' && parsed.isUnknownProduct) {
                    // Store data for after product selection
                    this._unknownFPParsed = parsed;
                    this._unknownFPScanKey = scanKey;

                    // Show product search modal
                    this._showFPProductSearch(parsed, scanKey);
                    return;
                }

                // For RM: Handle stock code not found in database
                if (sessionType === 'RM' && parsed.needsStockCodeScan) {
                    // Store data for after scan
                    this._unknownStockParsed = parsed;
                    this._unknownStockScanKey = scanKey;
                    this._waitingForStockCodeScan = true;

                    // Show message and let user scan stock code with normal scanner
                    this.showModal({
                        title: ' Unknown Product',
                        message: `The scanned barcode is not in the database.\n\nOriginal scan:\n${parsed.raw}\n\nPlease scan the STOCK CODE barcode on this product.`,
                        type: 'alert',
                        confirmText: 'Scan Stock Code',
                        onConfirm: () => {
                            // Start normal scanner - it will be handled specially
                            this.startScanning();
                        }
                    });
                    return;
                }

                // For RM: Handle batch confirmation 
                if (sessionType === 'RM' && parsed.needsBatchConfirmation && parsed.batchNumber) {
                    this.showModal({
                        title: ' Confirm Batch Number',
                        message: `Stock Code: ${parsed.stockCode}\n\nExtracted Batch: ${parsed.batchNumber}\n\nPlease confirm or correct the batch number:`,
                        type: 'input',
                        confirmText: 'Confirm Batch',
                        cancelText: 'Cancel',
                        onConfirm: (formData) => {
                            const confirmedBatch = formData.value?.trim() || parsed.batchNumber;
                            parsed.batchNumber = confirmedBatch;
                            parsed.needsBatchConfirmation = false;
                            // Continue to expiry confirmation
                            this._continueRMScan(parsed, scanKey);
                        }
                    });
                    // Pre-fill the input with extracted batch
                    setTimeout(() => {
                        const input = document.getElementById('modal-input');
                        if (input) input.value = parsed.batchNumber;
                    }, 100);
                    return;
                }

                // For RM: Handle expiry confirmation from barcode
                if (sessionType === 'RM' && parsed.needsExpiryConfirmation && parsed.extractedExpiry) {
                    this.showModal({
                        title: ' Confirm Expiry Date',
                        message: `Stock Code: ${parsed.stockCode}\nBatch: ${parsed.batchNumber}\n\nExtracted Expiry: ${parsed.extractedExpiry}\n(Format: DD/MM/YY)\n\nPlease confirm or correct the expiry date:`,
                        type: 'input',
                        confirmText: 'Confirm Expiry',
                        cancelText: 'No Expiry',
                        onConfirm: (formData) => {
                            const confirmedExpiry = formData.value?.trim() || parsed.extractedExpiry;
                            // Convert DD/MM/YY to YYYY-MM-DD format
                            parsed.expiryDate = confirmedExpiry ? convertDMYtoYMD(confirmedExpiry) : null;
                            parsed.needsExpiryConfirmation = false;
                            // Continue to duplicate check and case entry
                            this._continueRMScan(parsed, scanKey);
                        },
                        onCancel: () => {
                            // User said no expiry
                            parsed.expiryDate = null;
                            parsed.needsExpiryConfirmation = false;
                            this._continueRMScan(parsed, scanKey);
                        }
                    });
                    // Pre-fill the input with extracted expiry
                    setTimeout(() => {
                        const input = document.getElementById('modal-input');
                        if (input) input.value = parsed.extractedExpiry;
                    }, 100);
                    return;
                }

                // For FP 13-digit scans (with pallet number), check for duplicates
                // A pallet with same batch+pallet cannot be scanned twice
                // Note: 5-digit manual entries and RM items allow duplicates
                if (sessionType === 'FP' && parsed.palletNumber) {
                    console.log('FP duplicate check - batch:', parsed.batchNumber, 'pallet:', parsed.palletNumber);
                    const duplicate = await this.checkDuplicate(
                        parsed.batchNumber,
                        parsed.palletNumber,
                        parsed.stockCode,
                        parsed.expiryDate
                    );
                    console.log('FP duplicate check result:', duplicate);

                    if (duplicate) {
                        const timestamp = duplicate.scanned_at || duplicate.created_at || duplicate.date + ' ' + duplicate.time;
                        const scannedByName = duplicate.scanned_by || duplicate.scannedBy || 'Unknown';
                        const existingCases = duplicate.actual_cases || duplicate.actualCases || 0;

                        if (navigator.vibrate) navigator.vibrate([200, 100, 200]);

                        // Store duplicate info for update flow
                        parsed.isDuplicatePallet = true;
                        parsed.existingScanId = duplicate.id;
                        parsed.existingCases = existingCases;

                        // Show modal to notify and confirm update
                        this.showModal({
                            title: 'Pallet Already Scanned',
                            message: `This pallet has already been scanned!\n\n` +
                                `Stock Code: ${parsed.stockCode}\n` +
                                `Batch: ${parsed.batchNumber}\n` +
                                `Pallet: ${parsed.palletNumber}\n` +
                                `Current Cases: ${existingCases}\n\n` +
                                `Scanned by: ${scannedByName}\n` +
                                `at ${new Date(timestamp).toLocaleString()}\n\n` +
                                `Would you like to update this pallet's count?`,
                            type: 'confirm',
                            confirmText: 'Update Count',
                            cancelText: 'Cancel',
                            onConfirm: () => {
                                // Proceed to case entry to update
                                this.pendingScanKeys.add(scanKey);
                                this.currentScan = parsed;
                                this.showingCaseEntry = true;
                                this.render();
                            }
                        });
                        return;
                    }
                }

                // Mark this scan as pending to prevent double-capture
                this.pendingScanKeys.add(scanKey);

                this.currentScan = parsed;
                this.showingCaseEntry = true;
                this.render();
            }

            // Continue RM scan after confirmations
            async _continueRMScan(parsed, scanKey) {
                // Check if more confirmations are needed
                if (parsed.needsStockCodeScan) {
                    // Re-trigger stock code confirmation
                    await this.onScanSuccess(parsed.raw);
                    return;
                }

                if (parsed.needsBatchConfirmation) {
                    // Re-trigger batch confirmation
                    this.showModal({
                        title: ' Confirm Batch Number',
                        message: `Stock Code: ${parsed.stockCode}\n\nExtracted Batch: ${parsed.batchNumber}\n\nPlease confirm or correct the batch number:`,
                        type: 'input',
                        confirmText: 'Confirm Batch',
                        cancelText: 'Cancel',
                        onConfirm: (formData) => {
                            const confirmedBatch = formData.value?.trim() || parsed.batchNumber;
                            parsed.batchNumber = confirmedBatch;
                            parsed.needsBatchConfirmation = false;
                            this._continueRMScan(parsed, scanKey);
                        }
                    });
                    setTimeout(() => {
                        const input = document.getElementById('modal-input');
                        if (input) input.value = parsed.batchNumber || '';
                    }, 100);
                    return;
                }

                if (parsed.needsExpiryConfirmation && parsed.extractedExpiry) {
                    // Re-trigger expiry confirmation  
                    this.showModal({
                        title: ' Confirm Expiry Date',
                        message: `Stock Code: ${parsed.stockCode}\nBatch: ${parsed.batchNumber}\n\nExtracted Expiry: ${parsed.extractedExpiry}\n(Format: DD/MM/YY)\n\nPlease confirm or correct:`,
                        type: 'input',
                        confirmText: 'Confirm Expiry',
                        cancelText: 'No Expiry',
                        onConfirm: (formData) => {
                            const confirmedExpiry = formData.value?.trim() || parsed.extractedExpiry;
                            // Convert DD/MM/YY to YYYY-MM-DD format
                            parsed.expiryDate = confirmedExpiry ? convertDMYtoYMD(confirmedExpiry) : null;
                            parsed.needsExpiryConfirmation = false;
                            this._continueRMScan(parsed, scanKey);
                        },
                        onCancel: () => {
                            parsed.expiryDate = null;
                            parsed.needsExpiryConfirmation = false;
                            this._continueRMScan(parsed, scanKey);
                        }
                    });
                    setTimeout(() => {
                        const input = document.getElementById('modal-input');
                        if (input) input.value = parsed.extractedExpiry || '';
                    }, 100);
                    return;
                }

                // RM items allow duplicates (same item can be in different locations)
                // Proceed directly to case entry
                this.pendingScanKeys.add(scanKey);
                this.currentScan = parsed;
                this.showingCaseEntry = true;
                this.render();
            }

            async saveScan(parsedData, actualCases) {
                const userName = getUserName();
                const sessionType = this.activeStockTake?.sessionType || 'FP';
                const sessionId = this.activeStockTake?.id || null;
                const locationPayload = this.sessionSettings.locationScanningEnabled ? {
                    location: this.sessionSettings.currentLocation || null,
                    site: this.sessionSettings.site || null,
                    aisle: this.sessionSettings.aisle || null,
                    rack: this.sessionSettings.rack || null
                } : {
                    location: null,
                    site: null,
                    aisle: null,
                    rack: null
                };

                // Check if this is an update to an existing pallet scan
                const isUpdate = parsedData.isDuplicatePallet && parsedData.existingScanId;

                console.log('Saving scan:', { parsedData, actualCases, userName, sessionType, sessionId, supabaseEnabled: !!supabase, isUpdate });

                // For RM items, check if same item+batch+expiry+quantity already exists
                // This catches potential duplicate entries (same count recorded twice)
                if (sessionType === 'RM' && supabase && sessionId && !isUpdate) {
                    const rmDuplicate = await checkRMDuplicateQuantity(
                        sessionId,
                        parsedData.stockCode,
                        parsedData.batchNumber,
                        parsedData.expiryDate,
                        actualCases
                    );

                    if (rmDuplicate) {
                        const timestamp = rmDuplicate.scanned_at || rmDuplicate.created_at;
                        const scannedByName = rmDuplicate.scanned_by || 'Unknown';
                        const locationInfo = rmDuplicate.location ? `\nLocation: ${rmDuplicate.location}` : '';
                        const unitType = parsedData.unitType || getUnitTypeForStockCode(parsedData.stockCode);
                        const unitLabel = unitType === 'kg' ? 'KG' : 'units';

                        if (navigator.vibrate) navigator.vibrate([200, 100, 200]);

                        const confirmed = await new Promise(resolve => {
                            this.showModal({
                                title: 'Possible Duplicate Entry',
                                message: `This exact recording already exists:\n\n` +
                                    `Stock Code: ${parsedData.stockCode}\n` +
                                    `Batch: ${parsedData.batchNumber}\n` +
                                    `Quantity: ${actualCases} ${unitLabel}\n` +
                                    (parsedData.expiryDate ? `Expiry: ${parsedData.expiryDate}\n` : '') +
                                    locationInfo +
                                    `\n\nRecorded by: ${scannedByName}\n` +
                                    `at ${new Date(timestamp).toLocaleString()}\n\n` +
                                    `Are you sure this is a NEW recording\n(different location/pallet)?`,
                                type: 'confirm',
                                confirmText: 'Yes, Save New',
                                cancelText: 'Cancel',
                                onConfirm: () => resolve(true),
                                onCancel: () => resolve(false)
                            });
                        });

                        if (!confirmed) {
                            // User cancelled - don't save
                            return;
                        }
                    }
                }

                // For FP 5-digit manual entries (no pallet number), check if same batch+quantity exists
                // This catches potential duplicate entries where operator enters same count twice
                if (sessionType === 'FP' && !parsedData.palletNumber && supabase && sessionId && !isUpdate) {
                    const fpManualDuplicate = await checkFPManualDuplicateQuantity(
                        sessionId,
                        parsedData.batchNumber,
                        actualCases
                    );

                    if (fpManualDuplicate) {
                        const timestamp = fpManualDuplicate.scanned_at;
                        const scannedByName = fpManualDuplicate.scanned_by || 'Unknown';

                        if (navigator.vibrate) navigator.vibrate([200, 100, 200]);

                        const confirmed = await new Promise(resolve => {
                            this.showModal({
                                title: 'Possible Duplicate Entry',
                                message: `This exact recording already exists:\n\n` +
                                    `Stock Code: ${parsedData.stockCode}\n` +
                                    `Batch: ${parsedData.batchNumber}\n` +
                                    `Quantity: ${actualCases} cases\n\n` +
                                    `Recorded by: ${scannedByName}\n` +
                                    `at ${new Date(timestamp).toLocaleString()}\n\n` +
                                    `Are you sure this is a NEW pallet?`,
                                type: 'confirm',
                                confirmText: 'Yes, Save New',
                                cancelText: 'Cancel',
                                onConfirm: () => resolve(true),
                                onCancel: () => resolve(false)
                            });
                        });

                        if (!confirmed) {
                            // User cancelled - don't save
                            return;
                        }
                    }
                }

                // Check if we have a valid session for Supabase saves
                if (supabase && !sessionId) {
                    console.warn('No active session ID - scan will be saved to localStorage only');
                    alert('No active session. Please start or join a session first. Scan saved locally.');
                }

                if (supabase && sessionId) {
                    // Handle UPDATE for duplicate pallet
                    if (isUpdate) {
                        console.log('Updating existing pallet scan:', parsedData.existingScanId);
                        try {
                            const { data, error } = await supabase
                                .from('stock_scans')
                                .update({
                                    actual_cases: actualCases,
                                    scanned_by: userName,
                                    device_id: DEVICE_ID,
                                    scanned_at: new Date().toISOString(),
                                    location: locationPayload.location,
                                    site: locationPayload.site,
                                    aisle: locationPayload.aisle,
                                    rack: locationPayload.rack
                                })
                                .eq('id', parsedData.existingScanId)
                                .select();

                            if (error) {
                                console.error('Supabase update error:', error);
                                await logClientEvent('scan-update-failed', 'error', sessionId, { error: error.message, scanId: parsedData.existingScanId });
                                throw error;
                            }

                            console.log('Updated pallet scan in Supabase:', data);
                            await logClientEvent('scan-update', 'info', sessionId, { scanId: parsedData.existingScanId, newCases: actualCases });
                        } catch (err) {
                            console.error('Failed to update scan in Supabase:', err);
                            await logClientEvent('scan-update-failed', 'error', sessionId, { message: err.message });
                            alert('Failed to update scan. Please check your connection.');
                            throw err;
                        }
                    } else {
                        // INSERT new scan
                        console.log('Saving to Supabase with sessionId:', sessionId);
                        const record = {
                            session_id: sessionId,
                            take_date: this.currentTakeDate,
                            batch_number: parsedData.batchNumber,
                            stock_code: parsedData.stockCode,
                            description: parsedData.description,
                            scanned_by: userName,
                            device_id: DEVICE_ID,
                            session_type: sessionType,
                            location: locationPayload.location,
                            site: locationPayload.site,
                            aisle: locationPayload.aisle,
                            rack: locationPayload.rack,
                            unit_type: parsedData.unitType || (sessionType === 'RM' ? getUnitTypeForStockCode(parsedData.stockCode) : 'cases'),
                            actual_cases: actualCases,
                            pallet_number: parsedData.palletNumber || null,
                            cases_on_pallet: parsedData.casesOnPallet || null,
                            expiry_date: convertDMYtoYMD(parsedData.expiryDate) || null,
                            raw_code: parsedData.raw
                        };

                        try {
                            const { data, error } = await supabase
                                .from('stock_scans')
                                .insert([record])
                                .select();

                            if (error) {
                                console.error('Supabase insert error:', error);
                                await logClientEvent('scan-insert-failed', 'error', sessionId, { error: error.message, record });
                                throw error;
                            }

                            console.log('Saved to Supabase stock_scans:', data);
                            await logClientEvent('scan-insert', 'info', sessionId, { scanId: data?.[0]?.id || null });
                        } catch (err) {
                            console.error('Failed to save to Supabase:', err);

                            // Save to offline queue instead of losing the scan
                            offlineSyncQueue.addToQueue(record);
                            const pendingCount = offlineSyncQueue.getPendingCount();

                            this.showModal({
                                title: ' Saved Offline',
                                message: `Network error - scan saved locally.\n\nIt will sync automatically when you're back online.\n\n(${pendingCount} scan${pendingCount !== 1 ? 's' : ''} pending)`,
                                type: 'warning'
                            });

                            // Trigger haptic feedback for offline save
                            this.triggerHaptic('warning');

                            // Auto-close modal after 3 seconds
                            setTimeout(() => this.closeModal(), 3000);

                            // Don't throw - we've saved it offline
                            return;
                        }
                    }
                } else {
                    // Fallback to localStorage (offline mode)
                    console.log('Saving to localStorage (no session or Supabase not available)', { supabase: !!supabase, sessionId });
                    const scan = {
                        id: 'scan:' + Date.now(),
                        timestamp: Date.now(),
                        date: new Date().toLocaleDateString(),
                        time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
                        raw: parsedData.raw,
                        batchNumber: parsedData.batchNumber,
                        palletNumber: parsedData.palletNumber,
                        casesOnPallet: parsedData.casesOnPallet,
                        actualCases: actualCases,
                        scannedBy: userName,
                        stockCode: parsedData.stockCode,
                        description: parsedData.description,
                        valid: parsedData.valid,
                        deviceId: DEVICE_ID,
                        sessionType: sessionType,
                        expiryDate: parsedData.expiryDate || null,
                        isRawMaterial: parsedData.isRawMaterial || false,
                        location: locationPayload.location,
                        site: locationPayload.site,
                        aisle: locationPayload.aisle,
                        rack: locationPayload.rack,
                        unitType: parsedData.unitType || (sessionType === 'RM' ? 'kg' : 'cases')
                    };

                    localStorage_db.set(scan.id, scan);
                }

                await this.loadScans();

                // Clear the pending scan key now that save is complete
                if (this.currentScan) {
                    const scanKey = this.getScanKey(this.currentScan);
                    this.pendingScanKeys.delete(scanKey);
                }

                this.currentScan = null;
                this.showingCaseEntry = false;
                // Clear pending render flag since we're rendering now
                this._pendingRender = false;
                this.triggerHaptic('success');
                this.render();
            }

            editScan(id) {
                console.log('editScan called with id:', id, 'type:', typeof id);
                console.log('Available scan IDs:', this.scans.map(s => ({ id: s.id, type: typeof s.id })));

                // Convert both to strings for comparison to handle UUID vs string mismatches
                const scan = this.scans.find(s => String(s.id) === String(id));
                console.log('Found scan:', scan);
                if (!scan) {
                    console.error('Scan not found for id:', id);
                    alert('Could not find scan to edit');
                    return;
                }

                this.showModal({
                    title: 'Edit Scan',
                    message: `Editing ${scan.stockCode}`,
                    type: 'form',
                    fields: [
                        {
                            name: 'actualCases',
                            label: 'Quantity',
                            type: 'number',
                            value: scan.actualCases,
                            required: true
                        },
                        {
                            name: 'batchNumber',
                            label: 'Batch Number',
                            type: 'text',
                            value: scan.batchNumber || '',
                            required: true
                        }
                    ],
                    confirmText: 'Save Changes',
                    onConfirm: (data) => this.saveEditedScan(id, data)
                });
            }

            async saveEditedScan(id, data) {
                // Convert to string for comparison
                const scanIndex = this.scans.findIndex(s => String(s.id) === String(id));
                if (scanIndex === -1) return;

                const scan = this.scans[scanIndex];
                const oldCases = scan.actualCases;
                const newCases = parseFloat(data.actualCases);
                const newBatch = data.batchNumber;

                if (isNaN(newCases)) {
                    alert('Invalid quantity');
                    return;
                }

                // Update local state
                scan.actualCases = newCases;
                scan.batchNumber = newBatch;

                // Update Supabase if connected
                if (supabase && this.activeStockTake?.id) {
                    try {
                        const { error } = await supabase
                            .from('stock_scans')
                            .update({
                                actual_cases: newCases,
                                batch_number: newBatch
                            })
                            .eq('id', id);

                        if (error) throw error;

                        await logClientEvent('scan-edit', 'info', this.activeStockTake.id, {
                            scanId: id,
                            oldCases,
                            newCases,
                            newBatch
                        });

                    } catch (err) {
                        console.error('Failed to update scan in Supabase:', err);
                        alert('Scan updated locally but failed to sync to Supabase.');
                    }
                } else {
                    // Offline mode - update localStorage
                    localStorage_db.set(id, scan);
                }

                this.render();
            }

            async deleteScan(id) {
                // Find the scan to show in confirmation (use string comparison)
                const scan = this.scans.find(s => String(s.id) === String(id));
                const scanInfo = scan ? `${scan.stockCode} - ${scan.description}` : 'this scan';

                // Use custom confirm dialog
                const confirmed = await new Promise(resolve => {
                    this.showModal({
                        title: 'Delete Scan',
                        message: `Are you sure you want to delete ${scanInfo}?`,
                        type: 'confirm',
                        confirmText: 'Delete',
                        cancelText: 'Cancel',
                        onConfirm: () => resolve(true),
                        onCancel: () => resolve(false)
                    });
                });

                if (!confirmed) return;

                if (supabase) {
                    // Delete from stock_scans table
                    try {
                        const { error } = await supabase
                            .from('stock_scans')
                            .delete()
                            .eq('id', id);

                        if (error) {
                            console.error('Supabase delete error:', error);
                            await logClientEvent('scan-delete-failed', 'error', this.activeStockTake?.id || null, { scanId: id, message: error.message });
                            throw error;
                        }

                        console.log('Deleted from stock_scans:', id);
                        await logClientEvent('scan-delete', 'warning', this.activeStockTake?.id || null, { scanId: id });
                    } catch (err) {
                        console.error('Failed to delete from Supabase:', err);
                        alert('Failed to delete scan from database.');
                        return;
                    }
                } else {
                    localStorage_db.delete(id);
                }

                // Remove from local scans array immediately (use string comparison)
                this.scans = this.scans.filter(s => String(s.id) !== String(id));
                this.triggerHaptic('heavy');
                this.render();
            }

            async submitCaseCount() {
                const input = document.getElementById('caseInput');
                const isKg = this.currentScan?.unitType === 'kg';
                const actualCases = isKg ? parseFloat(input.value) : parseInt(input.value);

                console.log('submitCaseCount called:', { value: input?.value, isKg, actualCases, currentScan: this.currentScan });

                if (isNaN(actualCases) || actualCases < 0) {
                    alert(isKg ? 'Please enter a valid weight in kg' : 'Please enter a valid quantity');
                    return;
                }

                const save = async () => {
                    console.log('save() called, about to call saveScan');
                    try {
                        await this.saveScan(this.currentScan, actualCases);
                        console.log('saveScan completed successfully');
                    } catch (err) {
                        console.error('Save scan error:', err);
                        alert('Failed to save scan. Please try again.');
                    }
                };

                if ((this.activeStockTake?.sessionType === 'RM' || this.currentScan?.isRawMaterial) && !this.currentScan?.expiryDate) {
                    console.log('RM scan without expiry - showing modal');
                    this.showModal({
                        title: 'Expiry Date Required',
                        message: 'Enter expiry date (DD/MM/YY or YYYY-MM-DD) or leave blank:',
                        type: 'input',
                        confirmText: 'Continue',
                        onConfirm: (data) => {
                            console.log('Expiry modal onConfirm called:', data);
                            const manualExpiry = data.value;
                            if (manualExpiry && manualExpiry.trim() !== '') {
                                // Convert DD/MM/YY to YYYY-MM-DD if needed
                                const convertedExpiry = convertDMYtoYMD(manualExpiry.trim());
                                const parsedDate = new Date(convertedExpiry);
                                if (isNaN(parsedDate.getTime())) {
                                    alert('Invalid expiry date format. Please use DD/MM/YY or YYYY-MM-DD.');
                                    return;
                                }
                                this.currentScan.expiryDate = convertedExpiry;
                                console.log('Calling save with expiry:', this.currentScan.expiryDate);
                                save();
                            } else {
                                console.log('No expiry entered - showing confirmation modal');
                                this.showModal({
                                    title: 'Confirm No Expiry',
                                    message: 'No expiry date will be recorded. Continue?',
                                    type: 'confirm',
                                    confirmText: 'Yes, Continue',
                                    cancelText: 'Go Back',
                                    onConfirm: () => {
                                        console.log('No-expiry confirmation - calling save');
                                        save();
                                    }
                                });
                            }
                        }
                    });
                    return;
                }

                await save();
            }

            cancelCaseEntry() {
                // Clear the pending scan key when cancelling
                if (this.currentScan) {
                    const scanKey = this.getScanKey(this.currentScan);
                    this.pendingScanKeys.delete(scanKey);
                }

                this.currentScan = null;
                this.showingCaseEntry = false;
                // Check if a render was deferred during sync while case entry was open
                if (this._pendingRender) {
                    this._pendingRender = false;
                }
                this.render();
            }

            async toggleSessionPause() {
                if (!this.activeStockTake?.id) return;
                const nextStatus = this.activeStockTake.status === 'paused' ? 'active' : 'paused';

                const processStatusChange = async (reason) => {
                    if (supabaseSessionsEnabled) {
                        await changeSessionStatusSupabase(this.activeStockTake, nextStatus, reason, {});
                    } else {
                        await updateSession(this.activeStockTake.date, this.activeStockTake.id, { status: nextStatus });
                    }
                    this.activeStockTake = { ...this.activeStockTake, status: nextStatus };
                    setActiveStockTake(this.activeStockTake);
                    if (nextStatus === 'paused') {
                        this.stopHeartbeat('paused');
                        this.triggerHaptic('warning');
                    } else {
                        if (supabaseSessionsEnabled) {
                            this.startHeartbeat('active');
                        }
                        this.triggerHaptic('success');
                    }
                    this.render();
                };

                if (nextStatus === 'paused') {
                    this.showModal({
                        title: 'Pause Session',
                        message: 'Reason for pausing (optional):',
                        type: 'input',
                        confirmText: 'Pause',
                        onConfirm: (data) => {
                            processStatusChange(data.value || 'Paused manually');
                        }
                    });
                } else {
                    await processStatusChange('Resumed manually');
                }
            }

            selectExpiryDate(expiryDate) {
                if (!this.pendingScan) return;

                // Set the selected expiry date
                this.pendingScan.expiryDate = expiryDate;
                this.pendingScan.needsExpiryConfirmation = false;

                this.showingExpirySelection = false;

                // RM items allow duplicates (same item can be in different locations)
                const parsed = this.pendingScan;
                this.pendingScan = null;

                // Proceed directly to case entry
                this.currentScan = parsed;
                this.showingCaseEntry = true;
                this.render();
            }

            cancelExpirySelection() {
                this.pendingScan = null;
                this.showingExpirySelection = false;
                this.render();
            }

            manualEntry() {
                this.stopScanning();
                const sessionType = this.activeStockTake?.sessionType || 'FP';

                if (sessionType === 'FP') {
                    // FP: Allow entering 13-digit full code OR 5-digit batch code
                    this.showModal({
                        title: 'Type Code',
                        message: 'Enter 13-digit barcode OR 5-digit batch number:',
                        type: 'input',
                        confirmText: 'Process',
                        onConfirm: (data) => {
                            const code = (data.value || '').trim();
                            if (!code) return;

                            // Check if it's a full 13-digit code
                            if (/^\d{13}$/.test(code)) {
                                // Process as normal barcode
                                this.onScanSuccess(code);
                                return;
                            }

                            // Check if it's a 5-digit batch code
                            if (/^\d{5}$/.test(code)) {
                                // Lookup product in database
                                const productInfo = productDatabase[code];
                                if (!productInfo || productInfo.stockCode === 'UNKNOWN') {
                                    // Product not found - show search to select product
                                    // Create a partial parsed object for manual entry
                                    const manualParsed = {
                                        valid: true,
                                        batchNumber: code,
                                        palletNumber: 'MANUAL',
                                        casesOnPallet: 0,
                                        isUnknownProduct: true,
                                        isManualEntry: true
                                    };

                                    // Generate scanKey for duplicate prevention
                                    const timestamp = Date.now().toString().slice(-8);
                                    const rawCode = code.padStart(5, '0') + timestamp;
                                    manualParsed.raw = rawCode;
                                    const scanKey = `${code}-MANUAL-${rawCode}`;

                                    // Store data for after product selection
                                    this._unknownFPParsed = manualParsed;
                                    this._unknownFPScanKey = scanKey;

                                    // Show product search modal
                                    this._showFPProductSearch(manualParsed, scanKey);
                                    return;
                                }

                                // Product found - now ask for number of cases
                                this.showModal({
                                    title: 'Enter Case Count',
                                    message: `Product: ${productInfo.stockCode}\n${productInfo.description}\n\nEnter number of cases:`,
                                    type: 'input',
                                    confirmText: 'Save',
                                    onConfirm: (caseData) => {
                                        const cases = parseInt(caseData.value, 10);
                                        if (isNaN(cases) || cases < 0) {
                                            alert('Please enter a valid number of cases');
                                            return;
                                        }

                                        // Generate a 13-digit raw code for manual entry
                                        // Format: 5-digit batch + 8-digit timestamp (last 8 chars of epoch)
                                        const timestamp = Date.now().toString().slice(-8);
                                        const rawCode = code.padStart(5, '0') + timestamp;

                                        // Create a manual entry scan object
                                        const manualScan = {
                                            valid: true,
                                            raw: rawCode, // 13-digit code for database constraint
                                            batchNumber: code,
                                            palletNumber: 'MANUAL',
                                            casesOnPallet: cases,
                                            stockCode: productInfo.stockCode,
                                            description: productInfo.description,
                                            isManualEntry: true
                                        };

                                        // Save the scan directly
                                        this.saveScan(manualScan, cases).then(() => {
                                            // Show success feedback
                                            if (navigator.vibrate) navigator.vibrate(200);
                                        }).catch(err => {
                                            console.error('Failed to save manual entry:', err);
                                            alert('Failed to save. Please try again.');
                                        });
                                    }
                                });
                                return;
                            }

                            // Invalid format
                            alert('Please enter either:\n 13 digits (full barcode)\n 5 digits (batch code only)');
                        }
                    });
                } else {
                    // RM: Keep existing behavior - enter full code
                    this.showModal({
                        title: 'Manual Entry',
                        message: 'Enter the QR code manually:',
                        type: 'input',
                        confirmText: 'Process',
                        onConfirm: (data) => {
                            if (data.value && data.value.trim()) {
                                this.onScanSuccess(data.value.trim());
                            }
                        }
                    });
                }
            }

            showProductDatabase() {
                // Show appropriate database based on session type
                if (this.activeStockTake?.sessionType === 'RM') {
                    this.showingRMProductDB = true;
                } else {
                    this.showingProductDB = true;
                }
                this.render();
            }

            hideProductDatabase() {
                this.showingProductDB = false;
                this.showingRMProductDB = false;
                this.render();
            }

            showSettings() {
                this.showingStartStockTake = false;
                this.showingSettings = true;
                this.render();
            }

            hideSettings() {
                this.showingSettings = false;
                this.showingStartStockTake = true;
                this.refreshSessionsFromSupabase(); // Refresh sessions when returning to start screen
                this.render();
            }

            goHome() {
                // Stop current session activities but don't end the session
                this.stopAutoSync();
                this.stopHeartbeat();
                clearActiveStockTake();
                this.activeStockTake = null;
                this.scans = [];
                this.selectedStockTakeType = null;
                this.showingStartStockTake = true;
                this.refreshSessionsFromSupabase(); // Refresh sessions when going home
                this.render();
            }

            // Session History Methods
            showSessionHistory() {
                this.showingStartStockTake = false;
                this.showingSessionHistory = true;
                this.loadAvailableSessions();
                this.render();
            }

            hideSessionHistory() {
                this.showingSessionHistory = false;
                this.historyDate = null;
                this.historySessions = [];
                this.historyScans = [];
                this.showingStartStockTake = true;
                this.render();
            }

            async loadAvailableSessions() {
                // Get all unique sessions from localStorage
                const allSessions = [];
                const seenSessionIds = new Set();
                const activeSessionIds = new Set();
                const today = new Date().toLocaleDateString('en-CA');

                // First, get the current active session from activeStockTake
                const activeStockTake = getActiveStockTake();
                if (activeStockTake && activeStockTake.id) {
                    activeSessionIds.add(activeStockTake.id);
                }

                // Also check for any sessions stored with 'active' status in localStorage
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('stocktake_')) {
                        try {
                            const session = JSON.parse(localStorage.getItem(key));
                            if (session && session.id && session.status === 'active') {
                                activeSessionIds.add(session.id);
                            }
                        } catch (e) {
                            // Ignore parsing errors for this check
                        }
                    }
                }

                // Now load all sessions from localStorage
                const role = getUserRole();
                const displayName = getDisplayName();
                const userWarehouse = getUserWarehouse();

                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('stocktake_')) {
                        try {
                            const session = JSON.parse(localStorage.getItem(key));
                            if (session && session.id && !seenSessionIds.has(session.id)) {
                                // Filter by warehouse for non-admin users
                                if (role !== 'admin' && userWarehouse) {
                                    const sessionWarehouse = session.warehouse || '';
                                    // Only show sessions that match user's warehouse
                                    if (sessionWarehouse !== userWarehouse) {
                                        continue; // Skip sessions from different warehouse
                                    }
                                }

                                seenSessionIds.add(session.id);
                                // Determine if session is active
                                const isActive = activeSessionIds.has(session.id);
                                allSessions.push({
                                    id: session.id,
                                    date: session.date,
                                    sessionType: session.sessionType || 'FP',
                                    device: session.device || 'Unknown',
                                    startTime: session.startTime,
                                    endTime: session.endTime,
                                    status: isActive ? 'active' : (session.status || 'completed'),
                                    startedBy: session.startedBy || session.userName,
                                    warehouse: session.warehouse || '',
                                    deviceCount: session.devices?.length || 0,
                                    activeDeviceCount: session.devices?.filter(d => d.status === 'active').length || 0,
                                    devices: session.devices || []
                                });
                            }
                        } catch (e) {
                            console.error('Error parsing session:', e);
                        }
                    }
                }

                // Also load sessions from Supabase if available
                if (supabase && this.isBrowserOnline) {
                    try {
                        // Get sessions from stock_takes table (has started_by info)
                        const { data: stockTakesData, error: stockTakesError } = await supabase
                            .from('stock_takes')
                            .select('id, session_type, take_date, status, started_by, started_at, metadata')
                            .order('take_date', { ascending: false })
                            .order('started_at', { ascending: false });

                        if (!stockTakesError && stockTakesData) {
                            const role = getUserRole();
                            const userWarehouse = getUserWarehouse();

                            stockTakesData.forEach(session => {
                                if (session.id && !seenSessionIds.has(session.id)) {
                                    // Filter by warehouse for non-admin users
                                    if (role !== 'admin' && userWarehouse) {
                                        const sessionWarehouse = session.metadata?.warehouse || '';
                                        // Only show sessions that match user's warehouse
                                        if (sessionWarehouse !== userWarehouse) {
                                            return; // Skip sessions from different warehouse
                                        }
                                    }

                                    const isActive = activeSessionIds.has(session.id);
                                    const startTime = session.started_at
                                        ? new Date(session.started_at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
                                        : '';

                                    // Get creator device from metadata or first device in list
                                    const creatorDevice = session.metadata?.devices?.[0]?.deviceId || session.started_by || 'Unknown';

                                    allSessions.push({
                                        id: session.id,
                                        date: session.take_date,
                                        sessionType: session.session_type || 'FP',
                                        device: creatorDevice,
                                        startTime: startTime,
                                        status: isActive ? 'active' : (session.status || 'completed'),
                                        startedBy: session.started_by,
                                        warehouse: session.metadata?.warehouse || '',
                                        deviceCount: session.metadata?.devices?.length || 0,
                                        devices: session.metadata?.devices || []
                                    });
                                    seenSessionIds.add(session.id);
                                }
                            });

                            // Fetch device counts from session_devices table for all sessions
                            const sessionIdsToFetch = stockTakesData.map(s => s.id).filter(Boolean);
                            if (sessionIdsToFetch.length > 0) {
                                try {
                                    const { data: deviceData, error: deviceError } = await supabase
                                        .from('session_devices')
                                        .select('session_id, device_id, user_name, status')
                                        .in('session_id', sessionIdsToFetch);

                                    if (!deviceError && deviceData) {
                                        // Group by session_id
                                        const devicesBySession = {};
                                        deviceData.forEach(d => {
                                            if (!devicesBySession[d.session_id]) {
                                                devicesBySession[d.session_id] = [];
                                            }
                                            devicesBySession[d.session_id].push(d);
                                        });

                                        // Update session device counts
                                        allSessions.forEach(session => {
                                            const sessionDevices = devicesBySession[session.id] || [];
                                            session.deviceCount = sessionDevices.length;
                                            session.activeDeviceCount = sessionDevices.filter(d => d.status === 'active').length;
                                            session.deviceUsers = [...new Set(sessionDevices.map(d => d.user_name).filter(Boolean))];
                                        });
                                    }
                                } catch (e) {
                                    console.warn('Failed to fetch device counts:', e);
                                }
                            }
                        }

                        // Fallback: also check stock_scans for any sessions not in stock_takes
                        const { data, error } = await supabase
                            .from('stock_scans')
                            .select('session_id, session_type, scanned_at, device_id, scanned_by')
                            .order('scanned_at', { ascending: false });

                        if (!error && data) {
                            const role = getUserRole();
                            const userWarehouse = getUserWarehouse();

                            // Group by session_id to get unique sessions
                            const sessionMap = new Map();
                            data.forEach(scan => {
                                if (scan.session_id && !sessionMap.has(scan.session_id) && !seenSessionIds.has(scan.session_id)) {
                                    const scanDate = new Date(scan.scanned_at);
                                    const sessionDate = scanDate.toLocaleDateString('en-CA');
                                    // Check if this is an active session
                                    const isActive = activeSessionIds.has(scan.session_id);
                                    sessionMap.set(scan.session_id, {
                                        id: scan.session_id,
                                        date: sessionDate,
                                        sessionType: scan.session_type || 'FP',
                                        device: scan.device_id || 'Unknown',
                                        startTime: scanDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
                                        status: isActive ? 'active' : 'completed',
                                        startedBy: scan.scanned_by // Use first scanner as proxy for creator
                                    });
                                    seenSessionIds.add(scan.session_id);
                                }
                            });

                            // Add sessions to list (stock_scans don't have warehouse info, so include all for fallback)
                            sessionMap.forEach(session => {
                                allSessions.push(session);
                            });
                        }
                    } catch (e) {
                        console.error('Error loading sessions from Supabase:', e);
                    }
                }

                // Sort by date descending, with active sessions first
                allSessions.sort((a, b) => {
                    // Active sessions come first
                    if (a.status === 'active' && b.status !== 'active') return -1;
                    if (b.status === 'active' && a.status !== 'active') return 1;
                    const dateCompare = (b.date || '').localeCompare(a.date || '');
                    if (dateCompare !== 0) return dateCompare;
                    return (b.startTime || '').localeCompare(a.startTime || '');
                });

                this.historySessions = allSessions;
                this.render(); // Re-render after loading sessions
            }

            async loadSessionHistory(sessionId) {
                // Find the session first
                const session = this.historySessions.find(s => s.id === sessionId);
                if (!session) {
                    alert('Session not found');
                    return;
                }

                // Set session and show loading state immediately (don't clear scans yet)
                this.selectedHistorySession = session;
                this.historyLoading = true;
                this.render(); // Show loading indicator immediately

                if (!supabase) {
                    this.historyLoading = false;
                    this.historyScans = [];
                    alert('Session history requires Supabase connectivity.');
                    this.render();
                    return;
                }

                if (!this.isBrowserOnline) {
                    this.historyLoading = false;
                    this.historyScans = [];
                    alert('Session history is unavailable while offline.');
                    this.render();
                    return;
                }

                try {
                    const { data, error } = await supabase
                        .from('stock_scans')
                        .select('id,batch_number,stock_code,description,actual_cases,pallet_number,location,site,aisle,rack,expiry_date,unit_type,scanned_at,scanned_by')
                        .eq('session_id', sessionId)
                        .order('scanned_at', { ascending: true });

                    if (error) throw error;

                    this.historyScans = (data || []).map(item => ({
                        id: item.id,
                        batchNumber: item.batch_number,
                        stockCode: item.stock_code,
                        description: item.description,
                        cases: item.actual_cases,
                        palletNumber: item.pallet_number,
                        location: item.location,
                        site: item.site,
                        aisle: item.aisle,
                        rack: item.rack,
                        expiryDate: item.expiry_date,
                        unitType: item.unit_type || (session.sessionType === 'RM' ? 'kg' : 'cases'),
                        timestamp: item.scanned_at,
                        scannedBy: item.scanned_by
                    }));
                } catch (error) {
                    console.error('Error loading history scans:', error);
                    await logClientEvent('history-load-failed', 'error', sessionId, { message: error.message });
                    this.historyScans = [];
                    alert('Error loading session scans. Check console for details.');
                }

                this.historyLoading = false;
                this.render();
            }

            exportHistorySession() {
                if (!this.selectedHistorySession || this.historyScans.length === 0) {
                    alert('No session data to export');
                    return;
                }

                const session = this.selectedHistorySession;

                // Prepare export data
                const exportData = this.historyScans.map(scan => {
                    const base = {
                        'Stock Code': scan.stockCode,
                        'Description': scan.description,
                        'Batch Number': scan.batchNumber
                    };

                    if (session.sessionType === 'RM') {
                        base['Quantity'] = scan.cases;
                        base['Unit'] = scan.unitType === 'kg' ? 'kg' : 'units';
                        base['Location'] = scan.location || '';
                        base['Expiry Date'] = scan.expiryDate || '';
                    } else {
                        base['Cases'] = scan.cases;
                        base['Pallet Number'] = scan.palletNumber || '';
                        base['Location'] = scan.location || '';
                    }
                    base['Site'] = scan.site || '';
                    base['Aisle'] = scan.aisle || '';
                    base['Rack'] = scan.rack || '';

                    base['Scanned By'] = scan.scannedBy || '';
                    base['Timestamp'] = new Date(scan.timestamp).toLocaleString();

                    return base;
                });

                // Create workbook
                const wb = XLSX.utils.book_new();
                const ws = XLSX.utils.json_to_sheet(exportData);
                XLSX.utils.book_append_sheet(wb, ws, 'Stock Count');

                // Generate filename
                const sessionTypeLabel = session.sessionType === 'RM' ? 'RawMaterials' : 'FinishedProducts';
                const filename = `StockCount_${sessionTypeLabel}_${session.date}_${session.id.slice(-6)}.xlsx`;

                // Download
                XLSX.writeFile(wb, filename);
            }

            async saveSettings() {
                alert('Database credentials are configured. Use Test Connection to verify.');
            }

            async testConnection() {
                const connected = await db.init();

                if (connected) {
                    await this.loadScans();
                    if (!this.syncInterval) {
                        this.startAutoSync();
                    }
                    const modeLabel = db.mode === 'supabase' ? 'Supabase' : 'local cache';
                    if (db.mode === 'localStorage') {
                        alert('Connected in offline mode. Data will sync once Supabase is reachable.');
                    } else {
                        alert(` Connected to ${modeLabel} successfully!`);
                    }
                } else {
                    alert(' Connection failed. Check browser console for details.');
                }

                this.render();
            }

            addProduct() {
                this.showModal({
                    title: 'Add New Product',
                    type: 'form',
                    fields: [
                        { name: 'batch', label: 'Batch Number', placeholder: '5 digits', required: true },
                        { name: 'stockCode', label: 'Stock Code', placeholder: 'e.g. FP123', required: true },
                        { name: 'description', label: 'Description', placeholder: 'Product name', required: true }
                    ],
                    confirmText: 'Add Product',
                    onConfirm: async (data) => {
                        const { batch, stockCode, description } = data;
                        if (!/^\d{5}$/.test(batch)) {
                            alert('Invalid batch number (must be 5 digits)');
                            return;
                        }

                        productDatabase[batch] = { stockCode, description };
                        saveProductDatabase();

                        await addProductToSupabase(batch, stockCode, description);

                        this.showModal({
                            title: 'Success',
                            message: 'Product added successfully!',
                            type: 'alert'
                        });
                    }
                });
            }

            addRawMaterial() {
                this.showModal({
                    title: 'Add Raw Material',
                    type: 'form',
                    fields: [
                        { name: 'stockCode', label: 'Stock Code', placeholder: 'Starts with letter', required: true },
                        { name: 'description', label: 'Description', placeholder: 'Material name', required: true },
                        { name: 'batchNumber', label: 'Batch Number (Optional)', placeholder: 'e.g. B123', required: false },
                        { name: 'expiryDate', label: 'Expiry Date (Optional)', placeholder: 'YYYY-MM-DD', type: 'date', required: false }
                    ],
                    confirmText: 'Add Material',
                    onConfirm: async (data) => {
                        const { stockCode, description, batchNumber, expiryDate } = data;

                        if (!/^[A-Za-z]/.test(stockCode)) {
                            alert('Invalid stock code - must start with a letter');
                            return;
                        }

                        // Add to database
                        if (!rawMaterialsDatabase[stockCode]) {
                            rawMaterialsDatabase[stockCode] = { description, batches: {} };
                        }
                        if (batchNumber) {
                            rawMaterialsDatabase[stockCode].batches[batchNumber] = { expiryDate: expiryDate || null };
                        }
                        rawMaterialsDatabase[stockCode].description = description;

                        saveRawMaterialsDatabase();

                        await addRawMaterialToSupabase(stockCode, description, batchNumber, expiryDate);

                        this.showModal({
                            title: 'Success',
                            message: 'Raw Material added successfully!',
                            type: 'alert'
                        });
                    }
                });
            }

            // Quick add unknown scanned item to database - shows scan popup for stock code
            addScannedItemToDatabase(scan) {
                const isRM = scan.sessionType === 'RM';
                const escapedScanId = scan.id.toString().replace(/'/g, "\\'");

                // Show a simple popup with X close, Scan button, and Search button (for FP)
                const popup = document.createElement('div');
                popup.id = 'add-to-db-popup';
                popup.innerHTML = `
                    <div class="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center p-4 z-[9999]">
                        <div class="bg-white rounded-2xl shadow-2xl w-full max-w-sm overflow-hidden">
                            <div class="p-4 border-b border-slate-100 flex items-center justify-between">
                                <h3 class="text-lg font-bold text-slate-900">Add to Database</h3>
                                <button onclick="document.getElementById('add-to-db-popup').remove()" class="p-2 hover:bg-slate-100 rounded-full transition-colors">
                                    <svg class="w-5 h-5 text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                            <div class="p-6">
                                <div class="text-center mb-6">
                                    <div class="w-16 h-16 bg-orange-100 rounded-full flex items-center justify-center mx-auto mb-3">
                                        <svg class="w-8 h-8 text-orange-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/>
                                        </svg>
                                    </div>
                                    <p class="text-slate-900 font-medium mb-1">Unknown ${isRM ? 'Material' : 'Product'}</p>
                                    <p class="text-slate-500 text-sm">Batch: <span class="font-mono font-bold">${scan.batchNumber || 'N/A'}</span></p>
                                </div>
                                
                                <div class="space-y-3">
                                    <button onclick="app.scanStockCodeForProduct('${escapedScanId}', ${isRM})" class="w-full bg-blue-600 hover:bg-blue-700 text-white py-4 rounded-xl font-bold shadow-lg shadow-blue-200 transition-all flex items-center justify-center gap-3">
                                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v1m6 11h2m-6 0h-2v4m0-11v3m0 0h.01M12 12h4.01M16 20h4M4 12h4m12 0h.01M5 8h2a1 1 0 001-1V5a1 1 0 00-1-1H5a1 1 0 00-1 1v2a1 1 0 001 1zm12 0h2a1 1 0 001-1V5a1 1 0 00-1-1h-2a1 1 0 00-1 1v2a1 1 0 001 1zM5 20h2a1 1 0 001-1v-2a1 1 0 00-1-1H5a1 1 0 00-1 1v2a1 1 0 001 1z"/>
                                        </svg>
                                        Scan Stock Code
                                    </button>
                                    
                                    ${!isRM ? `
                                    <button onclick="app.searchProductsForScan('${escapedScanId}')" class="w-full bg-emerald-600 hover:bg-emerald-700 text-white py-4 rounded-xl font-bold shadow-lg shadow-emerald-200 transition-all flex items-center justify-center gap-3">
                                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
                                        </svg>
                                        Search Products
                                    </button>
                                    ` : ''}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                document.body.appendChild(popup);
            }

            // Search existing products to link to a scan
            searchProductsForScan(scanId) {
                // Close the add-to-db popup
                const popup = document.getElementById('add-to-db-popup');
                if (popup) popup.remove();

                // Find the scan
                const scan = this.scans.find(s => String(s.id) === String(scanId));
                if (!scan) {
                    alert('Scan not found');
                    return;
                }

                // Store reference for later
                this._searchingScanId = scanId;
                this._searchingScan = scan;

                // Get unique products from database (by stock code)
                const uniqueProducts = {};
                for (const [batch, info] of Object.entries(productDatabase)) {
                    if (info.stockCode && !uniqueProducts[info.stockCode]) {
                        uniqueProducts[info.stockCode] = {
                            stockCode: info.stockCode,
                            description: info.description || 'No description'
                        };
                    }
                }
                this._allProducts = Object.values(uniqueProducts).sort((a, b) =>
                    a.stockCode.localeCompare(b.stockCode)
                );

                // Create search overlay
                const searchOverlay = document.createElement('div');
                searchOverlay.id = 'product-search-overlay';
                searchOverlay.innerHTML = this._renderProductSearchHTML('');
                document.body.appendChild(searchOverlay);

                // Focus on search input
                setTimeout(() => {
                    const input = document.getElementById('product-search-input');
                    if (input) input.focus();
                }, 100);
            }

            _renderProductSearchHTML(query) {
                const scan = this._searchingScan;
                const filteredProducts = query.trim() === ''
                    ? this._allProducts.slice(0, 20) // Show first 20 if no query
                    : this._allProducts.filter(p =>
                        p.stockCode.toLowerCase().includes(query.toLowerCase()) ||
                        p.description.toLowerCase().includes(query.toLowerCase())
                    ).slice(0, 50);

                return `
                    <div class="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center p-4 z-[9999]">
                        <div class="bg-white rounded-2xl shadow-2xl w-full max-w-md max-h-[80vh] flex flex-col overflow-hidden">
                            <div class="p-4 border-b border-slate-100 flex items-center justify-between flex-shrink-0">
                                <div>
                                    <h3 class="text-lg font-bold text-slate-900">Search Products</h3>
                                    <p class="text-xs text-slate-500">Batch: ${scan?.batchNumber || 'N/A'}</p>
                                </div>
                                <button onclick="app.closeProductSearch()" class="p-2 hover:bg-slate-100 rounded-full transition-colors">
                                    <svg class="w-5 h-5 text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                            
                            <div class="p-4 border-b border-slate-100 flex-shrink-0">
                                <div class="relative">
                                    <svg class="w-5 h-5 text-slate-400 absolute left-3 top-1/2 -translate-y-1/2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
                                    </svg>
                                    <input 
                                        id="product-search-input"
                                        type="text" 
                                        placeholder="Search by stock code or description..."
                                        value="${query}"
                                        oninput="app.onProductSearchInput(this.value)"
                                        class="w-full pl-10 pr-4 py-3 border border-slate-200 rounded-xl focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none text-sm"
                                    />
                                </div>
                            </div>
                            
                            <div class="flex-1 overflow-y-auto p-2">
                                ${filteredProducts.length === 0 ? `
                                    <div class="text-center py-8 text-slate-500">
                                        <svg class="w-12 h-12 mx-auto mb-3 text-slate-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                        </svg>
                                        <p class="font-medium">No products found</p>
                                        <p class="text-sm mt-1">Try a different search term</p>
                                    </div>
                                ` : filteredProducts.map(product => `
                                    <button 
                                        onclick="app.selectProductForScan('${product.stockCode.replace(/'/g, "\\'")}')"
                                        class="w-full text-left p-3 hover:bg-blue-50 rounded-xl transition-colors flex items-center gap-3 border border-transparent hover:border-blue-200"
                                    >
                                        <div class="w-10 h-10 bg-blue-100 rounded-lg flex items-center justify-center flex-shrink-0">
                                            <span class="text-blue-600 font-bold text-xs">${product.stockCode.substring(0, 3)}</span>
                                        </div>
                                        <div class="flex-1 min-w-0">
                                            <div class="font-bold text-slate-900 text-sm">${product.stockCode}</div>
                                            <div class="text-slate-500 text-xs truncate">${product.description}</div>
                                        </div>
                                        <svg class="w-5 h-5 text-slate-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                                        </svg>
                                    </button>
                                `).join('')}
                            </div>
                            
                            <div class="p-4 border-t border-slate-100 flex-shrink-0">
                                <p class="text-xs text-slate-400 text-center">
                                    ${filteredProducts.length} product${filteredProducts.length !== 1 ? 's' : ''} found
                                    ${this._allProducts.length > 0 ? ` (${this._allProducts.length} total)` : ''}
                                </p>
                            </div>
                        </div>
                    </div>
                `;
            }

            onProductSearchInput(query) {
                const overlay = document.getElementById('product-search-overlay');
                if (overlay) {
                    overlay.innerHTML = this._renderProductSearchHTML(query);
                    // Re-focus input and restore cursor position
                    const input = document.getElementById('product-search-input');
                    if (input) {
                        input.focus();
                        input.setSelectionRange(query.length, query.length);
                    }
                }
            }

            closeProductSearch() {
                const overlay = document.getElementById('product-search-overlay');
                if (overlay) overlay.remove();
                this._searchingScanId = null;
                this._searchingScan = null;
                this._allProducts = [];
            }

            // FP Product Search during initial scan flow (unknown product)
            _showFPProductSearch(parsed, scanKey) {
                // Get unique products from database (by stock code)
                const uniqueProducts = {};
                for (const [batch, info] of Object.entries(productDatabase)) {
                    if (info.stockCode && !uniqueProducts[info.stockCode]) {
                        uniqueProducts[info.stockCode] = {
                            stockCode: info.stockCode,
                            description: info.description || 'No description'
                        };
                    }
                }
                this._fpSearchProducts = Object.values(uniqueProducts).sort((a, b) =>
                    a.stockCode.localeCompare(b.stockCode)
                );

                // Create search overlay
                const searchOverlay = document.createElement('div');
                searchOverlay.id = 'fp-product-search-overlay';
                searchOverlay.innerHTML = this._renderFPProductSearchHTML('', parsed);
                document.body.appendChild(searchOverlay);

                // Focus on search input
                setTimeout(() => {
                    const input = document.getElementById('fp-product-search-input');
                    if (input) input.focus();
                }, 100);
            }

            _renderFPProductSearchHTML(query, parsed) {
                const filteredProducts = query.trim() === ''
                    ? this._fpSearchProducts.slice(0, 20)
                    : this._fpSearchProducts.filter(p =>
                        p.stockCode.toLowerCase().includes(query.toLowerCase()) ||
                        p.description.toLowerCase().includes(query.toLowerCase())
                    ).slice(0, 50);

                return `
                    <div class="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center p-4 z-[9999]">
                        <div class="bg-white rounded-2xl shadow-2xl w-full max-w-md max-h-[85vh] flex flex-col overflow-hidden">
                            <div class="p-4 border-b border-slate-100 flex-shrink-0">
                                <div class="flex items-center justify-between mb-2">
                                    <h3 class="text-lg font-bold text-slate-900"> Select Product</h3>
                                    <button onclick="app._cancelFPProductSearch()" class="p-2 hover:bg-slate-100 rounded-full transition-colors">
                                        <svg class="w-5 h-5 text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                        </svg>
                                    </button>
                                </div>
                                <div class="bg-orange-50 border border-orange-200 rounded-lg p-3">
                                    <p class="text-orange-800 text-sm font-medium">Unknown Batch: <span class="font-mono">${parsed?.batchNumber || 'N/A'}</span></p>
                                    <p class="text-orange-600 text-xs mt-1">Pallet: ${parsed?.palletNumber || 'N/A'}  Cases: ${parsed?.casesOnPallet || 0}</p>
                                </div>
                            </div>
                            
                            <div class="p-4 border-b border-slate-100 flex-shrink-0">
                                <div class="relative">
                                    <svg class="w-5 h-5 text-slate-400 absolute left-3 top-1/2 -translate-y-1/2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
                                    </svg>
                                    <input 
                                        id="fp-product-search-input"
                                        type="text" 
                                        placeholder="Search by stock code or description..."
                                        value="${query}"
                                        oninput="app._onFPProductSearchInput(this.value)"
                                        class="w-full pl-10 pr-4 py-3 border border-slate-200 rounded-xl focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none text-sm"
                                    />
                                </div>
                            </div>
                            
                            <div class="flex-1 overflow-y-auto p-2">
                                ${filteredProducts.length === 0 ? `
                                    <div class="text-center py-8 text-slate-500">
                                        <svg class="w-12 h-12 mx-auto mb-3 text-slate-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                        </svg>
                                        <p class="font-medium">No products found</p>
                                        <p class="text-sm mt-1">Try a different search term</p>
                                    </div>
                                ` : filteredProducts.map(product => `
                                    <button 
                                        onclick="app._selectFPProduct('${product.stockCode.replace(/'/g, "\\'")}')"
                                        class="w-full text-left p-3 hover:bg-blue-50 rounded-xl transition-colors flex items-center gap-3 border border-transparent hover:border-blue-200"
                                    >
                                        <div class="w-10 h-10 bg-blue-100 rounded-lg flex items-center justify-center flex-shrink-0">
                                            <span class="text-blue-600 font-bold text-xs">${product.stockCode.substring(0, 3)}</span>
                                        </div>
                                        <div class="flex-1 min-w-0">
                                            <div class="font-bold text-slate-900 text-sm">${product.stockCode}</div>
                                            <div class="text-slate-500 text-xs truncate">${product.description}</div>
                                        </div>
                                        <svg class="w-5 h-5 text-slate-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                                        </svg>
                                    </button>
                                `).join('')}
                            </div>
                            
                            <div class="p-4 border-t border-slate-100 flex-shrink-0">
                                <p class="text-xs text-slate-400 text-center mb-3">
                                    ${filteredProducts.length} product${filteredProducts.length !== 1 ? 's' : ''} found
                                </p>
                                <button onclick="app._scanStockCodeForFP()" class="w-full bg-slate-100 hover:bg-slate-200 text-slate-700 py-3 rounded-xl font-medium text-sm transition-colors flex items-center justify-center gap-2">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v1m6 11h2m-6 0h-2v4m0-11v3m0 0h.01M12 12h4.01M16 20h4M4 12h4m12 0h.01M5 8h2a1 1 0 001-1V5a1 1 0 00-1-1H5a1 1 0 00-1 1v2a1 1 0 001 1zm12 0h2a1 1 0 001-1V5a1 1 0 00-1-1h-2a1 1 0 00-1 1v2a1 1 0 001 1zM5 20h2a1 1 0 001-1v-2a1 1 0 00-1-1H5a1 1 0 00-1 1v2a1 1 0 001 1z"/>
                                    </svg>
                                    Scan Stock Code Instead
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            }

            _onFPProductSearchInput(query) {
                const parsed = this._unknownFPParsed;
                const overlay = document.getElementById('fp-product-search-overlay');
                if (overlay && parsed) {
                    overlay.innerHTML = this._renderFPProductSearchHTML(query, parsed);
                    const input = document.getElementById('fp-product-search-input');
                    if (input) {
                        input.focus();
                        input.setSelectionRange(query.length, query.length);
                    }
                }
            }

            _cancelFPProductSearch() {
                const overlay = document.getElementById('fp-product-search-overlay');
                if (overlay) overlay.remove();
                this._unknownFPParsed = null;
                this._unknownFPScanKey = null;
                this._fpSearchProducts = [];
            }

            _scanStockCodeForFP() {
                // Close search overlay
                const overlay = document.getElementById('fp-product-search-overlay');
                if (overlay) overlay.remove();

                const parsed = this._unknownFPParsed;
                if (!parsed) return;

                // Set up for stock code scan
                this._waitingForFPStockCode = true;

                this.showModal({
                    title: ' Scan Stock Code',
                    message: `Batch: ${parsed.batchNumber}\nPallet: ${parsed.palletNumber}\n\nPlease scan the STOCK CODE barcode on this product.`,
                    type: 'alert',
                    confirmText: 'Start Scanning',
                    onConfirm: () => {
                        this.startScanning();
                    }
                });
            }

            async _processFPStockCodeScan(stockCode, parsed) {
                // Look for product in database by stock code
                let productInfo = null;
                for (const [batch, info] of Object.entries(productDatabase)) {
                    if (info.stockCode === stockCode) {
                        productInfo = info;
                        break;
                    }
                }

                const scanKey = this._unknownFPScanKey;

                if (productInfo) {
                    // Found the product - update parsed data
                    parsed.stockCode = stockCode;
                    parsed.description = productInfo.description;
                    parsed.isUnknownProduct = false;

                    // Add batch to product database
                    productDatabase[parsed.batchNumber] = {
                        stockCode: stockCode,
                        description: productInfo.description
                    };
                    saveProductDatabase();

                    // Save to Supabase products table
                    if (supabase) {
                        try {
                            await supabase
                                .from('products')
                                .upsert({
                                    batch_number: parsed.batchNumber,
                                    stock_code: stockCode,
                                    description: productInfo.description
                                }, { onConflict: 'batch_number' });
                        } catch (err) {
                            console.error('Error adding to Supabase:', err);
                        }
                    }

                    // Clear temp storage
                    this._unknownFPParsed = null;
                    this._unknownFPScanKey = null;

                    // Check for duplicate before proceeding to case entry
                    const duplicate = await this.checkDuplicate(
                        parsed.batchNumber,
                        parsed.palletNumber,
                        parsed.stockCode,
                        parsed.expiryDate
                    );

                    if (duplicate) {
                        const timestamp = duplicate.scanned_at || duplicate.created_at || duplicate.date + ' ' + duplicate.time;
                        const scannedByName = duplicate.scanned_by || duplicate.scannedBy || 'Unknown';
                        const existingCases = duplicate.actual_cases || duplicate.actualCases || 0;

                        if (navigator.vibrate) navigator.vibrate([200, 100, 200]);

                        // Store duplicate info for update flow
                        parsed.isDuplicatePallet = true;
                        parsed.existingScanId = duplicate.id;
                        parsed.existingCases = existingCases;

                        // Show modal to notify and confirm update
                        this.showModal({
                            title: 'Pallet Already Scanned',
                            message: `This pallet has already been scanned!\n\n` +
                                `Stock Code: ${parsed.stockCode}\n` +
                                `Batch: ${parsed.batchNumber}\n` +
                                `Pallet: ${parsed.palletNumber}\n` +
                                `Current Cases: ${existingCases}\n\n` +
                                `Scanned by: ${scannedByName}\n` +
                                `at ${new Date(timestamp).toLocaleString()}\n\n` +
                                `Would you like to update this pallet's count?`,
                            type: 'confirm',
                            confirmText: 'Update Count',
                            cancelText: 'Cancel',
                            onConfirm: () => {
                                // Proceed to case entry to update
                                this.pendingScanKeys.add(scanKey);
                                this.currentScan = parsed;
                                this.showingCaseEntry = true;
                                this.render();
                            }
                        });
                        return;
                    }

                    // No duplicate - continue to case entry
                    this.pendingScanKeys.add(scanKey);
                    this.currentScan = parsed;
                    this.showingCaseEntry = true;
                    this.render();
                } else {
                    // Stock code not in database - ask for description
                    this.showModal({
                        title: ' New Product',
                        message: `Stock Code: ${stockCode}\nBatch: ${parsed.batchNumber}\n\nPlease enter the product description:`,
                        type: 'confirm',
                        fields: [
                            { name: 'description', label: 'Product Description', type: 'text', placeholder: 'e.g., Milk Chocolate 200g' }
                        ],
                        confirmText: 'Save',
                        onConfirm: async (values) => {
                            const description = values.description?.trim();
                            if (!description) {
                                alert('Please enter a description');
                                return;
                            }

                            // Update parsed data
                            parsed.stockCode = stockCode;
                            parsed.description = description;
                            parsed.isUnknownProduct = false;

                            // Add to product database
                            productDatabase[parsed.batchNumber] = {
                                stockCode: stockCode,
                                description: description
                            };
                            saveProductDatabase();

                            // Save to Supabase products table
                            if (supabase) {
                                try {
                                    await supabase
                                        .from('products')
                                        .upsert({
                                            batch_number: parsed.batchNumber,
                                            stock_code: stockCode,
                                            description: description
                                        }, { onConflict: 'batch_number' });
                                } catch (err) {
                                    console.error('Error adding to Supabase:', err);
                                }
                            }

                            // Clear temp storage
                            this._unknownFPParsed = null;
                            this._unknownFPScanKey = null;

                            // Check for duplicate before proceeding to case entry
                            const duplicate = await this.checkDuplicate(
                                parsed.batchNumber,
                                parsed.palletNumber,
                                parsed.stockCode,
                                parsed.expiryDate
                            );

                            if (duplicate) {
                                const timestamp = duplicate.scanned_at || duplicate.created_at || duplicate.date + ' ' + duplicate.time;
                                const scannedByName = duplicate.scanned_by || duplicate.scannedBy || 'Unknown';
                                const existingCases = duplicate.actual_cases || duplicate.actualCases || 0;

                                if (navigator.vibrate) navigator.vibrate([200, 100, 200]);

                                // Store duplicate info for update flow
                                parsed.isDuplicatePallet = true;
                                parsed.existingScanId = duplicate.id;
                                parsed.existingCases = existingCases;

                                // Show modal to notify and confirm update
                                this.showModal({
                                    title: 'Pallet Already Scanned',
                                    message: `This pallet has already been scanned!\n\n` +
                                        `Stock Code: ${parsed.stockCode}\n` +
                                        `Batch: ${parsed.batchNumber}\n` +
                                        `Pallet: ${parsed.palletNumber}\n` +
                                        `Current Cases: ${existingCases}\n\n` +
                                        `Scanned by: ${scannedByName}\n` +
                                        `at ${new Date(timestamp).toLocaleString()}\n\n` +
                                        `Would you like to update this pallet's count?`,
                                    type: 'confirm',
                                    confirmText: 'Update Count',
                                    cancelText: 'Cancel',
                                    onConfirm: () => {
                                        // Proceed to case entry to update
                                        this.pendingScanKeys.add(scanKey);
                                        this.currentScan = parsed;
                                        this.showingCaseEntry = true;
                                        this.render();
                                    }
                                });
                                return;
                            }

                            // No duplicate - continue to case entry
                            this.pendingScanKeys.add(scanKey);
                            this.currentScan = parsed;
                            this.showingCaseEntry = true;
                            this.render();
                        }
                    });
                }
            }

            async _selectFPProduct(stockCode) {
                const parsed = this._unknownFPParsed;
                const scanKey = this._unknownFPScanKey;

                // Close search overlay
                const overlay = document.getElementById('fp-product-search-overlay');
                if (overlay) overlay.remove();
                this._fpSearchProducts = [];

                if (!parsed || !scanKey) {
                    alert('Scan data lost. Please scan again.');
                    this._unknownFPParsed = null;
                    this._unknownFPScanKey = null;
                    return;
                }

                // Find product info
                let productInfo = null;
                for (const [batch, info] of Object.entries(productDatabase)) {
                    if (info.stockCode === stockCode) {
                        productInfo = info;
                        break;
                    }
                }

                if (!productInfo) {
                    alert('Product not found');
                    return;
                }

                // Update parsed data with product info
                parsed.stockCode = stockCode;
                parsed.description = productInfo.description;
                parsed.isUnknownProduct = false;

                // Add batch to product database
                productDatabase[parsed.batchNumber] = {
                    stockCode: stockCode,
                    description: productInfo.description
                };
                saveProductDatabase();

                // Save to Supabase products table
                if (supabase) {
                    try {
                        await supabase
                            .from('products')
                            .upsert({
                                batch_number: parsed.batchNumber,
                                stock_code: stockCode,
                                description: productInfo.description
                            }, { onConflict: 'batch_number' });
                    } catch (err) {
                        console.error('Error adding to Supabase:', err);
                    }
                }

                // Clear temp storage
                this._unknownFPParsed = null;
                this._unknownFPScanKey = null;

                // Check for duplicate before proceeding to case entry
                const duplicate = await this.checkDuplicate(
                    parsed.batchNumber,
                    parsed.palletNumber,
                    parsed.stockCode,
                    parsed.expiryDate
                );

                if (duplicate) {
                    const timestamp = duplicate.scanned_at || duplicate.created_at || duplicate.date + ' ' + duplicate.time;
                    const scannedByName = duplicate.scanned_by || duplicate.scannedBy || 'Unknown';
                    const existingCases = duplicate.actual_cases || duplicate.actualCases || 0;

                    if (navigator.vibrate) navigator.vibrate([200, 100, 200]);

                    // Store duplicate info for update flow
                    parsed.isDuplicatePallet = true;
                    parsed.existingScanId = duplicate.id;
                    parsed.existingCases = existingCases;

                    // Show modal to notify and confirm update
                    this.showModal({
                        title: 'Pallet Already Scanned',
                        message: `This pallet has already been scanned!\n\n` +
                            `Stock Code: ${parsed.stockCode}\n` +
                            `Batch: ${parsed.batchNumber}\n` +
                            `Pallet: ${parsed.palletNumber}\n` +
                            `Current Cases: ${existingCases}\n\n` +
                            `Scanned by: ${scannedByName}\n` +
                            `at ${new Date(timestamp).toLocaleString()}\n\n` +
                            `Would you like to update this pallet's count?`,
                        type: 'confirm',
                        confirmText: 'Update Count',
                        cancelText: 'Cancel',
                        onConfirm: () => {
                            // Proceed to case entry to update
                            this.pendingScanKeys.add(scanKey);
                            this.currentScan = parsed;
                            this.showingCaseEntry = true;
                            this.render();
                        }
                    });
                    return;
                }

                // No duplicate - continue to case entry with the updated parsed data
                this.pendingScanKeys.add(scanKey);
                this.currentScan = parsed;
                this.showingCaseEntry = true;
                this.render();
            }

            async selectProductForScan(stockCode) {
                const scanId = this._searchingScanId;
                const scan = this._searchingScan;

                // Close search overlay
                this.closeProductSearch();

                if (!scan || !scanId) {
                    alert('Scan reference lost. Please try again.');
                    return;
                }

                // Find product info
                let productInfo = null;
                for (const [batch, info] of Object.entries(productDatabase)) {
                    if (info.stockCode === stockCode) {
                        productInfo = info;
                        break;
                    }
                }

                if (!productInfo) {
                    alert('Product not found');
                    return;
                }

                // Add batch to product database
                productDatabase[scan.batchNumber] = {
                    stockCode: stockCode,
                    description: productInfo.description
                };
                saveProductDatabase();

                // Save to Supabase
                if (supabase) {
                    try {
                        await supabase
                            .from('products')
                            .upsert({
                                batch_number: scan.batchNumber,
                                stock_code: stockCode,
                                description: productInfo.description
                            }, { onConflict: 'batch_number' });
                    } catch (err) {
                        console.error('Error adding to Supabase:', err);
                    }
                }

                // Update the scan in local array
                const scanIndex = this.scans.findIndex(s => String(s.id) === String(scanId));
                if (scanIndex >= 0) {
                    this.scans[scanIndex].stockCode = stockCode;
                    this.scans[scanIndex].description = productInfo.description;
                }

                // Update scan in Supabase
                if (supabase && scanId) {
                    try {
                        await supabase
                            .from('stock_scans')
                            .update({
                                stock_code: stockCode,
                                description: productInfo.description
                            })
                            .eq('id', scanId);
                    } catch (err) {
                        console.error('Error updating scan in Supabase:', err);
                    }
                }

                this.showModal({
                    title: ' Product Linked',
                    message: `Batch ${scan.batchNumber} linked to:\n\n${stockCode}\n${productInfo.description}`,
                    type: 'alert',
                    confirmText: 'OK'
                });

                this.render();
            }

            // Scan stock code and add product to database
            async scanStockCodeForProduct(scanId, isRM) {
                // Close the popup
                const popup = document.getElementById('add-to-db-popup');
                if (popup) popup.remove();

                // Find the scan
                const scan = this.scans.find(s => s.id === scanId);
                if (!scan) {
                    alert('Scan not found');
                    return;
                }

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: 'environment' }
                    });

                    // Create scanner overlay
                    const overlay = document.createElement('div');
                    overlay.id = 'stock-code-scanner';
                    overlay.innerHTML = `
                        <div class="fixed inset-0 bg-black z-[10000] flex flex-col">
                            <div class="bg-black/80 p-4 flex items-center justify-between">
                                <span class="text-white font-bold">Scan Stock Code</span>
                                <button onclick="app.cancelStockCodeScan()" class="text-white p-2 hover:bg-white/10 rounded-full">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                            <div class="flex-1 relative">
                                <video id="stock-code-video" class="w-full h-full object-cover" autoplay playsinline></video>
                                <div class="absolute inset-0 flex items-center justify-center pointer-events-none">
                                    <div class="w-64 h-32 border-2 border-white/50 rounded-lg relative">
                                        <div class="absolute top-0 left-0 w-8 h-8 border-t-4 border-l-4 border-blue-400 rounded-tl-lg"></div>
                                        <div class="absolute top-0 right-0 w-8 h-8 border-t-4 border-r-4 border-blue-400 rounded-tr-lg"></div>
                                        <div class="absolute bottom-0 left-0 w-8 h-8 border-b-4 border-l-4 border-blue-400 rounded-bl-lg"></div>
                                        <div class="absolute bottom-0 right-0 w-8 h-8 border-b-4 border-r-4 border-blue-400 rounded-br-lg"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="bg-black/80 p-4 text-center text-white text-sm">
                                Point camera at the stock code barcode
                            </div>
                        </div>
                    `;
                    document.body.appendChild(overlay);

                    const video = document.getElementById('stock-code-video');
                    video.srcObject = stream;

                    this._stockCodeScannerStream = stream;
                    this._stockCodeScanData = { scanId, isRM, scan };

                    // Use BarcodeDetector if available
                    if ('BarcodeDetector' in window) {
                        const detector = new BarcodeDetector({ formats: ['code_128', 'code_39', 'ean_13', 'ean_8', 'qr_code'] });

                        const scanFrame = async () => {
                            if (!this._stockCodeScannerStream) return;

                            try {
                                const barcodes = await detector.detect(video);
                                if (barcodes.length > 0) {
                                    const stockCode = barcodes[0].rawValue;
                                    this.finishStockCodeScan(stockCode);
                                    return;
                                }
                            } catch (err) {
                                // Ignore detection errors
                            }

                            if (this._stockCodeScannerStream) {
                                requestAnimationFrame(scanFrame);
                            }
                        };

                        video.onloadedmetadata = () => {
                            video.play();
                            requestAnimationFrame(scanFrame);
                        };
                    } else {
                        // Fallback: prompt for manual entry
                        this.cancelStockCodeScan();
                        const stockCode = prompt('BarcodeDetector not supported. Please enter the stock code manually:');
                        if (stockCode) {
                            this.processStockCodeScan(stockCode, scan, isRM);
                        }
                    }
                } catch (err) {
                    console.error('Camera access failed:', err);
                    alert('Could not access camera. Please check permissions.');
                }
            }

            finishStockCodeScan(stockCode) {
                // Stop scanner
                if (this._stockCodeScannerStream) {
                    this._stockCodeScannerStream.getTracks().forEach(track => track.stop());
                    this._stockCodeScannerStream = null;
                }

                // Remove overlay
                const overlay = document.getElementById('stock-code-scanner');
                if (overlay) overlay.remove();

                // Process the scanned stock code
                const { scan, isRM } = this._stockCodeScanData || {};
                if (scan && stockCode) {
                    this.processStockCodeScan(stockCode, scan, isRM);
                }

                this._stockCodeScanData = null;
            }

            cancelStockCodeScan() {
                // Stop scanner
                if (this._stockCodeScannerStream) {
                    this._stockCodeScannerStream.getTracks().forEach(track => track.stop());
                    this._stockCodeScannerStream = null;
                }

                // Remove overlay
                const overlay = document.getElementById('stock-code-scanner');
                if (overlay) overlay.remove();

                this._stockCodeScanData = null;
            }

            // Scan stock code for unknown RM product - goes straight into camera
            async scanUnknownStockCode() {
                // Close any popup if exists
                const popup = document.getElementById('unknown-stock-popup');
                if (popup) popup.remove();

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: 'environment' }
                    });

                    // Create scanner overlay with message about unknown product
                    const overlay = document.createElement('div');
                    overlay.id = 'unknown-stock-scanner';
                    overlay.innerHTML = `
                        <div class="fixed inset-0 bg-black z-[10000] flex flex-col">
                            <div class="bg-orange-500 p-4 flex items-center justify-between">
                                <div>
                                    <span class="text-white font-bold text-lg"> Unknown Product</span>
                                    <p class="text-orange-100 text-sm">Scan the STOCK CODE barcode</p>
                                </div>
                                <button onclick="app.cancelUnknownStockScan()" class="text-white p-2 hover:bg-white/20 rounded-full">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                            <div class="flex-1 relative">
                                <video id="unknown-stock-video" class="w-full h-full object-cover" autoplay playsinline></video>
                                <div class="absolute inset-0 flex items-center justify-center pointer-events-none">
                                    <div class="w-72 h-36 border-2 border-orange-400/70 rounded-lg relative">
                                        <div class="absolute top-0 left-0 w-10 h-10 border-t-4 border-l-4 border-orange-400 rounded-tl-lg"></div>
                                        <div class="absolute top-0 right-0 w-10 h-10 border-t-4 border-r-4 border-orange-400 rounded-tr-lg"></div>
                                        <div class="absolute bottom-0 left-0 w-10 h-10 border-b-4 border-l-4 border-orange-400 rounded-bl-lg"></div>
                                        <div class="absolute bottom-0 right-0 w-10 h-10 border-b-4 border-r-4 border-orange-400 rounded-br-lg"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="bg-orange-500 p-4 text-center">
                                <p class="text-white font-medium">Point camera at the stock code barcode</p>
                                <p class="text-orange-100 text-sm mt-1">This will confirm the product identity</p>
                            </div>
                        </div>
                    `;
                    document.body.appendChild(overlay);

                    const video = document.getElementById('unknown-stock-video');
                    video.srcObject = stream;

                    this._unknownStockScannerStream = stream;

                    // Store the original scanned code to ignore it
                    const originalCode = this._unknownStockParsed?.raw || '';

                    // Use BarcodeDetector if available
                    if ('BarcodeDetector' in window) {
                        const detector = new BarcodeDetector({ formats: ['code_128', 'code_39', 'ean_13', 'ean_8', 'qr_code'] });

                        const scanFrame = async () => {
                            if (!this._unknownStockScannerStream) return;

                            try {
                                const barcodes = await detector.detect(video);
                                if (barcodes.length > 0) {
                                    const stockCode = barcodes[0].rawValue;
                                    // Only accept if it's DIFFERENT from the original scan
                                    if (stockCode !== originalCode && !originalCode.includes(stockCode) && !stockCode.includes(originalCode)) {
                                        this.finishUnknownStockScan(stockCode);
                                        return;
                                    }
                                }
                            } catch (err) {
                                // Ignore detection errors
                            }

                            if (this._unknownStockScannerStream) {
                                requestAnimationFrame(scanFrame);
                            }
                        };

                        video.onloadedmetadata = () => {
                            video.play();
                            requestAnimationFrame(scanFrame);
                        };
                    } else {
                        // Fallback: prompt for manual entry
                        this.cancelUnknownStockScan();
                        const stockCode = prompt('BarcodeDetector not supported. Please enter the stock code manually:');
                        if (stockCode) {
                            this.finishUnknownStockScan(stockCode);
                        }
                    }
                } catch (err) {
                    console.error('Camera access failed:', err);
                    alert('Could not access camera. Please check permissions.');
                    this._unknownStockParsed = null;
                    this._unknownStockScanKey = null;
                }
            }

            finishUnknownStockScan(stockCode) {
                // Stop scanner
                if (this._unknownStockScannerStream) {
                    this._unknownStockScannerStream.getTracks().forEach(track => track.stop());
                    this._unknownStockScannerStream = null;
                }

                // Remove overlay
                const overlay = document.getElementById('unknown-stock-scanner');
                if (overlay) overlay.remove();

                // Process the scanned stock code
                const parsed = this._unknownStockParsed;
                const scanKey = this._unknownStockScanKey;

                if (parsed && stockCode) {
                    parsed.stockCode = stockCode.trim();
                    parsed.needsStockCodeScan = false;

                    // Parse the original string to extract batch, PO, and expiry
                    // Format example: "STOCKCODE-BATCH1234-####DD/MM/YY" or "BATCH####DD/MM/YY"
                    const rawString = parsed.raw || '';

                    // Extract date from end (DD/MM/YY pattern)
                    const dateMatch = rawString.match(/(\d{2}\/\d{2}\/\d{2})$/);
                    let extractedDate = dateMatch ? dateMatch[1] : null;

                    // Extract PO number (4 digits before date)
                    let poNumber = null;
                    let remainingForBatch = rawString;
                    if (extractedDate) {
                        const beforeDate = rawString.slice(0, -8); // Remove DD/MM/YY
                        const poMatch = beforeDate.match(/(\d{4})$/);
                        if (poMatch) {
                            poNumber = poMatch[1];
                            remainingForBatch = beforeDate.slice(0, -4); // Remove PO
                        } else {
                            remainingForBatch = beforeDate;
                        }
                    }

                    // The batch is what remains after removing stock code prefix
                    let suggestedBatch = remainingForBatch;
                    if (remainingForBatch.toUpperCase().startsWith(stockCode.toUpperCase())) {
                        suggestedBatch = remainingForBatch.substring(stockCode.length);
                    }
                    suggestedBatch = suggestedBatch.replace(/^[\-_\s]+/, '').replace(/[\-_\s]+$/, '').trim();

                    // Store extracted data
                    parsed.extractedExpiry = extractedDate;
                    parsed.poNumber = poNumber;
                    parsed.suggestedBatch = suggestedBatch;

                    // Start the confirmation flow: Batch  Expiry  Description/Type
                    this._confirmBatchNumber(parsed, scanKey, stockCode);
                }
            }

            _confirmBatchNumber(parsed, scanKey, stockCode) {
                const suggestedBatch = parsed.suggestedBatch || '';
                const poInfo = parsed.poNumber ? `\nPO Number: ${parsed.poNumber}` : '';

                this.showModal({
                    title: ' Confirm Batch Number',
                    message: `Stock Code: ${stockCode}${poInfo}\n\nOriginal scan: ${parsed.raw}\n\nPlease confirm or edit the batch number:`,
                    type: 'input',
                    confirmText: 'Next',
                    cancelText: 'Cancel',
                    onConfirm: (formData) => {
                        const confirmedBatch = formData.value?.trim() || suggestedBatch;
                        if (!confirmedBatch) {
                            alert('Batch number is required');
                            return;
                        }
                        parsed.batchNumber = confirmedBatch;

                        // Next step: Confirm expiry
                        this._confirmExpiryDate(parsed, scanKey, stockCode);
                    },
                    onCancel: () => {
                        this._unknownStockParsed = null;
                        this._unknownStockScanKey = null;
                    }
                });

                // Pre-fill with suggested batch
                setTimeout(() => {
                    const input = document.getElementById('modal-input');
                    if (input) input.value = suggestedBatch;
                }, 100);
            }

            _confirmExpiryDate(parsed, scanKey, stockCode) {
                const suggestedExpiry = parsed.extractedExpiry || '';

                this.showModal({
                    title: ' Confirm Expiry Date',
                    message: `Stock Code: ${stockCode}\nBatch: ${parsed.batchNumber}\n\nPlease confirm or edit the expiry date (DD/MM/YY):`,
                    type: 'input',
                    confirmText: 'Next',
                    cancelText: 'No Expiry',
                    onConfirm: (formData) => {
                        const confirmedExpiry = formData.value?.trim() || suggestedExpiry;
                        // Convert DD/MM/YY to YYYY-MM-DD format
                        parsed.expiryDate = confirmedExpiry ? convertDMYtoYMD(confirmedExpiry) : null;

                        // Next step: Description and Type
                        this._confirmDescriptionAndType(parsed, scanKey, stockCode);
                    },
                    onCancel: () => {
                        parsed.expiryDate = null;
                        // Continue to description
                        this._confirmDescriptionAndType(parsed, scanKey, stockCode);
                    }
                });

                // Pre-fill with suggested expiry
                setTimeout(() => {
                    const input = document.getElementById('modal-input');
                    if (input) input.value = suggestedExpiry;
                }, 100);
            }

            _confirmDescriptionAndType(parsed, scanKey, stockCode) {
                // Check if this is a known product with BOTH description AND product type
                const knownRM = rawMaterialsDatabase[parsed.stockCode] || rawMaterialsDatabase[parsed.stockCode.toUpperCase()];
                const knownType = productTypeDatabase[parsed.stockCode.toUpperCase()];

                // Only skip the form if we have BOTH a known type AND description
                if (knownType && knownType.productType && knownRM?.description) {
                    // Fully known item - get values from database
                    parsed.description = knownRM.description || knownType.description || stockCode;
                    parsed.unitType = knownType.productType === 'Ingredient' ? 'kg' : 'units';

                    // Skip to quantity entry
                    this._finishNewItemFlow(parsed, scanKey);
                    return;
                }

                // Get any existing values to pre-fill the form
                const existingDescription = knownRM?.description || knownType?.description || '';
                const existingType = knownType?.productType || 'Ingredient';

                // Unknown or incomplete item - ask for description and type
                this.showModal({
                    title: ' Product Details',
                    message: `Stock Code: ${stockCode}\nBatch: ${parsed.batchNumber}${parsed.expiryDate ? '\nExpiry: ' + parsed.expiryDate : ''}\n\nPlease enter product details:`,
                    type: 'form',
                    fields: [
                        { name: 'description', label: 'Description', placeholder: 'Product Name', value: existingDescription, required: true },
                        {
                            name: 'productType',
                            label: 'Product Type',
                            type: 'choice',
                            value: existingType,
                            options: [
                                { label: 'Ingredient', value: 'Ingredient', sublabel: 'Measured in KG' },
                                { label: 'Non-Ingredient', value: 'Non-Ingredient', sublabel: 'Measured in Units' }
                            ]
                        }
                    ],
                    confirmText: 'Save & Continue',
                    onConfirm: async (data) => {
                        const description = data.description;
                        const type = data.productType;
                        const isIngredient = type === 'Ingredient';

                        if (!description) {
                            alert('Description is required');
                            return;
                        }

                        // 1. Save Product Type to Supabase
                        await addProductTypeToSupabase(parsed.stockCode, type, description);

                        // 2. Save Raw Material info locally AND to Supabase
                        if (!rawMaterialsDatabase[parsed.stockCode]) {
                            rawMaterialsDatabase[parsed.stockCode] = { description, batches: {} };
                        }
                        rawMaterialsDatabase[parsed.stockCode].description = description;
                        if (parsed.batchNumber) {
                            if (!rawMaterialsDatabase[parsed.stockCode].batches) {
                                rawMaterialsDatabase[parsed.stockCode].batches = {};
                            }
                            rawMaterialsDatabase[parsed.stockCode].batches[parsed.batchNumber] = {
                                expiryDates: parsed.expiryDate ? [parsed.expiryDate] : []
                            };
                        }
                        saveRawMaterialsDatabase();

                        // 3. Save to Supabase raw_materials table
                        await addRawMaterialToSupabase(parsed.stockCode, description, parsed.batchNumber, parsed.expiryDate);

                        // 4. Update parsed object
                        parsed.description = description;
                        parsed.unitType = isIngredient ? 'kg' : 'units';

                        // 5. Continue to quantity entry
                        this._finishNewItemFlow(parsed, scanKey);
                    }
                });
            }

            _finishNewItemFlow(parsed, scanKey) {
                // Clear temp storage
                this._unknownStockParsed = null;
                this._unknownStockScanKey = null;

                // RM items allow duplicates (same item can be in different locations)
                // Proceed directly to case entry
                this.pendingScanKeys.add(scanKey);
                this.currentScan = parsed;
                this.showingCaseEntry = true;
                this.render();
            }

            _processBatchAndContinue(parsed, scanKey, stockCode) {
                // Re-extract batch from remaining string
                if (parsed.raw.toUpperCase().startsWith(stockCode.toUpperCase())) {
                    const remaining = parsed.raw.substring(stockCode.length);
                    // Remove expiry from end if present
                    let batchPart = remaining;
                    if (parsed.extractedExpiry) {
                        batchPart = batchPart.replace(parsed.extractedExpiry, '').trim();
                    }
                    batchPart = batchPart.replace(/^[\-_\s]+/, '').trim();
                    if (batchPart) {
                        parsed.batchNumber = batchPart;
                        parsed.needsBatchConfirmation = true;
                    }
                }

                // Continue to batch confirmation
                this._continueRMScan(parsed, scanKey);
            }

            cancelUnknownStockScan() {
                // Stop scanner
                if (this._unknownStockScannerStream) {
                    this._unknownStockScannerStream.getTracks().forEach(track => track.stop());
                    this._unknownStockScannerStream = null;
                }

                // Remove overlay
                const overlay = document.getElementById('unknown-stock-scanner');
                if (overlay) overlay.remove();

                // Remove popup if exists
                const popup = document.getElementById('unknown-stock-popup');
                if (popup) popup.remove();

                this._unknownStockParsed = null;
                this._unknownStockScanKey = null;
            }

            async processStockCodeScan(stockCode, scan, isRM) {
                // Look up the stock code in the database to get description and type
                let description = '';
                let productType = 'Non-Ingredient';
                let hasKnownType = false;

                // Check product types database first
                const knownType = productTypeDatabase[stockCode.toUpperCase()];
                if (knownType) {
                    productType = knownType.productType || 'Non-Ingredient';
                    description = knownType.description || '';
                    hasKnownType = true;
                }

                if (isRM) {
                    // Check RM database
                    if (rawMaterialsDatabase[stockCode]) {
                        description = description || rawMaterialsDatabase[stockCode].description || '';
                    }
                } else {
                    // Check FP database - look for any product with this stock code
                    for (const [batch, info] of Object.entries(productDatabase)) {
                        if (info.stockCode === stockCode) {
                            description = description || info.description || '';
                            break;
                        }
                    }
                }

                // If no description or type found, prompt for both
                if (!description || !hasKnownType) {
                    // Use modal form to get description and product type
                    this.showModal({
                        title: ' Product Details',
                        message: `Adding ${isRM ? 'Raw Material' : 'Product'}: ${stockCode}`,
                        type: 'form',
                        fields: [
                            { name: 'description', label: 'Description', placeholder: 'Product Name', value: description || '', required: true },
                            {
                                name: 'productType',
                                label: 'Product Type',
                                type: 'choice',
                                value: productType,
                                options: [
                                    { label: 'Ingredient', value: 'Ingredient', sublabel: 'Measured in KG' },
                                    { label: 'Non-Ingredient', value: 'Non-Ingredient', sublabel: 'Measured in Units' }
                                ]
                            }
                        ],
                        confirmText: 'Save to Database',
                        onConfirm: async (data) => {
                            const finalDescription = data.description;
                            const finalType = data.productType;

                            if (!finalDescription) {
                                alert('Description is required');
                                return;
                            }

                            // Save with description and type
                            await this._saveProductToDatabase(stockCode, finalDescription, finalType, scan, isRM);
                        }
                    });
                    return;
                }

                // Known item - save with existing description and type
                await this._saveProductToDatabase(stockCode, description, productType, scan, isRM);
            }

            async _saveProductToDatabase(stockCode, description, productType, scan, isRM) {
                const isIngredient = productType === 'Ingredient';
                const unitType = isIngredient ? 'kg' : 'units';

                // 1. Save product type to database
                await addProductTypeToSupabase(stockCode, productType, description);

                if (isRM) {
                    // Add to RM database
                    if (!rawMaterialsDatabase[stockCode]) {
                        rawMaterialsDatabase[stockCode] = { description, batches: {} };
                    }
                    rawMaterialsDatabase[stockCode].description = description;
                    if (scan.batchNumber) {
                        if (!rawMaterialsDatabase[stockCode].batches) {
                            rawMaterialsDatabase[stockCode].batches = {};
                        }
                        rawMaterialsDatabase[stockCode].batches[scan.batchNumber] = {
                            expiryDates: scan.expiryDate ? [scan.expiryDate] : []
                        };
                    }
                    saveRawMaterialsDatabase();

                    // Add to Supabase raw materials
                    await addRawMaterialToSupabase(stockCode, description, scan.batchNumber, scan.expiryDate);

                    // Update the scan
                    const scanIndex = this.scans.findIndex(s => s.id === scan.id);
                    if (scanIndex >= 0) {
                        this.scans[scanIndex].stockCode = stockCode;
                        this.scans[scanIndex].description = description;
                        this.scans[scanIndex].unitType = unitType;
                    }

                    // Update scan in Supabase if it exists
                    if (supabase && scan.id) {
                        try {
                            await supabase
                                .from('stock_scans')
                                .update({
                                    stock_code: stockCode,
                                    description: description,
                                    unit_type: unitType
                                })
                                .eq('id', scan.id);
                        } catch (err) {
                            console.error('Error updating scan in Supabase:', err);
                        }
                    }

                    this.showModal({
                        title: 'Success',
                        message: `"${stockCode}" added to database!\nType: ${productType} (${unitType})`,
                        type: 'alert',
                        confirmText: 'OK'
                    });
                } else {
                    // Add to FP database
                    productDatabase[scan.batchNumber] = { stockCode, description };
                    saveProductDatabase();

                    // Add to Supabase
                    if (supabase) {
                        try {
                            await supabase
                                .from('products')
                                .upsert({
                                    batch_number: scan.batchNumber,
                                    stock_code: stockCode,
                                    description: description
                                }, { onConflict: 'batch_number' });
                        } catch (err) {
                            console.error('Error adding to Supabase:', err);
                        }
                    }

                    // Update the scan
                    const scanIndex = this.scans.findIndex(s => s.id === scan.id);
                    if (scanIndex >= 0) {
                        this.scans[scanIndex].stockCode = stockCode;
                        this.scans[scanIndex].description = description;
                    }

                    // Update scan in Supabase if it exists
                    if (supabase && scan.id) {
                        try {
                            await supabase
                                .from('stock_scans')
                                .update({
                                    stock_code: stockCode,
                                    description: description
                                })
                                .eq('id', scan.id);
                        } catch (err) {
                            console.error('Error updating scan in Supabase:', err);
                        }
                    }

                    this.showModal({
                        title: 'Success',
                        message: `Product "${stockCode}" added to database!`,
                        type: 'alert',
                        confirmText: 'OK'
                    });
                }

                this.render();
            }

            addProductType() {
                this.showModal({
                    title: 'Add Product Type',
                    type: 'form',
                    fields: [
                        { name: 'stockCode', label: 'Stock Code', placeholder: 'e.g. RM001, FP123', required: true },
                        { name: 'type', label: 'Type', placeholder: 'Ingredient or Non-Ingredient', required: true },
                        { name: 'description', label: 'Description', placeholder: 'Product description', required: true }
                    ],
                    confirmText: 'Add Product Type',
                    onConfirm: async (data) => {
                        const { stockCode, type, description } = data;

                        if (!stockCode || !type || !description) {
                            alert('All fields are required');
                            return;
                        }

                        const result = await addProductTypeToSupabase(stockCode, type, description);

                        if (result.success) {
                            this.showModal({
                                title: 'Success',
                                message: 'Product type added successfully!',
                                type: 'alert'
                            });
                        } else if (result.exists) {
                            this.showModal({
                                title: 'Already Exists',
                                message: `Product with stock code "${stockCode.toUpperCase()}" already exists in the database.`,
                                type: 'alert'
                            });
                        } else {
                            alert('Failed to add product type: ' + result.error);
                        }
                    }
                });
            }

            async importProductTypes() {
                // Create file input dynamically
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = '.xlsx,.xls,.csv';
                fileInput.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    try {
                        const data = await file.arrayBuffer();
                        const workbook = XLSX.read(data);
                        const sheet = workbook.Sheets[workbook.SheetNames[0]];
                        const json = XLSX.utils.sheet_to_json(sheet);

                        if (json.length === 0) {
                            alert('No data found in the file');
                            return;
                        }

                        // Map columns - expect: type, stock_code, description
                        // Also support: Type, Stock Code, Description (case insensitive)
                        const products = json.map(row => {
                            // Find the columns (case insensitive)
                            const keys = Object.keys(row);
                            const findKey = (names) => keys.find(k => names.includes(k.toLowerCase().replace(/[_\s]/g, '')));

                            const typeKey = findKey(['type', 'producttype']);
                            const stockCodeKey = findKey(['stockcode', 'stock_code', 'code', 'sku']);
                            const descKey = findKey(['description', 'desc', 'name', 'productname']);

                            return {
                                type: row[typeKey] || 'Non-Ingredient',
                                stock_code: row[stockCodeKey] || '',
                                description: row[descKey] || ''
                            };
                        }).filter(p => p.stock_code); // Only include rows with stock code

                        if (products.length === 0) {
                            alert('No valid products found. Make sure your file has columns: stock_code, type, description');
                            return;
                        }

                        // Show confirmation
                        this.showModal({
                            title: 'Confirm Import',
                            message: `Found ${products.length} products in the file.\n\nOnly NEW products will be added.\nExisting products will be skipped.\n\nProceed with import?`,
                            type: 'confirm',
                            confirmText: 'Import',
                            cancelText: 'Cancel',
                            onConfirm: async () => {
                                const result = await bulkAddProductTypesToSupabase(products);

                                if (result.success) {
                                    this.showModal({
                                        title: 'Import Complete',
                                        message: `Added: ${result.added} products\nSkipped (already exist): ${result.skipped} products`,
                                        type: 'alert'
                                    });
                                    this.render();
                                } else {
                                    alert('Import failed: ' + result.error);
                                }
                            }
                        });
                    } catch (err) {
                        console.error('Error reading file:', err);
                        alert('Error reading file: ' + err.message);
                    }
                };
                fileInput.click();
            }

            async refreshProductsFromCloud() {
                if (!supabase) {
                    alert('Cloud sync not available');
                    return;
                }

                const btn = event.target;
                const originalText = btn.innerHTML;
                btn.innerHTML = '<span class="animate-spin"></span> Loading...';
                btn.disabled = true;

                try {
                    // Check which view is active, or fall back to active stock take type
                    const isRM = this.showingRMProductDB || this.activeStockTake?.sessionType === 'RM';

                    if (isRM) {
                        const loaded = await loadRawMaterialsFromSupabase(true); // Force reload
                        if (loaded) {
                            alert(`Loaded ${Object.keys(rawMaterialsDatabase).length} raw materials from Supabase`);
                        } else {
                            alert('No raw materials found in Supabase or error occurred');
                        }
                    } else {
                        const loaded = await loadProductsFromSupabase(true); // Force reload
                        if (loaded) {
                            alert(`Loaded ${Object.keys(productDatabase).length} products from Supabase`);
                        } else {
                            alert('No products found in Supabase or error occurred');
                        }
                    }
                } catch (err) {
                    alert('Error loading products: ' + err.message);
                } finally {
                    btn.innerHTML = originalText;
                    btn.disabled = false;
                }
                this.render();
            }

            clearRMDatabase() {
                this.showModal({
                    title: 'Clear Raw Materials',
                    message: 'Are you sure you want to clear all raw materials? This cannot be undone.',
                    type: 'confirm',
                    confirmText: 'Clear',
                    cancelText: 'Cancel',
                    onConfirm: () => {
                        rawMaterialsDatabase = {};
                        saveRawMaterialsDatabase();
                        this.render();
                    }
                });
            }

            uploadExcel() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.xlsx,.xls,.csv';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const data = new Uint8Array(event.target.result);
                            const workbook = XLSX.read(data, { type: 'array' });
                            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                            const jsonData = XLSX.utils.sheet_to_json(firstSheet);

                            let imported = 0;
                            jsonData.forEach(row => {
                                const batch = String(row.BatchNumber || row.batchNumber || row['Batch Number'] || '').padStart(5, '0');
                                const stockCode = row.StockCode || row.stockCode || row['Stock Code'];
                                const description = row.Description || row.description;

                                if (batch && stockCode && description && /^\d{5}$/.test(batch)) {
                                    productDatabase[batch] = { stockCode, description };
                                    imported++;
                                }
                            });

                            saveProductDatabase();
                            alert(`Imported ${imported} products!`);
                            this.render();
                        } catch (err) {
                            alert('Error: ' + err.message);
                        }
                    };
                    reader.readAsArrayBuffer(file);
                };
                input.click();
            }

            uploadRMExcel() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.xlsx,.xls,.csv';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const data = new Uint8Array(event.target.result);
                            const workbook = XLSX.read(data, { type: 'array' });
                            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                            const jsonData = XLSX.utils.sheet_to_json(firstSheet);

                            let imported = 0;
                            jsonData.forEach(row => {
                                const stockCode = row.StockCode || row.stockCode || row['Stock Code'] || row.stock_code;
                                const description = row.Description || row.description || row['Stock Description'] || '';
                                const batchNumber = row.BatchNumber || row.batchNumber || row['Batch Number'] || row.batch_number || '';
                                const expiryDate = row.ExpiryDate || row.expiryDate || row['Expiry Date'] || row.expiry_date || null;

                                if (stockCode) {
                                    if (!rawMaterialsDatabase[stockCode]) {
                                        rawMaterialsDatabase[stockCode] = { description, batches: {} };
                                    }
                                    if (description) {
                                        rawMaterialsDatabase[stockCode].description = description;
                                    }
                                    if (batchNumber) {
                                        rawMaterialsDatabase[stockCode].batches[batchNumber] = {
                                            expiryDate: expiryDate || null
                                        };
                                    }
                                    imported++;
                                }
                            });

                            saveRawMaterialsDatabase();
                            alert(`Imported ${imported} raw materials!`);
                            this.render();
                        } catch (err) {
                            alert('Error: ' + err.message);
                        }
                    };
                    reader.readAsArrayBuffer(file);
                };
                input.click();
            }

            exportProductDatabase() {
                const data = Object.entries(productDatabase).map(([batch, info]) => ({
                    BatchNumber: batch,
                    StockCode: info.stockCode,
                    Description: info.description
                }));

                const ws = XLSX.utils.json_to_sheet(data);
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, "Products");
                XLSX.writeFile(wb, "product_database.xlsx");
            }

            exportRMDatabase() {
                const data = [];
                Object.entries(rawMaterialsDatabase).forEach(([stockCode, info]) => {
                    if (Object.keys(info.batches || {}).length === 0) {
                        data.push({
                            StockCode: stockCode,
                            Description: info.description,
                            BatchNumber: '',
                            ExpiryDate: ''
                        });
                    } else {
                        Object.entries(info.batches).forEach(([batch, batchInfo]) => {
                            data.push({
                                StockCode: stockCode,
                                Description: info.description,
                                BatchNumber: batch,
                                ExpiryDate: batchInfo.expiryDate || ''
                            });
                        });
                    }
                });

                const ws = XLSX.utils.json_to_sheet(data);
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, "Raw Materials");
                XLSX.writeFile(wb, "raw_materials_database.xlsx");
            }

            exportStockCount() {
                const data = this.scans.map(scan => ({
                    'Stock Take Date': this.currentTakeDate,
                    'Scanned By': scan.scannedBy || 'Unknown',
                    'Batch Number': scan.batchNumber,
                    'Pallet Number': scan.palletNumber,
                    'Stock Code': scan.stockCode,
                    'Description': scan.description,
                    'Cases on Pallet': scan.casesOnPallet,
                    'Actual Cases': scan.actualCases,
                    'Variance': scan.actualCases - scan.casesOnPallet,
                    'Site': scan.site || '',
                    'Aisle': scan.aisle || '',
                    'Rack': scan.rack || '',
                    'Location Notes': scan.location || '',
                    'Scanned At': scan.date + ' ' + scan.time,
                    'Device ID': scan.deviceId,
                    'Raw QR Code': scan.raw
                }));

                const ws = XLSX.utils.json_to_sheet(data);
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, "Stock Count");

                const filename = `stock_count_${this.currentTakeDate}.xlsx`;
                XLSX.writeFile(wb, filename);
            }

            clearDatabase() {
                this.showModal({
                    title: 'Clear Database',
                    message: 'Are you sure you want to clear the entire product database?',
                    type: 'confirm',
                    confirmText: 'Clear',
                    cancelText: 'Cancel',
                    onConfirm: () => {
                        productDatabase = {};
                        saveProductDatabase();
                        this.showModal({ title: 'Success', message: 'Database cleared', type: 'alert' });
                        this.render();
                    }
                });
            }

            showModal(config) {
                this.modalState = {
                    title: config.title || 'Alert',
                    message: config.message || '',
                    type: config.type || 'alert', // alert, confirm, input, form
                    fields: config.fields || [], // [{name, label, type, value, placeholder, required}]
                    confirmText: config.confirmText || 'OK',
                    cancelText: config.cancelText || 'Cancel',
                    onConfirm: config.onConfirm || (() => { }),
                    onCancel: config.onCancel || (() => { })
                };
                this.render();

                // Focus first input if applicable
                setTimeout(() => {
                    const firstInput = document.querySelector('#modal-content input');
                    if (firstInput) firstInput.focus();
                }, 100);
            }

            closeModal() {
                // Save callback before clearing modal state
                const onCancelCallback = this.modalState?.onCancel;
                this.modalState = null;

                // Call onCancel callback if provided
                if (onCancelCallback) {
                    onCancelCallback();
                }

                // Check if a render was deferred during sync while modal was open
                if (this._pendingRender) {
                    this._pendingRender = false;
                }
                this.render();
            }

            handleModalSubmit(e) {
                e.preventDefault();
                if (!this.modalState) return;

                const formData = {};
                if (this.modalState.type === 'input') {
                    const input = document.getElementById('modal-input');
                    formData.value = input ? input.value : '';
                } else if (this.modalState.type === 'form') {
                    this.modalState.fields.forEach(field => {
                        const input = document.getElementById(`modal-field-${field.name}`);
                        if (input) {
                            formData[field.name] = field.type === 'checkbox' ? input.checked : input.value;
                        }
                    });
                }

                // Save the callback before closing modal (in case callback shows a new modal)
                const onConfirmCallback = this.modalState.onConfirm;
                this.modalState = null; // Clear modal state first

                if (onConfirmCallback) {
                    onConfirmCallback(formData);
                }

                // Only render if no new modal was opened
                if (!this.modalState) {
                    // Clear pending render flag since we're rendering now
                    this._pendingRender = false;
                    this.render();
                }
            }

            selectModalChoice(fieldName, value) {
                // Update hidden input
                const input = document.getElementById(`modal-field-${fieldName}`);
                if (input) input.value = value;

                // Update UI
                const buttons = document.querySelectorAll(`.modal-choice-btn-${fieldName}`);
                buttons.forEach(btn => {
                    if (btn.id === `modal-choice-${fieldName}-${value}`) {
                        btn.classList.remove('border-slate-200', 'text-slate-600');
                        btn.classList.add('border-blue-600', 'bg-blue-50', 'text-blue-700');
                    } else {
                        btn.classList.add('border-slate-200', 'text-slate-600');
                        btn.classList.remove('border-blue-600', 'bg-blue-50', 'text-blue-700');
                    }
                });
            }

            renderModal() {
                const root = document.getElementById('modal-root');
                if (!this.modalState) {
                    root.innerHTML = '';
                    return;
                }

                const { title, message, type, fields, confirmText, cancelText } = this.modalState;

                let content = '';

                if (type === 'input') {
                    content = `
                        <input type="text" id="modal-input" class="w-full px-4 py-3 border-2 border-slate-200 rounded-xl focus:border-blue-500 focus:ring-4 focus:ring-blue-50/50 outline-none transition-all" placeholder="Enter value" autocomplete="off">
                    `;
                } else if (type === 'form') {
                    content = fields.map(field => `
                        <div class="mb-4">
                            <label class="block text-sm font-bold text-slate-700 mb-2">${field.label}</label>
                            ${field.type === 'choice' ? `
                                <div class="grid grid-cols-2 gap-3">
                                    ${field.options.map(opt => `
                                        <button 
                                            type="button"
                                            onclick="app.selectModalChoice('${field.name}', '${opt.value}')"
                                            id="modal-choice-${field.name}-${opt.value}"
                                            class="modal-choice-btn-${field.name} p-4 rounded-xl border-2 text-center transition-all ${field.value === opt.value ? 'border-blue-600 bg-blue-50 text-blue-700' : 'border-slate-200 hover:border-slate-300 text-slate-600'}"
                                        >
                                            <div class="font-bold text-sm">${opt.label}</div>
                                            ${opt.sublabel ? `<div class="text-xs opacity-75 mt-1">${opt.sublabel}</div>` : ''}
                                        </button>
                                    `).join('')}
                                    <input type="hidden" id="modal-field-${field.name}" value="${field.value || ''}">
                                </div>
                            ` : field.type === 'checkbox' ? `
                                <label class="flex items-center gap-3 p-3 border border-slate-200 rounded-xl bg-slate-50">
                                    <input type="checkbox" id="modal-field-${field.name}" ${field.value ? 'checked' : ''} class="w-5 h-5 text-blue-600 rounded focus:ring-blue-500">
                                    <span class="text-slate-700 font-medium">${field.placeholder || ''}</span>
                                </label>
                            ` : `
                                <input 
                                    type="${field.type || 'text'}" 
                                    id="modal-field-${field.name}" 
                                    value="${field.value || ''}" 
                                    class="w-full px-4 py-3 border-2 border-slate-200 rounded-xl focus:border-blue-500 focus:ring-4 focus:ring-blue-50/50 outline-none transition-all" 
                                    placeholder="${field.placeholder || ''}"
                                    ${field.required ? 'required' : ''}
                                >
                            `}
                        </div>
                    `).join('');
                } else if (type === 'loading') {
                    content = `
                        <div class="flex flex-col items-center justify-center py-4">
                            <div class="w-12 h-12 border-4 border-blue-200 border-t-blue-600 rounded-full animate-spin mb-4"></div>
                            <p class="text-slate-600 font-medium">${message || 'Loading...'}</p>
                        </div>
                    `;
                }

                root.innerHTML = `
                    <div class="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center p-4 animate-fade-in" style="z-index: 9999;">
                        <div class="bg-white rounded-2xl sm:rounded-3xl shadow-2xl w-full max-w-sm sm:max-w-md overflow-hidden transform transition-all scale-100">
                            <div class="p-4 sm:p-6">
                                ${type !== 'loading' ? `<h3 class="text-lg sm:text-xl font-bold text-slate-900 mb-2">${title}</h3>` : ''}
                                ${message && type !== 'loading' ? `<p class="text-sm sm:text-base text-slate-500 mb-4 sm:mb-6">${message}</p>` : ''}
                                
                                <form id="modal-form" onsubmit="app.handleModalSubmit(event)">
                                    <div id="modal-content" class="mb-4 sm:mb-6">
                                        ${content}
                                    </div>
                                    
                                    ${type !== 'loading' ? `
                                    <div class="flex gap-2 sm:gap-3">
                                        ${type !== 'alert' ? `
                                            <button type="button" onclick="app.closeModal()" class="flex-1 py-2.5 sm:py-3 px-4 bg-slate-100 hover:bg-slate-200 text-slate-700 text-sm sm:text-base font-bold rounded-xl transition-colors">
                                                ${cancelText}
                                            </button>
                                        ` : ''}
                                        <button type="submit" class="flex-1 py-2.5 sm:py-3 px-4 bg-blue-600 hover:bg-blue-700 text-white text-sm sm:text-base font-bold rounded-xl shadow-lg shadow-blue-200 transition-all">
                                            ${confirmText}
                                        </button>
                                    </div>
                                    ` : ''}
                                </form>
                            </div>
                        </div>
                    </div>
                `;
            }

            renderFloatingButtons() {
                const container = document.getElementById('floating-buttons');
                if (!container) return;

                // Only show floating scan button when there's an active session and we're in the main session view
                // (not showing settings, product DB, session history, start screen, or scanning)
                const shouldShow = this.activeStockTake &&
                    !this.showingStartStockTake &&
                    !this.showingSettings &&
                    !this.showingProductDB &&
                    !this.showingRMProductDB &&
                    !this.showingSessionHistory &&
                    !this.showingLocationManagement &&
                    !this.showingQRGenerator &&
                    !this.isScanning;

                if (!shouldShow) {
                    container.innerHTML = '';
                    return;
                }

                const isRM = this.activeStockTake?.sessionType === 'RM';
                const isFP = this.activeStockTake?.sessionType === 'FP';

                // Stack buttons vertically on the right side
                container.innerHTML = `
                    <div class="fixed bottom-6 right-6 z-[9999] flex flex-col items-center gap-3">
                        ${isFP ? `
                        <!-- Manual 5-digit entry button (above scan) -->
                        <button onclick="app.showManual5DigitEntry()" 
                            class="w-12 h-12 bg-amber-500 hover:bg-amber-600 active:scale-95 text-white rounded-full shadow-lg shadow-amber-200/50 flex items-center justify-center transition-all border-2 border-amber-400"
                            title="Manual 5-digit entry">
                            <span class="text-sm font-bold">5#</span>
                        </button>
                        ` : ''}
                        
                        <!-- Main scan button -->
                        <button onclick="app.startScanning()" 
                            class="w-16 h-16 ${isRM ? 'bg-gradient-to-br from-teal-500 to-teal-600 shadow-teal-200/50 border-teal-400' : 'bg-gradient-to-br from-blue-500 to-blue-600 shadow-blue-200/50 border-blue-400'} active:scale-95 text-white rounded-full shadow-xl flex items-center justify-center transition-all border-2"
                            title="Scan barcode">
                            <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v1m6 11h2m-6 0h-2v4m0-11v3m0 0h.01M12 12h4.01M16 20h4M4 12h4m12 0h.01M5 8h2a1 1 0 001-1V5a1 1 0 00-1-1H5a1 1 0 00-1 1v2a1 1 0 001 1zm12 0h2a1 1 0 001-1V5a1 1 0 00-1-1h-2a1 1 0 00-1 1v2a1 1 0 001 1zM5 20h2a1 1 0 001-1v-2a1 1 0 00-1-1H5a1 1 0 00-1 1v2a1 1 0 001 1z"/>
                            </svg>
                        </button>
                    </div>
                `;
            }

            // Manual 5-digit batch number entry for FP sessions
            showManual5DigitEntry() {
                this.showModal({
                    title: ' Manual Entry',
                    message: 'Enter the 5-digit batch number:',
                    type: 'input',
                    confirmText: 'Continue',
                    cancelText: 'Cancel',
                    onConfirm: (data) => {
                        const batchNumber = (data.value || '').trim();

                        // Validate 5-digit format
                        if (!/^\d{5}$/.test(batchNumber)) {
                            alert('Please enter exactly 5 digits');
                            return;
                        }

                        // Look up product info
                        const productInfo = productDatabase[batchNumber];

                        // Create a synthetic 13-digit raw_code for manual entries
                        // Format: 00000 (prefix) + batchNumber (5 digits) + 000 (suffix) = 13 digits
                        const syntheticRawCode = '00000' + batchNumber + '000';

                        // Create parsed data similar to parseQRCode
                        const parsed = {
                            valid: true,
                            raw: syntheticRawCode, // Use 13-digit synthetic code for database
                            batchNumber: batchNumber,
                            palletNumber: null, // No pallet for manual entry
                            casesOnPallet: 0,
                            stockCode: productInfo?.stockCode || 'UNKNOWN',
                            description: productInfo?.description || 'Unknown Product',
                            isUnknownProduct: !productInfo,
                            isManualEntry: true // Flag for manual entry
                        };

                        // Handle unknown product - show search to select product
                        if (parsed.isUnknownProduct) {
                            this._unknownFPParsed = parsed;
                            this._unknownFPScanKey = batchNumber;
                            this._showFPProductSearch(parsed, batchNumber);
                            return;
                        }

                        // Proceed to case entry
                        this.currentScan = parsed;
                        this.showingCaseEntry = true;
                        this.render();
                    }
                });

                // Set input properties for number entry
                setTimeout(() => {
                    const input = document.getElementById('modal-input');
                    if (input) {
                        input.type = 'tel';
                        input.pattern = '[0-9]*';
                        input.inputMode = 'numeric';
                        input.maxLength = 5;
                        input.placeholder = '00000';
                        input.focus();
                    }
                }, 100);
            }

            // Optimized render with debouncing to prevent excessive DOM updates
            render() {
                // Skip if render is already scheduled
                if (this._renderScheduled) return;

                // Debounce rapid render calls
                const now = performance.now();
                const timeSinceLastRender = now - this._lastRenderTime;

                if (timeSinceLastRender < this._renderDebounceMs) {
                    this._renderScheduled = true;
                    requestAnimationFrame(() => {
                        this._renderScheduled = false;
                        this._executeRender();
                    });
                    return;
                }

                this._executeRender();
            }

            _executeRender() {
                this._lastRenderTime = performance.now();
                this.renderModal();
                this.renderFloatingButtons();
                const scrollY = window.scrollY;
                const app = document.getElementById('app');

                const updateView = (html) => {
                    app.innerHTML = html;
                    // Restore scroll position if we are in the main list view
                    // (heuristic: if we are not showing a modal or special screen)
                    if (!this.showingStartStockTake && !this.showingSettings && !this.showingProductDB && !this.showingRMProductDB && !this.showingSessionHistory) {
                        window.scrollTo(0, scrollY);
                    } else {
                        window.scrollTo(0, 0);
                    }
                };

                if (this.isScanning && document.getElementById('scanner-view')) {
                    return;
                }
                // Note: Session refresh moved to explicit calls only to avoid blocking render

                // ===== LOCATION MANAGEMENT PAGE (Admin Only) =====
                if (this.showingLocationManagement) {
                    const locations = getWarehouseLocations();
                    const rackLocations = locations.filter(l => l.location_type === 'rack');
                    const floorLocations = locations.filter(l => l.location_type === 'floor');

                    updateView(`
                        <div class="min-h-screen bg-slate-50">
                            <div class="bg-purple-600 text-white p-4 sm:p-6">
                                <div class="max-w-4xl mx-auto">
                                    <button onclick="app.hideLocationManagement()" class="flex items-center gap-2 text-purple-100 hover:text-white mb-4 transition-colors">
                                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                                        </svg>
                                        <span class="font-medium">Back</span>
                                    </button>
                                    <h1 class="text-2xl font-bold"> Location Management</h1>
                                    <p class="text-purple-100 text-sm mt-1">Manage pallet rack and floor locations</p>
                                </div>
                            </div>
                            
                            <div class="max-w-4xl mx-auto p-4 sm:p-6">
                                <!-- Add Location Buttons -->
                                <div class="flex gap-3 mb-6">
                                    <button onclick="app.addRackLocation()" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white py-3 px-4 rounded-xl font-bold transition-colors">
                                         Add Rack Location
                                    </button>
                                    <button onclick="app.addFloorLocationDB()" class="flex-1 bg-teal-600 hover:bg-teal-700 text-white py-3 px-4 rounded-xl font-bold transition-colors">
                                         Add Floor Location
                                    </button>
                                </div>
                                
                                <!-- Rack Locations -->
                                <div class="bg-white rounded-2xl shadow-lg shadow-slate-200 mb-6 overflow-hidden">
                                    <div class="bg-blue-50 px-4 py-3 border-b border-blue-100">
                                        <h2 class="font-bold text-blue-800"> Rack Locations (${rackLocations.length})</h2>
                                    </div>
                                    <div class="divide-y divide-slate-100 max-h-64 overflow-y-auto">
                                        ${rackLocations.length === 0 ? `
                                            <div class="p-4 text-center text-slate-400">No rack locations defined</div>
                                        ` : rackLocations.map(loc => `
                                            <div class="p-4 flex items-center justify-between hover:bg-slate-50">
                                                <div>
                                                    <div class="font-bold text-slate-900">${loc.location_code}</div>
                                                    <div class="text-xs text-slate-500">${loc.warehouse || ''} ${loc.description || ''}</div>
                                                </div>
                                                <button onclick="app.deleteLocationDB('${loc.id}')" class="p-2 text-red-500 hover:bg-red-50 rounded-lg transition-colors" title="Delete">
                                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                                                    </svg>
                                                </button>
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                                
                                <!-- Floor Locations -->
                                <div class="bg-white rounded-2xl shadow-lg shadow-slate-200 overflow-hidden">
                                    <div class="bg-teal-50 px-4 py-3 border-b border-teal-100">
                                        <h2 class="font-bold text-teal-800"> Floor Locations (${floorLocations.length})</h2>
                                    </div>
                                    <div class="divide-y divide-slate-100 max-h-64 overflow-y-auto">
                                        ${floorLocations.length === 0 ? `
                                            <div class="p-4 text-center text-slate-400">No floor locations defined</div>
                                        ` : floorLocations.map(loc => `
                                            <div class="p-4 flex items-center justify-between hover:bg-slate-50">
                                                <div>
                                                    <div class="font-bold text-slate-900">${loc.location_code}</div>
                                                    <div class="text-xs text-slate-500">${loc.warehouse || ''} ${loc.description || ''}</div>
                                                </div>
                                                <button onclick="app.deleteLocationDB('${loc.id}')" class="p-2 text-red-500 hover:bg-red-50 rounded-lg transition-colors" title="Delete">
                                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                                                    </svg>
                                                </button>
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                            </div>
                        </div>
                    `);
                    return;
                }

                // ===== QR CODE GENERATOR PAGE (Admin Only) =====
                if (this.showingQRGenerator) {
                    const locations = getWarehouseLocations();
                    const selectedSet = this._selectedLocationsForQR || new Set();

                    updateView(`
                        <div class="min-h-screen bg-slate-50">
                            <div class="bg-purple-600 text-white p-4 sm:p-6">
                                <div class="max-w-4xl mx-auto">
                                    <button onclick="app.hideQRGenerator()" class="flex items-center gap-2 text-purple-100 hover:text-white mb-4 transition-colors">
                                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                                        </svg>
                                        <span class="font-medium">Back</span>
                                    </button>
                                    <h1 class="text-2xl font-bold"> QR Code Generator</h1>
                                    <p class="text-purple-100 text-sm mt-1">Select locations to generate printable QR codes</p>
                                </div>
                            </div>
                            
                            <div class="max-w-4xl mx-auto p-4 sm:p-6">
                                <!-- Action Buttons -->
                                <div class="flex gap-3 mb-6">
                                    <button onclick="app.selectAllLocationsForQR()" class="flex-1 bg-slate-200 hover:bg-slate-300 text-slate-700 py-3 px-4 rounded-xl font-bold transition-colors">
                                        Select All
                                    </button>
                                    <button onclick="app.clearLocationSelections()" class="flex-1 bg-slate-200 hover:bg-slate-300 text-slate-700 py-3 px-4 rounded-xl font-bold transition-colors">
                                        Clear All
                                    </button>
                                    <button onclick="app.generateQRCodes()" class="flex-1 bg-purple-600 hover:bg-purple-700 text-white py-3 px-4 rounded-xl font-bold transition-colors ${selectedSet.size === 0 ? 'opacity-50' : ''}">
                                         Print (${selectedSet.size})
                                    </button>
                                </div>
                                
                                <!-- Location Selection -->
                                <div class="bg-white rounded-2xl shadow-lg shadow-slate-200 overflow-hidden">
                                    <div class="bg-slate-50 px-4 py-3 border-b border-slate-100">
                                        <h2 class="font-bold text-slate-800">Select Locations (${locations.length} available)</h2>
                                    </div>
                                    <div class="divide-y divide-slate-100 max-h-96 overflow-y-auto">
                                        ${locations.length === 0 ? `
                                            <div class="p-4 text-center text-slate-400">No locations defined. Add locations first.</div>
                                        ` : locations.map(loc => `
                                            <label class="p-4 flex items-center gap-3 hover:bg-slate-50 cursor-pointer">
                                                <input type="checkbox" 
                                                    ${selectedSet.has(loc.location_code) ? 'checked' : ''}
                                                    onchange="app.toggleLocationForQR('${loc.location_code}')"
                                                    class="w-5 h-5 rounded border-slate-300 text-purple-600 focus:ring-purple-500"
                                                />
                                                <div class="flex-1">
                                                    <div class="font-bold text-slate-900">${loc.location_code}</div>
                                                    <div class="text-xs text-slate-500">${loc.location_type === 'rack' ? ' Rack' : ' Floor'} ${loc.warehouse ? ' ' + loc.warehouse : ''}</div>
                                                </div>
                                            </label>
                                        `).join('')}
                                    </div>
                                </div>
                            </div>
                        </div>
                    `);
                    return;
                }

                // Start Stock Take Screen - Step 1: Type Selection
                if (this.showingStartStockTake && !this.selectedStockTakeType) {
                    const savedName = getUserName();

                    updateView(`
                        <div class="min-h-screen flex flex-col bg-white">
                            <div class="flex-1 flex flex-col items-center justify-center p-4 sm:p-8">
                                <div class="w-full max-w-lg mx-auto">
                                    <div class="flex flex-col items-center mb-8">
                                        <div class="w-20 h-20 sm:w-24 sm:h-24 bg-gradient-to-br from-blue-500 to-blue-600 rounded-3xl flex items-center justify-center mb-6 sm:mb-8 shadow-lg shadow-blue-200 transform -rotate-6">
                                            <svg class="w-10 h-10 sm:w-12 sm:h-12 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"/>
                                            </svg>
                                        </div>
                                        
                                        <h1 class="text-2xl sm:text-3xl font-bold text-slate-900">Stock Intelligence</h1>
                                    </div>
                                    
                                    <div class="w-full space-y-5">
                                        <!-- Name Input Field -->
                                        <div>
                                            <input 
                                                type="text" 
                                                id="userNameInput" 
                                                value="${savedName}"
                                                placeholder="Enter your name"
                                                onchange="setUserName(this.value); app.handleNameChange();"
                                                class="w-full px-4 py-3 text-center text-lg font-medium border-2 border-slate-200 rounded-xl focus:border-blue-500 focus:ring-2 focus:ring-blue-100 outline-none transition-all"
                                            />
                                            ${(() => {
                            const role = getUserRole();
                            const warehouse = getUserWarehouse();
                            if (role === 'admin') {
                                return '<div class="mt-2 text-center"><span class="inline-flex items-center gap-1 px-3 py-1 bg-purple-100 text-purple-700 rounded-full text-xs font-bold"> Admin</span></div>';
                            } else if (role === 'supervisor') {
                                const warehouseBadge = warehouse ? `  ${warehouse}` : '';
                                return '<div class="mt-2 text-center"><span class="inline-flex items-center gap-1 px-3 py-1 bg-amber-100 text-amber-700 rounded-full text-xs font-bold"> Supervisor' + warehouseBadge + '</span></div>';
                            } else {
                                const warehouseBadge = warehouse ? `  ${warehouse}` : '';
                                return '<div class="mt-2 text-center"><span class="inline-flex items-center gap-1 px-3 py-1 bg-slate-100 text-slate-600 rounded-full text-xs font-bold"> Operator' + warehouseBadge + '</span></div>';
                            }
                        })()}
                                        </div>
                                        
                                        <div>
                                            <label class="block text-sm font-bold text-slate-700 mb-3 text-center">
                                                Stock Count Type
                                            </label>
                                            <div class="grid grid-cols-2 gap-4">
                                            <button 
                                                onclick="app.selectStockTakeType('FP', document.getElementById('userNameInput').value)"
                                                class="bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800 active:scale-[0.98] text-white p-4 sm:p-5 rounded-2xl text-xl sm:text-2xl font-bold shadow-lg shadow-blue-200 transition-all flex items-center justify-center hover-lift"
                                            >
                                                FP
                                            </button>
                                            <button 
                                                onclick="app.selectStockTakeType('RM', document.getElementById('userNameInput').value)"
                                                class="bg-gradient-to-r from-teal-600 to-teal-700 hover:from-teal-700 hover:to-teal-800 active:scale-[0.98] text-white p-4 sm:p-5 rounded-2xl text-xl sm:text-2xl font-bold shadow-lg shadow-teal-200 transition-all flex items-center justify-center hover-lift"
                                            >
                                                RM
                                            </button>
                                        </div>
                                    </div>
                                </div>
                                </div>
                            </div>
                            
                            <!-- Quick Actions (role-based) -->
                            <div class="p-4 sm:p-6 pt-0">
                                <div class="max-w-lg mx-auto">
                                    <div class="flex gap-3 justify-center flex-wrap">
                                        ${canViewHistory() ? `
                                        <button onclick="app.showSessionHistory()" class="w-12 h-12 bg-slate-100 hover:bg-slate-200 text-slate-600 rounded-full transition-colors flex items-center justify-center hover-lift" title="History">
                                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                            </svg>
                                        </button>
                                        ` : ''}
                                        ${canViewSettings() ? `
                                        <button onclick="app.showSettings()" class="w-12 h-12 bg-slate-100 hover:bg-slate-200 text-slate-600 rounded-full transition-colors flex items-center justify-center hover-lift" title="Settings">
                                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/>
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
                                            </svg>
                                        </button>
                                        ` : ''}
                                        ${getUserRole() === 'admin' ? `
                                        <button onclick="app.showLocationManagement()" class="w-12 h-12 bg-purple-100 hover:bg-purple-200 text-purple-600 rounded-full transition-colors flex items-center justify-center hover-lift" title="Location Management">
                                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"/>
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"/>
                                            </svg>
                                        </button>
                                        <button onclick="app.showQRGenerator()" class="w-12 h-12 bg-purple-100 hover:bg-purple-200 text-purple-600 rounded-full transition-colors flex items-center justify-center hover-lift" title="QR Code Generator">
                                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v1m6 11h2m-6 0h-2v4m0-11v3m0 0h.01M12 12h4.01M16 20h4M4 12h4m12 0h.01M5 8h2a1 1 0 001-1V5a1 1 0 00-1-1H5a1 1 0 00-1 1v2a1 1 0 001 1zm12 0h2a1 1 0 001-1V5a1 1 0 00-1-1h-2a1 1 0 00-1 1v2a1 1 0 001 1zM5 20h2a1 1 0 001-1v-2a1 1 0 00-1-1H5a1 1 0 00-1 1v2a1 1 0 001 1z"/>
                                            </svg>
                                        </button>
                                        ` : ''}
                                    </div>
                                </div>
                            </div>
                            
                            <div class="p-4 sm:p-6 pt-0 text-center">
                                ${supabase && this.isBrowserOnline ? `
                                    <div class="inline-flex items-center gap-2 px-4 py-2 bg-green-50 text-green-700 rounded-full text-xs font-bold border border-green-100">
                                        <div class="w-2 h-2 bg-green-500 rounded-full animate-pulse"></div>
                                        <span>Connected to Supabase</span>
                                    </div>
                                ` : `
                                    <div class="inline-flex items-center gap-2 px-4 py-2 bg-slate-100 text-slate-600 rounded-full text-xs font-bold border border-slate-200">
                                        <div class="w-2 h-2 bg-slate-400 rounded-full"></div>
                                        <span>Offline Mode</span>
                                    </div>
                                `}
                                <p class="text-xs text-slate-400 mt-4">v1.0.0  ${this.currentTakeDate}</p>
                            </div>
                        </div>
                    `);
                    return;
                }

                // Start Stock Take Screen - Step 2: Session Selection
                if (this.showingStartStockTake && this.selectedStockTakeType) {
                    const savedName = getUserName();
                    const sessionType = this.selectedStockTakeType;
                    const isRM = sessionType === 'RM';
                    const activeSessions = getActiveSessionsForDate(this.currentTakeDate).filter(s => s.sessionType === sessionType);

                    updateView(`
                        <div class="min-h-screen flex flex-col bg-white pb-24">
                            <!-- Header -->
                            <div class="p-4 border-b border-slate-100">
                                <div class="max-w-2xl mx-auto">
                                    <button onclick="app.selectedStockTakeType = null; app.render();" class="flex items-center gap-2 text-slate-600 hover:text-slate-900 transition-colors">
                                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                                        </svg>
                                        <span class="font-medium text-sm sm:text-base">Back to Type Selection</span>
                                    </button>
                                </div>
                            </div>
                            
                            <div class="flex-1 flex flex-col p-4 sm:p-6">
                                <div class="max-w-2xl mx-auto w-full">
                                    <div class="flex items-center gap-3 sm:gap-4 mb-6">
                                        <div class="w-12 h-12 sm:w-16 sm:h-16 ${isRM ? 'bg-gradient-to-br from-teal-500 to-teal-600' : 'bg-gradient-to-br from-blue-600 to-blue-700'} rounded-xl sm:rounded-2xl flex items-center justify-center shadow-lg ${isRM ? 'shadow-teal-200' : 'shadow-blue-200'}">
                                            ${isRM ? `
                                                <svg class="w-6 h-6 sm:w-8 sm:h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z"/>
                                                </svg>
                                            ` : `
                                                <svg class="w-6 h-6 sm:w-8 sm:h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 7l-8-4-8 4m16 0l-8 4m8-4v10l-8 4m0-10L4 7m8 4v10M4 7v10l8 4"/>
                                                </svg>
                                            `}
                                        </div>
                                        <div>
                                            <h1 class="text-xl sm:text-2xl font-bold text-slate-900">${isRM ? 'Raw Materials' : 'Finished Products'}</h1>
                                            <p class="text-sm sm:text-base text-slate-500">Select or start a session</p>
                                        </div>
                                    </div>
                                
                                ${activeSessions.length > 0 ? `
                                    <!-- Active Sessions -->
                                    <div class="mb-6">
                                        <label class="block text-sm font-bold text-slate-700 mb-3">
                                            Active ${isRM ? 'RM' : 'FP'} Sessions
                                        </label>
                                        <div class="space-y-3">
                                            ${activeSessions.map(session => {
                        const activeCount = session.devices?.filter(d => d.status === 'active').length || 0;
                        const completedCount = session.devices?.filter(d => d.status === 'completed').length || 0;
                        const sessionDate = session.startedAt ? new Date(session.startedAt).toLocaleDateString() : session.date || '';
                        const sessionTime = session.startedAt ? new Date(session.startedAt).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '';
                        return `
                                                    <div class="p-4 border-2 ${isRM ? 'border-teal-200' : 'border-blue-200'} rounded-2xl">
                                                        <div class="flex items-center justify-between mb-2">
                                                            <div class="flex items-center gap-2">
                                                                <span class="px-3 py-1 text-sm font-bold ${isRM ? 'bg-teal-100 text-teal-700' : 'bg-blue-100 text-blue-700'} rounded-full">
                                                                    Session #${session.sessionNumber}
                                                                </span>
                                                                <span class="text-slate-600">by ${session.startedBy}</span>
                                                            </div>
                                                        </div>
                                                        <div class="flex items-center gap-4 text-sm mb-3">
                                                            <div class="flex items-center gap-1 text-emerald-600">
                                                                <div class="w-2 h-2 bg-emerald-500 rounded-full animate-pulse"></div>
                                                                <span>${activeCount} active</span>
                                                            </div>
                                                            ${completedCount > 0 ? `
                                                                <div class="flex items-center gap-1 text-slate-400">
                                                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
                                                                    </svg>
                                                                    <span>${completedCount} done</span>
                                                                </div>
                                                            ` : ''}
                                                            <div class="flex items-center gap-1 text-slate-400">
                                                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"/>
                                                                </svg>
                                                                <span>${sessionDate} ${sessionTime}</span>
                                                            </div>
                                                        </div>
                                                        <div class="flex gap-2">
                                                            <button 
                                                                onclick="app.joinExistingSession('${session.id}', '${savedName}')"
                                                                class="flex-1 py-2 px-4 ${isRM ? 'bg-teal-600 hover:bg-teal-700' : 'bg-blue-600 hover:bg-blue-700'} text-white font-bold rounded-xl transition-colors text-sm"
                                                            >
                                                                Join Session
                                                            </button>
                                                            <button 
                                                                onclick="app.endSessionFromList('${session.id}')"
                                                                class="py-2 px-4 bg-slate-100 hover:bg-slate-200 text-slate-600 font-bold rounded-xl transition-colors text-sm"
                                                            >
                                                                End
                                                            </button>
                                                        </div>
                                                    </div>
                                                `;
                    }).join('')}
                                        </div>
                                    </div>
                                ` : `
                                    <div class="mb-6 p-4 sm:p-6 bg-slate-50 rounded-xl sm:rounded-2xl text-center">
                                        <svg class="w-10 h-10 sm:w-12 sm:h-12 mx-auto text-slate-300 mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"/>
                                        </svg>
                                        <p class="text-sm sm:text-base text-slate-500">No active ${isRM ? 'RM' : 'FP'} sessions today</p>
                                        <p class="text-xs sm:text-sm text-slate-400">Start a new session below</p>
                                    </div>
                                `}
                                </div>
                            </div>
                            
                            <div class="p-4 sm:p-6 text-center border-t border-slate-100">
                                <p class="text-xs text-slate-400">${this.currentTakeDate}</p>
                            </div>
                            
                            <!-- Floating Start New Session Button - Bottom Right (supervisors/admins only) -->
                            ${canCreateSession() ? `
                            <button 
                                onclick="app.startNewStockTake('${savedName}', '${sessionType}')"
                                class="fixed bottom-6 right-6 ${isRM ? 'bg-teal-600 hover:bg-teal-700 shadow-teal-200' : 'bg-blue-600 hover:bg-blue-700 shadow-blue-200'} text-white px-5 py-3 rounded-full shadow-xl transition-all flex items-center gap-2 font-bold text-sm z-40"
                            >
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"/>
                                </svg>
                                New Session
                            </button>
                            ` : ''}
                        </div>
                    `);
                    return;
                }

                if (this.isScanning) {
                    updateView(`
                        <div id="scanner-view" class="fixed inset-0 bg-black z-50 flex flex-col">
                            <!-- Scanner Header -->
                            <div class="absolute top-0 left-0 right-0 z-10 p-4 flex justify-between items-start bg-gradient-to-b from-black/50 to-transparent">
                                <button onclick="app.stopScanning()" class="bg-white/20 backdrop-blur-md text-white p-3 rounded-full hover:bg-white/30 transition-colors">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                                <button onclick="app.manualEntry()" class="bg-white/20 backdrop-blur-md text-white px-4 py-2 rounded-full hover:bg-white/30 transition-colors text-sm font-medium">
                                    Type Code
                                </button>
                            </div>

                            <!-- Scanner Viewport -->
                            <div class="flex-1 relative overflow-hidden bg-black">
                                <div id="scanner" class="w-full h-full absolute inset-0"></div>
                                
                                <!-- Overlay Guide -->
                                <div class="absolute inset-0 pointer-events-none flex items-center justify-center">
                                    <div class="w-64 h-64 border-2 border-white/50 rounded-3xl relative">
                                        <div class="absolute top-0 left-0 w-8 h-8 border-t-4 border-l-4 border-blue-500 rounded-tl-xl -mt-1 -ml-1"></div>
                                        <div class="absolute top-0 right-0 w-8 h-8 border-t-4 border-r-4 border-blue-500 rounded-tr-xl -mt-1 -mr-1"></div>
                                        <div class="absolute bottom-0 left-0 w-8 h-8 border-b-4 border-l-4 border-blue-500 rounded-bl-xl -mb-1 -ml-1"></div>
                                        <div class="absolute bottom-0 right-0 w-8 h-8 border-b-4 border-r-4 border-blue-500 rounded-br-xl -mb-1 -mr-1"></div>
                                        
                                        <div class="absolute top-1/2 left-0 right-0 h-0.5 bg-red-500/50 animate-pulse"></div>
                                    </div>
                                </div>
                                
                                <!-- Location Indicator (when active) -->
                                ${this.activeLocation ? `
                                <div class="absolute top-4 left-1/2 -translate-x-1/2 z-20 pointer-events-none">
                                    <div class="bg-purple-600/90 backdrop-blur-md text-white px-4 py-2 rounded-full text-sm font-bold flex items-center gap-2 shadow-lg">
                                        <span></span>
                                        <span>${this.activeLocation}</span>
                                    </div>
                                </div>
                                ` : ''}
                                
                                <div class="absolute bottom-20 left-0 right-0 text-center pointer-events-none">
                                    <div class="inline-block bg-black/60 backdrop-blur-md text-white px-6 py-2 rounded-full text-sm font-medium">
                                        ${this.activeLocation ? 'Scan products for this location' : 'Align QR code within frame'}
                                    </div>
                                </div>
                            </div>
                        </div>
                    `);
                    return;
                }

                // Expiry Date Selection Screen
                if (this.showingExpirySelection && this.pendingScan) {
                    const scan = this.pendingScan;
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);

                    updateView(`
                        <div class="min-h-screen bg-slate-50 flex flex-col">
                            <div class="flex-1 p-4 sm:p-6 flex flex-col justify-center max-w-md lg:max-w-lg mx-auto w-full">
                                <div class="bg-white rounded-2xl sm:rounded-3xl shadow-xl shadow-slate-200 overflow-hidden">
                                    <div class="bg-blue-500 p-4 sm:p-6 text-white text-center">
                                        <div class="flex items-center justify-center gap-2 mb-2">
                                            <svg class="w-5 h-5 sm:w-6 sm:h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"/>
                                            </svg>
                                            <span class="font-bold text-sm sm:text-base">CONFIRM EXPIRY DATE</span>
                                        </div>
                                        <h2 class="text-lg sm:text-xl font-bold">Multiple Expiry Dates Found</h2>
                                        <p class="text-blue-100 text-xs sm:text-sm mt-1">Please select the correct expiry date for this item</p>
                                    </div>
                                    
                                    <div class="p-4 sm:p-6 space-y-4">
                                        <!-- Product Info -->
                                        <div class="text-center pb-4 border-b border-slate-100">
                                            <div class="inline-block bg-blue-50 text-blue-700 px-3 py-1 rounded-full text-xs sm:text-sm font-bold mb-2">
                                                ${scan.stockCode}
                                            </div>
                                            <h3 class="text-base sm:text-lg font-medium text-slate-900 leading-tight mb-1">${scan.description}</h3>
                                            <div class="text-xs sm:text-sm text-slate-500">Batch: ${scan.batchNumber}</div>
                                        </div>
                                        
                                        <!-- Expiry Date Options -->
                                        <div class="space-y-2">
                                            <label class="block text-xs font-bold text-slate-500 uppercase tracking-wider mb-2">
                                                Select Expiry Date
                                            </label>
                                            ${scan.availableExpiryDates.map(expDate => {
                        const exp = new Date(expDate);
                        exp.setHours(0, 0, 0, 0);
                        const isExpired = exp <= today;
                        const displayDate = exp.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });

                        return `
                                                    <button 
                                                        onclick="app.selectExpiryDate('${expDate}')"
                                                        class="w-full p-3 sm:p-4 border-2 ${isExpired ? 'border-red-200 bg-red-50 hover:border-red-400' : 'border-slate-200 bg-white hover:border-blue-400 hover:bg-blue-50'} rounded-xl transition-all text-left flex items-center justify-between"
                                                    >
                                                        <div class="flex items-center gap-3">
                                                            <div class="w-8 h-8 sm:w-10 sm:h-10 ${isExpired ? 'bg-red-100' : 'bg-blue-100'} rounded-full flex items-center justify-center">
                                                                <svg class="w-4 h-4 sm:w-5 sm:h-5 ${isExpired ? 'text-red-600' : 'text-blue-600'}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"/>
                                                                </svg>
                                                            </div>
                                                            <div>
                                                                <div class="font-bold text-sm sm:text-base ${isExpired ? 'text-red-700' : 'text-slate-900'}">${displayDate}</div>
                                                                ${isExpired ? '<div class="text-xs text-red-500 font-medium"> EXPIRED</div>' : ''}
                                                            </div>
                                                        </div>
                                                        <svg class="w-5 h-5 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                                                        </svg>
                                                    </button>
                                                `;
                    }).join('')}
                                        </div>
                                        
                                        <!-- Cancel Button -->
                                        <button 
                                            onclick="app.cancelExpirySelection()" 
                                            class="w-full mt-4 bg-slate-100 hover:bg-slate-200 text-slate-600 py-2.5 sm:py-3 rounded-xl text-sm sm:text-base font-bold transition-colors"
                                        >
                                            Cancel
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `);
                    return;
                }

                if (this.showingCaseEntry && this.currentScan) {
                    const scan = this.currentScan;
                    // Check if expired
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    let isExpired = false;
                    let expiryDisplay = '';
                    if (scan.expiryDate) {
                        const expiry = new Date(scan.expiryDate);
                        expiry.setHours(0, 0, 0, 0);
                        isExpired = expiry <= today;
                        expiryDisplay = expiry.toLocaleDateString();
                    }
                    updateView(`
                        <div class="min-h-screen bg-slate-50 flex flex-col">
                            <div class="flex-1 p-4 sm:p-6 flex flex-col justify-center max-w-md lg:max-w-lg mx-auto w-full">
                                <div class="bg-white rounded-2xl sm:rounded-3xl shadow-xl shadow-slate-200 overflow-hidden">
                                    <div class="${isExpired ? 'bg-red-600' : 'bg-blue-600'} p-4 sm:p-6 text-white text-center">
                                        ${isExpired ? `
                                            <div class="flex items-center justify-center gap-2 mb-2">
                                                <svg class="w-5 h-5 sm:w-6 sm:h-6 animate-pulse" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/>
                                                </svg>
                                                <span class="font-bold text-sm sm:text-base">EXPIRED PRODUCT</span>
                                            </div>
                                        ` : ''}
                                        <h2 class="text-xl sm:text-2xl font-bold">Confirm Count</h2>
                                        <p class="${isExpired ? 'text-red-100' : 'text-blue-100'} text-xs sm:text-sm mt-1">Verify the physical stock count</p>
                                    </div>
                                    
                                    ${isExpired ? `
                                        <div class="bg-red-50 border-b border-red-100 p-4 flex items-center gap-3">
                                            <div class="flex-shrink-0 w-10 h-10 bg-red-100 rounded-full flex items-center justify-center">
                                                <svg class="w-5 h-5 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"/>
                                                </svg>
                                            </div>
                                            <div>
                                                <div class="font-bold text-red-700">Expired: ${expiryDisplay}</div>
                                                <div class="text-sm text-red-600">This item is past its expiry date</div>
                                            </div>
                                        </div>
                                    ` : (scan.expiryDate ? `
                                        <div class="bg-slate-50 border-b border-slate-100 p-3 flex items-center justify-center gap-2 text-sm text-slate-600">
                                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"/>
                                            </svg>
                                            <span>Expires: ${expiryDisplay}</span>
                                        </div>
                                    ` : '')}
                                    
                                    <div class="p-4 sm:p-6 space-y-4 sm:space-y-6">
                                        <!-- Product Info -->
                                        <div class="text-center">
                                            <div class="inline-block ${isExpired ? 'bg-red-50 text-red-700' : 'bg-blue-50 text-blue-700'} px-3 py-1 rounded-full text-xs sm:text-sm font-bold mb-2">
                                                ${scan.stockCode}
                                            </div>
                                            <h3 class="text-base sm:text-lg font-medium text-slate-900 leading-tight mb-1">${scan.description}</h3>
                                            ${scan.isRawMaterial ? `
                                                <div class="text-xs sm:text-sm text-slate-500">Batch: ${scan.batchNumber}</div>
                                                <div class="mt-1 inline-block px-2 py-0.5 text-xs font-bold ${scan.unitType === 'kg' ? 'bg-teal-100 text-teal-700' : 'bg-blue-100 text-blue-700'} rounded-full">
                                                    ${scan.unitType === 'kg' ? ' Measured in KG' : ' Counted in Units'}
                                                </div>
                                            ` : `
                                                <div class="text-xs sm:text-sm text-slate-500">Batch: ${scan.batchNumber}  Pallet: ${scan.palletNumber}</div>
                                            `}
                                        </div>

                                        <!-- Count Input -->
                                        <div class="bg-slate-50 rounded-xl sm:rounded-2xl p-4 sm:p-6 border border-slate-100">
                                            ${!scan.isRawMaterial ? `
                                                <div class="flex justify-between items-center mb-4">
                                                    <span class="text-xs sm:text-sm font-bold text-slate-500 uppercase tracking-wider">Expected</span>
                                                    <span class="text-xl sm:text-2xl font-bold text-slate-400">${scan.casesOnPallet}</span>
                                                </div>
                                            ` : ''}
                                            
                                            <div class="relative">
                                                <label class="block text-xs font-bold ${isExpired ? 'text-red-600' : 'text-blue-600'} uppercase tracking-wider mb-2">
                                                    ${scan.isRawMaterial ? (scan.unitType === 'kg' ? 'Quantity (KG)' : 'Quantity (Units)') : 'Actual Count'}
                                                </label>
                                                <input
                                                    type="number"
                                                    id="caseInput"
                                                    value="${scan.isRawMaterial ? '' : scan.casesOnPallet}"
                                                    min="0"
                                                    ${scan.unitType === 'kg' ? 'step="0.01"' : ''}
                                                    placeholder="${scan.isRawMaterial ? 'Enter ' + scan.unitType : ''}"
                                                    class="w-full px-4 py-3 sm:py-4 bg-white border-2 ${isExpired ? 'border-red-100 text-red-900 focus:border-red-600 focus:ring-red-50' : 'border-blue-100 text-blue-900 focus:border-blue-600 focus:ring-blue-50'} rounded-xl text-3xl sm:text-4xl font-black text-center focus:ring-4 outline-none transition-all"
                                                    autofocus
                                                    onclick="this.select()"
                                                />
                                                ${scan.isRawMaterial ? `
                                                    <div class="mt-2 text-center text-xs sm:text-sm text-slate-500">${scan.unitType === 'kg' ? 'Enter weight in kilograms' : 'Enter quantity in units'}</div>
                                                ` : ''}
                                            </div>
                                        </div>
                                        
                                        <!-- Actions -->
                                        <div class="grid grid-cols-2 gap-3 sm:gap-4 pt-2">
                                            <button onclick="app.cancelCaseEntry()" class="bg-white border-2 border-slate-200 text-slate-600 hover:bg-slate-50 py-3 sm:py-4 rounded-xl text-base sm:text-lg font-bold transition-colors">
                                                Cancel
                                            </button>
                                            <button onclick="app.submitCaseCount()" class="${isExpired ? 'bg-red-600 hover:bg-red-700 shadow-red-200' : 'bg-blue-600 hover:bg-blue-700 shadow-blue-200'} text-white py-3 sm:py-4 rounded-xl text-base sm:text-lg font-bold shadow-lg transition-all">
                                                ${isExpired ? 'Confirm (Expired)' : 'Confirm'}
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `);
                    return;
                }

                if (this.showingProductDB) {
                    updateView(`
                        <div class="min-h-screen bg-slate-50 pb-24">
                            <div class="bg-white shadow-sm border-b border-slate-200 sticky top-0 z-20">
                                <div class="max-w-4xl mx-auto">
                                    <div class="flex items-center justify-between p-4">
                                        <div>
                                            <h1 class="text-lg sm:text-xl font-bold text-slate-900">Product Database</h1>
                                            <p class="text-xs sm:text-sm text-slate-500">${Object.keys(productDatabase).length} products ${productsLoadedFromDB ? '(from Supabase)' : '(cached)'}</p>
                                        </div>
                                        <button onclick="app.hideProductDatabase()" class="p-2 bg-slate-100 hover:bg-slate-200 rounded-full transition-colors">
                                            <svg class="w-6 h-6 text-slate-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                            </svg>
                                        </button>
                                    </div>
                                    
                                    <div class="flex gap-2 p-4 pt-0">
                                        <button onclick="app.refreshProductsFromCloud()" class="flex-1 bg-blue-50 text-blue-600 hover:bg-blue-100 py-2.5 px-3 sm:px-4 rounded-xl text-xs sm:text-sm font-bold transition-colors flex items-center justify-center gap-1 sm:gap-2">
                                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
                                            </svg>
                                            <span class="hidden sm:inline">Refresh</span>
                                            <span class="sm:hidden"></span>
                                        </button>
                                        <button onclick="app.uploadExcel()" class="flex-1 bg-blue-50 text-blue-600 hover:bg-blue-100 py-2.5 px-3 sm:px-4 rounded-xl text-xs sm:text-sm font-bold transition-colors flex items-center justify-center gap-1 sm:gap-2">
                                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/>
                                            </svg>
                                            Import
                                        </button>
                                        <button onclick="app.exportProductDatabase()" class="flex-1 bg-emerald-50 text-emerald-600 hover:bg-emerald-100 py-2.5 px-3 sm:px-4 rounded-xl text-xs sm:text-sm font-bold transition-colors flex items-center justify-center gap-1 sm:gap-2">
                                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/>
                                            </svg>
                                            Export
                                        </button>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="p-4 max-w-4xl mx-auto">
                                <div class="space-y-3 md:grid md:grid-cols-2 lg:grid-cols-3 md:gap-4 md:space-y-0">
                                ${Object.keys(productDatabase).length === 0 ? `
                                    <div class="md:col-span-2 lg:col-span-3 text-center py-16">
                                        <div class="w-16 h-16 sm:w-20 sm:h-20 bg-slate-100 rounded-full flex items-center justify-center mx-auto mb-4">
                                            <svg class="w-8 h-8 sm:w-10 sm:h-10 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 13V6a2 2 0 00-2-2H6a2 2 0 00-2 2v7m16 0v5a2 2 0 01-2 2H6a2 2 0 01-2-2v-5m16 0h-2.586a1 1 0 00-.707.293l-2.414 2.414a1 1 0 01-.707.293h-3.172a1 1 0 01-.707-.293l-2.414-2.414A1 1 0 006.586 13H4"/>
                                            </svg>
                                        </div>
                                        <p class="text-lg font-medium text-slate-900">Database Empty</p>
                                        <p class="text-sm text-slate-500 mt-1">Import an Excel file or add products manually</p>
                                    </div>
                                ` : Object.entries(productDatabase).map(([batch, info]) => `
                                    <div class="bg-white rounded-xl p-4 shadow-sm border border-slate-100 hover-lift transition-all">
                                        <div class="flex items-center gap-3 mb-2">
                                            <span class="bg-slate-100 text-slate-600 text-xs px-2 py-1 rounded font-mono font-bold">
                                                ${batch}
                                            </span>
                                            <span class="text-sm font-bold text-blue-600">${info.stockCode}</span>
                                        </div>
                                        <div class="text-slate-900 text-sm">${info.description}</div>
                                    </div>
                                `).join('')}
                                </div>
                            </div>
                            
                            <div class="fixed bottom-0 left-0 right-0 bg-white border-t border-slate-200 p-4 z-20">
                                <div class="max-w-4xl mx-auto space-y-3">
                                    <button onclick="app.addProduct()" class="w-full bg-blue-600 hover:bg-blue-700 text-white py-3 sm:py-3.5 rounded-xl text-base sm:text-lg font-bold shadow-lg shadow-blue-200 transition-all">
                                        + Add Product
                                    </button>
                                    ${Object.keys(productDatabase).length > 0 ? `
                                        <button onclick="app.clearDatabase()" class="w-full bg-white border border-red-200 text-red-600 hover:bg-red-50 py-2.5 sm:py-3 rounded-xl text-sm font-bold transition-colors">
                                            Clear Database
                                        </button>
                                    ` : ''}
                                </div>
                            </div>
                        </div>
                    `);
                    return;
                }

                if (this.showingRMProductDB) {
                    const rmCount = Object.keys(rawMaterialsDatabase).length;
                    let totalBatches = 0;
                    Object.values(rawMaterialsDatabase).forEach(rm => {
                        totalBatches += Object.keys(rm.batches || {}).length;
                    });

                    updateView(`
                        <div class="min-h-screen bg-slate-50 pb-24">
                            <div class="bg-white shadow-sm border-b border-slate-200 sticky top-0 z-20">
                                <div class="max-w-4xl mx-auto">
                                    <div class="flex items-center justify-between p-4">
                                        <div>
                                            <h1 class="text-lg sm:text-xl font-bold text-slate-900">Raw Materials</h1>
                                            <p class="text-xs sm:text-sm text-slate-500">${rmCount} materials, ${totalBatches} batches ${rmProductsLoadedFromDB ? '(from Supabase)' : '(cached)'}</p>
                                        </div>
                                        <button onclick="app.hideProductDatabase()" class="p-2 bg-slate-100 hover:bg-slate-200 rounded-full transition-colors">
                                            <svg class="w-6 h-6 text-slate-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                            </svg>
                                        </button>
                                    </div>
                                </div>
                                
                                <div class="flex gap-2 p-4 pt-0">
                                    <button onclick="app.refreshProductsFromCloud()" class="flex-1 bg-blue-50 text-blue-600 hover:bg-blue-100 py-2.5 px-3 sm:px-4 rounded-xl text-xs sm:text-sm font-bold transition-colors flex items-center justify-center gap-1 sm:gap-2">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
                                        </svg>
                                        <span class="hidden sm:inline">Refresh</span>
                                        <span class="sm:hidden"></span>
                                    </button>
                                    <button onclick="app.uploadRMExcel()" class="flex-1 bg-teal-50 text-teal-600 hover:bg-teal-100 py-2.5 px-3 sm:px-4 rounded-xl text-xs sm:text-sm font-bold transition-colors flex items-center justify-center gap-1 sm:gap-2">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/>
                                        </svg>
                                        Import
                                    </button>
                                    <button onclick="app.exportRMDatabase()" class="flex-1 bg-emerald-50 text-emerald-600 hover:bg-emerald-100 py-2.5 px-3 sm:px-4 rounded-xl text-xs sm:text-sm font-bold transition-colors flex items-center justify-center gap-1 sm:gap-2">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/>
                                        </svg>
                                        Export
                                    </button>
                                </div>
                                </div>
                            </div>
                            
                            <div class="p-4 max-w-4xl mx-auto">
                                <div class="space-y-3 md:grid md:grid-cols-2 lg:grid-cols-3 md:gap-4 md:space-y-0">
                                ${rmCount === 0 ? `
                                    <div class="md:col-span-2 lg:col-span-3 text-center py-16">
                                        <div class="w-16 h-16 sm:w-20 sm:h-20 bg-teal-100 rounded-full flex items-center justify-center mx-auto mb-4">
                                            <svg class="w-8 h-8 sm:w-10 sm:h-10 text-teal-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z"/>
                                            </svg>
                                        </div>
                                        <p class="text-lg font-medium text-slate-900">No Raw Materials</p>
                                        <p class="text-sm text-slate-500 mt-1">Import an Excel file or add materials manually</p>
                                    </div>
                                ` : Object.entries(rawMaterialsDatabase).map(([stockCode, info]) => `
                                    <div class="bg-white rounded-xl p-4 shadow-sm border border-slate-100 hover-lift transition-all">
                                        <div class="flex items-center gap-3 mb-2">
                                            <span class="bg-teal-100 text-teal-700 text-xs px-2 py-1 rounded font-mono font-bold">
                                                ${stockCode}
                                            </span>
                                            <span class="text-xs text-slate-400">${Object.keys(info.batches || {}).length} batches</span>
                                        </div>
                                        <div class="text-slate-900 text-sm font-medium mb-2">${info.description}</div>
                                        ${Object.keys(info.batches || {}).length > 0 ? `
                                            <div class="flex flex-wrap gap-2 mt-2">
                                                ${Object.entries(info.batches).map(([batch, batchInfo]) => `
                                                    <span class="text-xs bg-slate-100 text-slate-600 px-2 py-1 rounded ${batchInfo.expiryDate && new Date(batchInfo.expiryDate) < new Date() ? 'bg-red-100 text-red-600' : ''}">
                                                        ${batch}${batchInfo.expiryDate ? '  ' + batchInfo.expiryDate : ''}
                                                    </span>
                                                `).join('')}
                                            </div>
                                        ` : ''}
                                    </div>
                                `).join('')}
                                </div>
                            </div>
                            
                            <div class="fixed bottom-0 left-0 right-0 bg-white border-t border-slate-200 p-4 z-20">
                                <div class="max-w-4xl mx-auto space-y-3">
                                    <button onclick="app.addRawMaterial()" class="w-full bg-teal-600 hover:bg-teal-700 text-white py-3 sm:py-3.5 rounded-xl text-base sm:text-lg font-bold shadow-lg shadow-teal-200 transition-all">
                                        + Add Raw Material
                                    </button>
                                    ${rmCount > 0 ? `
                                        <button onclick="app.clearRMDatabase()" class="w-full bg-white border border-red-200 text-red-600 hover:bg-red-50 py-2.5 sm:py-3 rounded-xl text-sm font-bold transition-colors">
                                            Clear Database
                                        </button>
                                    ` : ''}
                                </div>
                            </div>
                        </div>
                    `);
                    return;
                }

                // Session History Screen
                if (this.showingSessionHistory) {
                    const groupedSessions = {};
                    const liveSessions = [];
                    const historicalSessions = [];
                    const today = new Date().toLocaleDateString('en-CA'); // YYYY-MM-DD format

                    this.historySessions.forEach(session => {
                        const date = session.date || 'Unknown';
                        if (!groupedSessions[date]) groupedSessions[date] = [];
                        groupedSessions[date].push(session);

                        // Separate live (active) from historical
                        // A session is live if its status is 'active'
                        if (session.status === 'active') {
                            liveSessions.push(session);
                        } else {
                            historicalSessions.push(session);
                        }
                    });

                    // Group historical sessions by date
                    const groupedHistorical = {};
                    historicalSessions.forEach(session => {
                        const date = session.date || 'Unknown';
                        if (!groupedHistorical[date]) groupedHistorical[date] = [];
                        groupedHistorical[date].push(session);
                    });

                    updateView(`
                        <div class="min-h-screen bg-slate-50 p-4">
                            <div class="max-w-2xl lg:max-w-4xl mx-auto">
                                <!-- Header -->
                                <div class="bg-white rounded-2xl shadow-lg shadow-slate-200 overflow-hidden mb-4">
                                    <div class="p-4 border-b border-slate-100 flex items-center justify-between">
                                        <div class="flex items-center gap-3">
                                            <div class="w-8 h-8 sm:w-10 sm:h-10 bg-blue-500 rounded-xl flex items-center justify-center">
                                                <svg class="w-4 h-4 sm:w-5 sm:h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                                </svg>
                                            </div>
                                            <div>
                                                <h2 class="text-base sm:text-lg font-bold text-slate-900">Sessions</h2>
                                                <p class="text-xs text-slate-500">${liveSessions.length} live, ${historicalSessions.length} historical</p>
                                            </div>
                                        </div>
                                        <button onclick="app.hideSessionHistory()" class="p-2 bg-slate-50 hover:bg-slate-100 rounded-full transition-colors">
                                            <svg class="w-5 h-5 text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                            </svg>
                                        </button>
                                    </div>
                                    
                                    ${this.selectedHistorySession ? `
                                        <!-- Selected Session Details -->
                                        <div class="p-4 bg-blue-50 border-b border-blue-100">
                                            <div class="flex items-center justify-between mb-3">
                                                <div>
                                                    <div class="flex items-center gap-2">
                                                        <span class="${this.selectedHistorySession.sessionType === 'RM' ? 'bg-teal-100 text-teal-700' : 'bg-blue-100 text-blue-700'} text-xs font-bold px-2 py-0.5 rounded-full">
                                                            ${this.selectedHistorySession.sessionType === 'RM' ? 'Raw Materials' : 'Finished Products'}
                                                        </span>
                                                        <span class="text-xs text-slate-500">${this.selectedHistorySession.date}</span>
                                                        ${this.selectedHistorySession.warehouse ? `<span class="bg-slate-100 text-slate-600 text-xs font-medium px-2 py-0.5 rounded-full"> ${this.selectedHistorySession.warehouse}</span>` : ''}
                                                    </div>
                                                    <p class="text-sm font-medium text-slate-700 mt-1"> ${this.selectedHistorySession.startedBy || 'Unknown supervisor'}</p>
                                                    <p class="text-xs text-slate-500">
                                                        ${this.selectedHistorySession.startTime || ''} 
                                                        ${this.selectedHistorySession.deviceCount > 0 ? `  ${this.selectedHistorySession.deviceCount} device${this.selectedHistorySession.deviceCount > 1 ? 's' : ''}` : ''}
                                                    </p>
                                                </div>
                                                <button onclick="app.exportHistorySession()" class="px-4 py-2 bg-blue-600 text-white rounded-lg text-sm font-bold hover:bg-blue-700 transition-colors flex items-center gap-2">
                                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
                                                    </svg>
                                                    Export
                                                </button>
                                            </div>
                                            <div class="text-sm text-blue-700 font-medium">${this.historyLoading ? '<span class="inline-flex items-center gap-1"><svg class="w-3 h-3 animate-spin" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path></svg>Loading...</span>' : `${this.historyScans.length} scan(s)`}</div>
                                        </div>
                                        
                                        <!-- Scans List -->
                                        <div class="max-h-80 overflow-y-auto">
                                            ${this.historyLoading ? `
                                                <div class="p-8 text-center">
                                                    <div class="inline-flex items-center gap-3">
                                                        <svg class="w-5 h-5 animate-spin text-blue-500" fill="none" viewBox="0 0 24 24">
                                                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                                        </svg>
                                                        <span class="text-slate-500 font-medium">Loading scans...</span>
                                                    </div>
                                                </div>
                                            ` : this.historyScans.length > 0 ? this.historyScans.map((scan, idx) => `
                                                <div class="p-3 border-b border-slate-100 hover:bg-slate-50">
                                                    <div class="flex items-center justify-between">
                                                        <div class="flex-1">
                                                            <div class="flex items-center gap-2">
                                                                <span class="font-bold text-sm text-slate-800">${scan.stockCode}</span>
                                                                <span class="text-xs text-slate-400">#${scan.batchNumber}</span>
                                                            </div>
                                                            <p class="text-xs text-slate-500 truncate">${scan.description || 'No description'}</p>
                                                            <div class="flex items-center gap-2 mt-1 text-xs text-slate-400">
                                                                ${scan.location ? `<span> ${scan.location}</span>` : ''}
                                                                ${scan.expiryDate ? `<span> ${scan.expiryDate}</span>` : ''}
                                                            </div>
                                                        </div>
                                                        <div class="text-right">
                                                            <div class="font-bold text-lg ${this.selectedHistorySession.sessionType === 'RM' ? 'text-teal-600' : 'text-blue-600'}">
                                                                ${scan.cases}
                                                            </div>
                                                            <div class="text-xs text-slate-500">${scan.unitType || 'units'}</div>
                                                        </div>
                                                    </div>
                                                </div>
                                            `).join('') : `
                                                <div class="p-8 text-center text-slate-400">
                                                    <p>No scans in this session</p>
                                                </div>
                                            `}
                                        </div>
                                        
                                        <div class="p-4 border-t border-slate-100">
                                            <button onclick="app.selectedHistorySession = null; app.historyScans = []; app.historyLoading = false; app.render();" class="w-full bg-slate-100 hover:bg-slate-200 text-slate-700 py-2 rounded-lg text-sm font-bold transition-colors">
                                                 Back to Sessions
                                            </button>
                                        </div>
                                    ` : `
                                        <!-- Sessions List -->
                                        <div class="max-h-96 overflow-y-auto">
                                            ${liveSessions.length > 0 ? `
                                                <!-- Live Sessions -->
                                                <div class="border-b border-slate-100">
                                                    <div class="px-4 py-2 bg-emerald-50 text-xs font-bold text-emerald-700 uppercase tracking-wider flex items-center gap-2">
                                                        <div class="w-2 h-2 bg-emerald-500 rounded-full animate-pulse"></div>
                                                        Live Sessions
                                                    </div>
                                                    ${liveSessions.map(session => `
                                                        <button onclick="app.loadSessionHistory('${session.id}')" class="w-full p-4 hover:bg-slate-50 transition-colors text-left border-b border-slate-50 last:border-0">
                                                            <div class="flex items-center justify-between">
                                                                <div class="flex items-center gap-3">
                                                                    <div class="w-10 h-10 ${session.sessionType === 'RM' ? 'bg-teal-100' : 'bg-blue-100'} rounded-xl flex items-center justify-center">
                                                                        <span class="${session.sessionType === 'RM' ? 'text-teal-600' : 'text-blue-600'} font-bold text-xs">${session.sessionType}</span>
                                                                    </div>
                                                                    <div>
                                                                        <div class="flex items-center gap-2">
                                                                            <span class="font-bold text-sm text-slate-800">${session.sessionType === 'RM' ? 'Raw Materials' : 'Finished Products'}</span>
                                                                            <span class="bg-emerald-100 text-emerald-700 text-xs font-medium px-2 py-0.5 rounded-full flex items-center gap-1">
                                                                                <div class="w-1.5 h-1.5 bg-emerald-500 rounded-full animate-pulse"></div>
                                                                                live
                                                                            </span>
                                                                        </div>
                                                                        <div class="text-xs text-slate-600 mt-0.5 font-medium">
                                                                             ${session.startedBy || 'Unknown'} ${session.warehouse ? `  ${session.warehouse}` : ''}
                                                                        </div>
                                                                        <div class="text-xs text-slate-400 flex items-center gap-2 mt-0.5">
                                                                            <span>${session.startTime || ''}</span>
                                                                            ${session.activeDeviceCount > 0 ? `<span class="text-emerald-600"> ${session.activeDeviceCount} active</span>` : ''}
                                                                            ${session.deviceCount > 0 ? `<span>(${session.deviceCount} total)</span>` : ''}
                                                                        </div>
                                                                    </div>
                                                                </div>
                                                                <svg class="w-5 h-5 text-slate-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                                                                </svg>
                                                            </div>
                                                        </button>
                                                    `).join('')}
                                                </div>
                                            ` : ''}
                                            
                                            ${Object.keys(groupedHistorical).length > 0 ? Object.entries(groupedHistorical).map(([date, sessions]) => `
                                                <div class="border-b border-slate-100">
                                                    <div class="px-4 py-2 bg-slate-50 text-xs font-bold text-slate-500 uppercase tracking-wider">
                                                        ${date}
                                                    </div>
                                                    ${sessions.map(session => `
                                                        <button onclick="app.loadSessionHistory('${session.id}')" class="w-full p-4 hover:bg-slate-50 transition-colors text-left border-b border-slate-50 last:border-0">
                                                            <div class="flex items-center justify-between">
                                                                <div class="flex items-center gap-3">
                                                                    <div class="w-10 h-10 ${session.sessionType === 'RM' ? 'bg-teal-100' : 'bg-blue-100'} rounded-xl flex items-center justify-center">
                                                                        <span class="${session.sessionType === 'RM' ? 'text-teal-600' : 'text-blue-600'} font-bold text-xs">${session.sessionType}</span>
                                                                    </div>
                                                                    <div>
                                                                        <div class="flex items-center gap-2">
                                                                            <span class="font-bold text-sm text-slate-800">${session.sessionType === 'RM' ? 'Raw Materials' : 'Finished Products'}</span>
                                                                            <span class="${session.status === 'completed' ? 'bg-emerald-100 text-emerald-700' : 'bg-slate-100 text-slate-600'} text-xs font-medium px-2 py-0.5 rounded-full">
                                                                                ${session.status || 'active'}
                                                                            </span>
                                                                        </div>
                                                                        <div class="text-xs text-slate-600 mt-0.5 font-medium">
                                                                             ${session.startedBy || 'Unknown'} ${session.warehouse ? `  ${session.warehouse}` : ''}
                                                                        </div>
                                                                        <div class="text-xs text-slate-400 flex items-center gap-2 mt-0.5">
                                                                            <span>${session.startTime || ''}</span>
                                                                            ${session.deviceCount > 0 ? `<span> ${session.deviceCount} device${session.deviceCount > 1 ? 's' : ''}</span>` : ''}
                                                                        </div>
                                                                    </div>
                                                                </div>
                                                                <svg class="w-5 h-5 text-slate-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                                                                </svg>
                                                            </div>
                                                        </button>
                                                    `).join('')}
                                                </div>
                                            `).join('') : (liveSessions.length === 0 ? `
                                                <div class="p-8 text-center text-slate-400">
                                                    <svg class="w-12 h-12 mx-auto mb-3 text-slate-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                                    </svg>
                                                    <p class="font-medium">No sessions found</p>
                                                    <p class="text-sm">Complete a stock count to see it here</p>
                                                </div>
                                            ` : '')}
                                        </div>
                                    `}
                                </div>
                                
                                <button onclick="app.hideSessionHistory()" class="w-full bg-white border border-slate-200 text-slate-700 hover:bg-slate-50 py-3 rounded-xl text-sm font-bold transition-colors">
                                    Close
                                </button>
                            </div>
                        </div>
                    `);
                    return;
                }

                // Warehouse Setup Screen
                if (this.showingWarehouseSetup) {
                    const racks = this.sessionSettings.warehouseConfig?.racks || [];
                    const floors = this.sessionSettings.warehouseConfig?.floorLocations || [];

                    updateView(`
                        <div class="min-h-screen bg-slate-50 p-4 flex items-start justify-center pt-4">
                            <div class="max-w-lg w-full bg-white rounded-3xl shadow-xl shadow-slate-200 overflow-hidden">
                                <div class="p-4 sm:p-6 border-b border-slate-100 flex items-center justify-between bg-gradient-to-r from-blue-600 to-blue-700">
                                    <div>
                                        <h2 class="text-lg sm:text-xl font-bold text-white"> Warehouse Setup</h2>
                                        <p class="text-blue-100 text-sm">Configure racks and floor locations</p>
                                    </div>
                                    <button onclick="app.hideWarehouseSetup()" class="p-2 bg-white/20 hover:bg-white/30 rounded-full transition-colors">
                                        <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                        </svg>
                                    </button>
                                </div>
                                
                                <div class="p-4 sm:p-6 space-y-6 max-h-[75vh] overflow-y-auto">
                                    <!-- Racks Section -->
                                    <div>
                                        <div class="flex items-center justify-between mb-3">
                                            <h3 class="font-bold text-slate-800 flex items-center gap-2">
                                                <span class="text-xl"></span> Racks
                                            </h3>
                                            <button onclick="app.addRack()" class="px-3 py-1.5 bg-blue-600 hover:bg-blue-700 text-white text-sm font-bold rounded-lg transition-colors">
                                                + Add Rack
                                            </button>
                                        </div>
                                        
                                        ${racks.length === 0 ? `
                                            <div class="p-6 border-2 border-dashed border-slate-200 rounded-xl text-center text-slate-400">
                                                <p class="font-medium">No racks configured</p>
                                                <p class="text-sm">Add racks to define storage locations</p>
                                            </div>
                                        ` : `
                                            <div class="space-y-2">
                                                ${racks.map(rack => `
                                                    <div class="p-4 border border-slate-200 rounded-xl bg-slate-50 flex items-center justify-between">
                                                        <div>
                                                            <div class="font-bold text-slate-800">${rack.name}</div>
                                                            <div class="text-xs text-slate-500">
                                                                ${rack.columns} columns  ${rack.levels} levels = ${rack.columns * rack.levels} positions
                                                            </div>
                                                            <div class="text-xs text-blue-600 mt-1">
                                                                Levels: ${Array.from({ length: rack.levels }, (_, i) => String.fromCharCode(65 + i)).join(', ')} (bottom to top)
                                                            </div>
                                                        </div>
                                                        <button onclick="app.deleteRack('${rack.id}')" class="p-2 text-slate-400 hover:text-red-500 hover:bg-red-50 rounded-lg transition-colors">
                                                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                                                            </svg>
                                                        </button>
                                                    </div>
                                                `).join('')}
                                            </div>
                                        `}
                                    </div>
                                    
                                    <!-- Floor Locations Section -->
                                    <div>
                                        <div class="flex items-center justify-between mb-3">
                                            <h3 class="font-bold text-slate-800 flex items-center gap-2">
                                                <span class="text-xl"></span> Floor Locations
                                            </h3>
                                            <button onclick="app.addFloorLocation()" class="px-3 py-1.5 bg-emerald-600 hover:bg-emerald-700 text-white text-sm font-bold rounded-lg transition-colors">
                                                + Add Floor
                                            </button>
                                        </div>
                                        
                                        ${floors.length === 0 ? `
                                            <div class="p-6 border-2 border-dashed border-slate-200 rounded-xl text-center text-slate-400">
                                                <p class="font-medium">No floor locations</p>
                                                <p class="text-sm">Add floor areas for items not on racks</p>
                                            </div>
                                        ` : `
                                            <div class="flex flex-wrap gap-2">
                                                ${floors.map(floor => `
                                                    <div class="px-3 py-2 bg-emerald-50 border border-emerald-200 rounded-lg flex items-center gap-2">
                                                        <span class="font-medium text-emerald-700">FLOOR-${floor}</span>
                                                        <button onclick="app.deleteFloorLocation('${floor}')" class="p-1 text-emerald-400 hover:text-red-500 transition-colors">
                                                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                                            </svg>
                                                        </button>
                                                    </div>
                                                `).join('')}
                                            </div>
                                        `}
                                    </div>
                                    
                                    <!-- Summary -->
                                    <div class="p-4 bg-blue-50 border border-blue-200 rounded-xl">
                                        <div class="font-bold text-blue-800 mb-2"> Location Format</div>
                                        <div class="text-sm text-blue-700 space-y-1">
                                            <p><strong>Rack:</strong> RACKNAME-[Level][Position] (e.g., RACK01-A1, RACK01-B3)</p>
                                            <p><strong>Floor:</strong> FLOOR-[Name] (e.g., FLOOR-STAGING, FLOOR-01)</p>
                                        </div>
                                        <div class="mt-3 text-xs text-blue-600">
                                            Levels go AZ from bottom to top. Positions go 1N from left to right.
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="p-4 border-t border-slate-100">
                                    <button onclick="app.hideWarehouseSetup()" class="w-full py-3 bg-slate-100 hover:bg-slate-200 text-slate-700 font-bold rounded-xl transition-colors">
                                        Done
                                    </button>
                                </div>
                            </div>
                        </div>
                    `);
                    return;
                }

                // Location Picker Screen
                if (this.showingLocationPicker) {
                    const racks = this.sessionSettings.warehouseConfig?.racks || [];
                    const floors = this.sessionSettings.warehouseConfig?.floorLocations || [];
                    const selectedRack = this.selectedRackForPicker ? racks.find(r => r.id === this.selectedRackForPicker) : null;

                    updateView(`
                        <div class="min-h-screen bg-slate-900/95 p-4 flex items-start justify-center pt-4">
                            <div class="max-w-lg w-full bg-white rounded-3xl shadow-2xl overflow-hidden">
                                <div class="p-4 border-b border-slate-100 flex items-center justify-between bg-gradient-to-r from-blue-600 to-blue-700">
                                    <div>
                                        <h2 class="text-lg font-bold text-white"> Select Location</h2>
                                        <p class="text-blue-100 text-sm">${selectedRack ? `Rack: ${selectedRack.name}` : 'Choose a rack or floor location'}</p>
                                    </div>
                                    <button onclick="app.hideLocationPicker()" class="p-2 bg-white/20 hover:bg-white/30 rounded-full transition-colors">
                                        <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                        </svg>
                                    </button>
                                </div>
                                
                                <div class="p-4 max-h-[75vh] overflow-y-auto">
                                    ${selectedRack ? `
                                        <!-- Rack Grid View -->
                                        <div class="mb-4">
                                            <button onclick="app.selectRackForPicker(null)" class="text-blue-600 text-sm font-medium flex items-center gap-1 mb-3">
                                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                                                </svg>
                                                Back to list
                                            </button>
                                            
                                            <div class="text-center mb-4">
                                                <div class="font-bold text-lg text-slate-800">${selectedRack.name}</div>
                                                <div class="text-sm text-slate-500">${selectedRack.columns} columns  ${selectedRack.levels} levels</div>
                                            </div>
                                            
                                            <!-- Grid: Levels (rows) from TOP to BOTTOM, Positions (columns) left to right -->
                                            <div class="overflow-x-auto">
                                                <div class="inline-block min-w-full">
                                                    <!-- Column headers (positions) -->
                                                    <div class="flex mb-1">
                                                        <div class="w-10 flex-shrink-0"></div>
                                                        ${Array.from({ length: selectedRack.columns }, (_, i) => `
                                                            <div class="w-12 flex-shrink-0 text-center text-xs font-bold text-slate-400">${i + 1}</div>
                                                        `).join('')}
                                                    </div>
                                                    
                                                    <!-- Rows (levels from top to bottom, but A is at bottom) -->
                                                    ${Array.from({ length: selectedRack.levels }, (_, levelIdx) => {
                        const level = selectedRack.levels - levelIdx; // Reverse so top row is highest level
                        const levelLetter = String.fromCharCode(64 + level);
                        return `
                                                            <div class="flex mb-1">
                                                                <div class="w-10 flex-shrink-0 flex items-center justify-center text-xs font-bold text-slate-400">${levelLetter}</div>
                                                                ${Array.from({ length: selectedRack.columns }, (_, posIdx) => {
                            const position = posIdx + 1;
                            const locationCode = selectedRack.name + '-' + levelLetter + position;
                            const isSelected = this.sessionSettings.currentLocation === locationCode;
                            return `
                                                                        <button 
                                                                            onclick="app.selectRackPosition('${selectedRack.id}', ${level}, ${position})"
                                                                            class="w-12 h-12 flex-shrink-0 m-0.5 rounded-lg font-bold text-xs transition-all ${isSelected ? 'bg-blue-600 text-white shadow-lg scale-105' : 'bg-slate-100 hover:bg-blue-100 text-slate-600 hover:text-blue-600'}"
                                                                        >
                                                                            ${levelLetter}${position}
                                                                        </button>
                                                                    `;
                        }).join('')}
                                                            </div>
                                                        `;
                    }).join('')}
                                                </div>
                                            </div>
                                            
                                            <div class="mt-4 text-center text-xs text-slate-400">
                                                 Left to Right  &nbsp;|&nbsp;  A (ground) to ${String.fromCharCode(64 + selectedRack.levels)} (top) 
                                            </div>
                                        </div>
                                    ` : `
                                        <!-- Rack and Floor Selection -->
                                        ${racks.length > 0 ? `
                                            <div class="mb-6">
                                                <h3 class="font-bold text-slate-800 mb-3 flex items-center gap-2">
                                                    <span></span> Racks
                                                </h3>
                                                <div class="grid grid-cols-2 gap-2">
                                                    ${racks.map(rack => `
                                                        <button 
                                                            onclick="app.selectRackForPicker('${rack.id}')"
                                                            class="p-4 border-2 border-slate-200 hover:border-blue-500 rounded-xl text-left transition-all hover:shadow-md"
                                                        >
                                                            <div class="font-bold text-slate-800">${rack.name}</div>
                                                            <div class="text-xs text-slate-500">${rack.columns}${rack.levels} grid</div>
                                                        </button>
                                                    `).join('')}
                                                </div>
                                            </div>
                                        ` : ''}
                                        
                                        ${floors.length > 0 ? `
                                            <div>
                                                <h3 class="font-bold text-slate-800 mb-3 flex items-center gap-2">
                                                    <span></span> Floor Locations
                                                </h3>
                                                <div class="grid grid-cols-2 gap-2">
                                                    ${floors.map(floor => {
                        const locationCode = 'FLOOR-' + floor;
                        const isSelected = this.sessionSettings.currentLocation === locationCode;
                        return `
                                                            <button 
                                                                onclick="app.selectFloorLocation('${floor}')"
                                                                class="p-4 border-2 rounded-xl text-left transition-all hover:shadow-md ${isSelected ? 'border-emerald-500 bg-emerald-50' : 'border-slate-200 hover:border-emerald-500'}"
                                                            >
                                                                <div class="font-bold ${isSelected ? 'text-emerald-700' : 'text-slate-800'}">FLOOR-${floor}</div>
                                                                ${isSelected ? '<div class="text-xs text-emerald-600"> Selected</div>' : ''}
                                                            </button>
                                                        `;
                    }).join('')}
                                                </div>
                                            </div>
                                        ` : ''}
                                        
                                        ${racks.length === 0 && floors.length === 0 ? `
                                            <div class="p-8 text-center text-slate-400">
                                                <p class="font-medium mb-2">No locations configured</p>
                                                <p class="text-sm">Go to Settings to set up warehouse locations</p>
                                            </div>
                                        ` : ''}
                                    `}
                                </div>
                            </div>
                        </div>
                    `);
                    return;
                }

                if (this.showingSettings) {
                    updateView(`
                        <div class="min-h-screen bg-slate-50 p-4 flex items-start sm:items-center justify-center pt-8 sm:pt-4">
                            <div class="max-w-md md:max-w-lg lg:max-w-xl w-full bg-white rounded-3xl shadow-xl shadow-slate-200 overflow-hidden">
                                <div class="p-4 sm:p-6 border-b border-slate-100 flex items-center justify-between">
                                    <h2 class="text-lg sm:text-xl font-bold text-slate-900">Settings</h2>
                                    <button onclick="app.hideSettings()" class="p-2 bg-slate-50 hover:bg-slate-100 rounded-full transition-colors">
                                        <svg class="w-5 h-5 text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                        </svg>
                                    </button>
                                </div>
                                
                                <div class="p-4 sm:p-6 space-y-5 sm:space-y-6 max-h-[70vh] overflow-y-auto">
                                    <div>
                                        <label class="block text-xs font-bold text-slate-500 uppercase tracking-wider mb-2">
                                            Device ID
                                        </label>
                                        <div class="flex items-center gap-2 bg-slate-50 px-3 sm:px-4 py-2.5 sm:py-3 rounded-xl border border-slate-200">
                                            <svg class="w-4 h-4 sm:w-5 sm:h-5 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 18h.01M8 21h8a2 2 0 002-2V5a2 2 0 00-2-2H8a2 2 0 00-2 2v14a2 2 0 002 2z"/>
                                            </svg>
                                            <code class="text-xs sm:text-sm font-mono text-slate-600 flex-1 truncate">${DEVICE_ID}</code>
                                        </div>
                                    </div>
                                    
                                    <!-- Location Scanning Toggle -->
                                    <div>
                                        <label class="block text-xs font-bold text-slate-500 uppercase tracking-wider mb-2">
                                            Location Scanning
                                        </label>
                                        <div class="px-4 py-4 border rounded-xl border-slate-200 bg-slate-50">
                                            <div class="flex items-center justify-between">
                                                <div class="flex items-center gap-3">
                                                    <svg class="w-5 h-5 text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"/>
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"/>
                                                    </svg>
                                                    <div>
                                                        <div class="font-bold text-sm text-slate-800">Track Location</div>
                                                        <div class="text-xs text-slate-500">Rack, Floor, Bin, etc.</div>
                                                    </div>
                                                </div>
                                                <button 
                                                    onclick="app.toggleLocationScanning()"
                                                    class="relative w-12 h-7 rounded-full transition-colors ${this.sessionSettings.locationScanningEnabled ? 'bg-blue-600' : 'bg-slate-300'}"
                                                >
                                                    <span class="absolute top-1 ${this.sessionSettings.locationScanningEnabled ? 'left-6' : 'left-1'} w-5 h-5 bg-white rounded-full shadow transition-all"></span>
                                                </button>
                                            </div>
                                            
                                            ${this.sessionSettings.locationScanningEnabled ? `
                                                <div class="mt-4 pt-4 border-t border-slate-200">
                                                    <!-- Current Location Display -->
                                                    <div class="mb-4">
                                                        <label class="block text-xs font-medium text-slate-500 mb-2">Current Location</label>
                                                        <div class="flex items-center gap-2 p-3 bg-white border border-slate-200 rounded-xl">
                                                            ${this.sessionSettings.currentLocation ? `
                                                                <span class="flex-1 font-bold text-blue-600">${this.sessionSettings.currentLocation}</span>
                                                                <button onclick="app.clearLocation()" class="p-1 text-slate-400 hover:text-red-500">
                                                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                                                    </svg>
                                                                </button>
                                                            ` : `
                                                                <span class="flex-1 text-slate-400 italic">No location selected</span>
                                                            `}
                                                        </div>
                                                    </div>
                                                    
                                                    <!-- Warehouse Setup Button -->
                                                    <button 
                                                        onclick="app.showWarehouseSetup()"
                                                        class="w-full py-3 px-4 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-xl transition-colors flex items-center justify-center gap-2"
                                                    >
                                                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/>
                                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
                                                        </svg>
                                                        Configure Warehouse Locations
                                                    </button>
                                                    
                                                    <!-- Quick Stats -->
                                                    <div class="mt-3 grid grid-cols-2 gap-2 text-center text-xs">
                                                        <div class="p-2 bg-white rounded-lg border border-slate-100">
                                                            <div class="font-bold text-slate-800">${this.sessionSettings.warehouseConfig?.racks?.length || 0}</div>
                                                            <div class="text-slate-500">Racks</div>
                                                        </div>
                                                        <div class="p-2 bg-white rounded-lg border border-slate-100">
                                                            <div class="font-bold text-slate-800">${this.sessionSettings.warehouseConfig?.floorLocations?.length || 0}</div>
                                                            <div class="text-slate-500">Floor Locations</div>
                                                        </div>
                                                    </div>
                                                </div>
                                            ` : ''}
                                        </div>
                                    </div>
                                    
                                    <div>
                                        <label class="block text-xs font-bold text-slate-500 uppercase tracking-wider mb-2">
                                            Connection Status
                                        </label>
                                        ${(() => {
                            const mode = this.usingSupabaseDB ? 'supabase' : 'offline';
                            const configs = {
                                supabase: {
                                    border: 'border-blue-200 bg-blue-50',
                                    dot: 'bg-blue-500',
                                    title: 'Connected to Supabase',
                                    titleClass: 'text-blue-800',
                                    subtitle: 'All scans sync directly to Supabase Postgres',
                                    subtitleClass: 'text-blue-600',
                                    note: 'Session heartbeats, duplicate checks, and exports are using Supabase only.',
                                    noteClass: 'text-blue-500'
                                },
                                offline: {
                                    border: 'border-slate-200 bg-slate-50',
                                    dot: 'bg-slate-400',
                                    title: 'Offline Mode',
                                    titleClass: 'text-slate-700',
                                    subtitle: 'Data stored locally on this device',
                                    subtitleClass: 'text-slate-500',
                                    note: 'Reconnect to sync with Supabase automatically.',
                                    noteClass: 'text-slate-500'
                                }
                            };
                            const cfg = configs[mode];
                            return `
                                                <div class="px-4 py-4 border rounded-xl ${cfg.border}">
                                                    <div class="flex items-center gap-3">
                                                        <div class="w-3 h-3 rounded-full ${cfg.dot}"></div>
                                                        <div>
                                                            <div class="font-bold text-sm ${cfg.titleClass}">${cfg.title}</div>
                                                            <div class="text-xs mt-0.5 ${cfg.subtitleClass}">${cfg.subtitle}</div>
                                                        </div>
                                                    </div>
                                                    ${cfg.note ? `<div class="mt-3 text-xs ${cfg.noteClass}">${cfg.note}</div>` : ''}
                                                </div>
                                            `;
                        })()}
                                    </div>
                                    
                                    <!-- Product Types Management -->
                                    <div>
                                        <label class="block text-xs font-bold text-slate-500 uppercase tracking-wider mb-2">
                                            Product Types Database
                                        </label>
                                        <div class="px-4 py-4 border rounded-xl border-slate-200 bg-slate-50">
                                            <div class="flex items-center justify-between mb-3">
                                                <div class="flex items-center gap-3">
                                                    <svg class="w-5 h-5 text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"/>
                                                    </svg>
                                                    <div>
                                                        <div class="font-bold text-sm text-slate-800">${Object.keys(productTypeDatabase).length} Product Types</div>
                                                        <div class="text-xs text-slate-500">${productTypesLoadedFromDB ? 'Synced from Supabase' : 'Local cache'}</div>
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="grid grid-cols-2 gap-2">
                                                <button 
                                                    onclick="app.addProductType()"
                                                    class="py-2 px-3 bg-blue-600 hover:bg-blue-700 text-white rounded-lg text-xs font-bold transition-colors flex items-center justify-center gap-1"
                                                >
                                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"/>
                                                    </svg>
                                                    Add One
                                                </button>
                                                <button 
                                                    onclick="app.importProductTypes()"
                                                    class="py-2 px-3 bg-emerald-600 hover:bg-emerald-700 text-white rounded-lg text-xs font-bold transition-colors flex items-center justify-center gap-1"
                                                >
                                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"/>
                                                    </svg>
                                                    Import Excel
                                                </button>
                                            </div>
                                            <div class="text-xs text-slate-400 mt-2 text-center">Only new products will be added</div>
                                        </div>
                                    </div>
                                    
                                    <div class="pt-2 space-y-3">
                                        <button onclick="app.testConnection()" class="w-full bg-blue-600 hover:bg-blue-700 text-white py-3 rounded-xl text-sm font-bold shadow-lg shadow-blue-100 transition-all">
                                             Test Connection
                                        </button>
                                        
                                        <button onclick="app.hideSettings()" class="w-full bg-white border border-slate-200 text-slate-700 hover:bg-slate-50 py-3 rounded-xl text-sm font-bold transition-colors">
                                            Close
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `);
                    return;
                }

                // Main screen
                const userName = getUserName();
                updateView(`
                    <div class="min-h-screen bg-slate-50 pb-24">
                        <!-- Sticky Header -->
                        <div class="sticky top-0 z-30 bg-white/80 backdrop-blur-md border-b border-slate-200 px-4 py-3 shadow-sm">
                            <div class="max-w-4xl mx-auto flex items-center justify-between">
                                <div class="flex items-center gap-3">
                                    <div class="w-10 h-10 sm:w-12 sm:h-12 ${this.activeStockTake?.sessionType === 'RM' ? 'bg-teal-600' : 'bg-blue-600'} rounded-xl flex items-center justify-center shadow-md ${this.activeStockTake?.sessionType === 'RM' ? 'shadow-teal-200' : 'shadow-blue-200'}">
                                        <span class="text-white font-bold text-lg sm:text-xl">${userName.charAt(0).toUpperCase()}</span>
                                    </div>
                                    <div>
                                        <div class="flex items-center gap-2">
                                            <h1 class="text-sm sm:text-base font-bold text-slate-900 leading-tight">${this.activeStockTake?.sessionType === 'RM' ? 'Raw Materials' : 'Finished Products'}</h1>
                                            <span class="${this.activeStockTake?.sessionType === 'RM' ? 'bg-teal-100 text-teal-700' : 'bg-blue-100 text-blue-700'} text-xs font-bold px-2 py-0.5 rounded-full">
                                                #${this.activeStockTake?.sessionNumber || 1}
                                            </span>
                                        </div>
                                        <div class="flex items-center gap-2 mt-0.5">
                                            <p class="text-xs text-slate-500 font-medium">${this.currentTakeDate}</p>
                                            ${(() => {
                        const session = this.activeStockTake?.id ? getSessionById(this.currentTakeDate, this.activeStockTake.id) : null;
                        if (session?.devices && session.devices.length > 0) {
                            const now = Date.now();
                            const activeDevices = session.devices.filter(d => d.status === 'active');
                            const staleDevices = activeDevices.filter(d => {
                                if (!d.lastSeen) return false;
                                const last = new Date(d.lastSeen).getTime();
                                return now - last > HEARTBEAT_GRACE_MS;
                            });
                            const liveActive = activeDevices.length - staleDevices.length;
                            const completedCount = session.devices.filter(d => d.status === 'completed').length;
                            return `
                                                        <span class="text-xs text-slate-400"></span>
                                                        <span class="text-xs text-emerald-600 font-medium flex items-center gap-1">
                                                            <span class="w-1.5 h-1.5 bg-emerald-500 rounded-full"></span>
                                                            ${liveActive} active${completedCount > 0 ? `, ${completedCount} done` : ''}
                                                        </span>
                                                        ${staleDevices.length > 0 ? `
                                                            <span class="text-xs text-red-500 font-medium flex items-center gap-1">
                                                                <span class="w-1.5 h-1.5 bg-red-500 rounded-full"></span>
                                                                ${staleDevices.length} idle
                                                            </span>
                                                        ` : ''}
                                                    `;
                        }
                        return '';
                    })()}
                                            ${(() => {
                        const pendingCount = offlineSyncQueue.getPendingCount();
                        if (pendingCount > 0) {
                            return `
                                                        <button onclick="app.manualSyncOffline()" class="text-xs font-medium flex items-center gap-1 text-amber-600 hover:text-amber-700 transition-colors">
                                                            <span class="w-1.5 h-1.5 rounded-full bg-amber-500 animate-pulse"></span>
                                                            ${pendingCount} pending sync
                                                        </button>
                                                    `;
                        }
                        return `
                                                    <span class="text-xs font-medium flex items-center gap-1 ${this.isOfflineMode() ? 'text-slate-500' : 'text-emerald-600'}">
                                                        <span class="w-1.5 h-1.5 rounded-full ${this.isOfflineMode() ? 'bg-slate-400' : 'bg-emerald-500'} animate-pulse"></span>
                                                        ${this.isOfflineMode() ? 'Offline' : 'Online'}
                                                    </span>
                                                `;
                    })()}
                                        </div>
                                    </div>
                                </div>
                                <div class="flex gap-2">
                                    ${canViewProductDatabase() ? `
                                    <button onclick="app.showProductDatabase()" class="p-2 text-slate-600 hover:bg-slate-100 rounded-xl transition-colors" title="Products">
                                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 7v10c0 2.21 3.582 4 8 4s8-1.79 8-4V7M4 7c0 2.21 3.582 4 8 4s8-1.79 8-4M4 7c0-2.21 3.582-4 8-4s8 1.79 8 4m0 5c0 2.21-3.582 4-8 4s-8-1.79-8-4"/>
                                        </svg>
                                    </button>
                                    ` : ''}
                                    <button onclick="app.goHome()" class="p-2 text-slate-600 hover:bg-slate-100 rounded-xl transition-colors" title="Back to Home">
                                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"/>
                                        </svg>
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- Stats Bar -->
                        <div class="px-4 py-4 max-w-4xl mx-auto">
                            <div class="bg-white rounded-2xl p-4 sm:p-6 shadow-sm border border-slate-100">
                                <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
                                    <div>
                                        <div class="text-xs font-bold text-slate-400 uppercase tracking-wider mb-1">Total Scanned</div>
                                        <div class="text-3xl sm:text-4xl font-black text-slate-900">${this.scans.length}</div>
                                    </div>
                                </div>
                                ${(() => {
                        const today = new Date();
                        today.setHours(0, 0, 0, 0);
                        const expiredCount = this.scans.filter(s => {
                            if (!s.expiryDate) return false;
                            const exp = new Date(s.expiryDate);
                            exp.setHours(0, 0, 0, 0);
                            return exp <= today;
                        }).length;
                        return expiredCount > 0 ? `
                                        <div class="mt-3 flex items-center gap-2 p-2 bg-red-50 rounded-lg border border-red-100">
                                            <div class="flex-shrink-0 w-8 h-8 bg-red-500 rounded-full flex items-center justify-center">
                                                <svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/>
                                                </svg>
                                            </div>
                                            <div>
                                                <div class="text-sm font-bold text-red-700">${expiredCount} Expired Item${expiredCount > 1 ? 's' : ''}</div>
                                                <div class="text-xs text-red-500">These items are past their expiry date</div>
                                            </div>
                                        </div>
                                    ` : '';
                    })()}
                            </div>
                            
                            ${this.sessionSettings.locationScanningEnabled ? `
                                <button onclick="app.promptForLocation()" class="mt-3 w-full flex items-center justify-center gap-2 text-xs font-medium ${this.sessionSettings.currentLocation ? 'text-blue-600 bg-blue-50/50 border-blue-100/50' : 'text-slate-500 bg-slate-50/50 border-slate-200/50'} py-2 rounded-lg border">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"/>
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"/>
                                    </svg>
                                    <span>${[this.sessionSettings.site, this.sessionSettings.aisle, this.sessionSettings.rack].filter(Boolean).join('  ') || this.sessionSettings.currentLocation || 'Tap to set location'}</span>
                                </button>
                            ` : ''}
                        </div>

                        <!-- List -->
                        <div class="px-4 max-w-4xl mx-auto">
                            <div class="space-y-3 md:grid md:grid-cols-2 lg:grid-cols-3 md:gap-4 md:space-y-0">
                            ${this.scans.length === 0 ? `
                                <div class="md:col-span-2 lg:col-span-3 text-center py-20">
                                    <div class="w-24 h-24 sm:w-32 sm:h-32 bg-slate-100 rounded-full flex items-center justify-center mx-auto mb-6">
                                        <svg class="w-10 h-10 sm:w-14 sm:h-14 text-slate-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v1m6 11h2m-6 0h-2v4m0-11v3m0 0h.01M12 12h4.01M16 20h4M4 12h4m12 0h.01M5 8h2a1 1 0 001-1V5a1 1 0 00-1-1H5a1 1 0 00-1 1v2a1 1 0 001 1zm12 0h2a1 1 0 001-1V5a1 1 0 00-1-1h-2a1 1 0 00-1 1v2a1 1 0 001 1zM5 20h2a1 1 0 001-1v-2a1 1 0 00-1-1H5a1 1 0 00-1 1v2a1 1 0 001 1z"/>
                                        </svg>
                                    </div>
                                    <h3 class="text-lg sm:text-xl font-bold text-slate-900">Ready to Scan</h3>
                                    <p class="text-slate-500 mt-1 text-sm sm:text-base">Tap the button below to start counting</p>
                                </div>
                            ` : this.scans.map(scan => {
                        // Check if expired
                        const today = new Date();
                        today.setHours(0, 0, 0, 0);
                        let isExpired = false;
                        let expiryDisplay = '';
                        if (scan.expiryDate) {
                            const expiry = new Date(scan.expiryDate);
                            expiry.setHours(0, 0, 0, 0);
                            isExpired = expiry <= today;
                            expiryDisplay = expiry.toLocaleDateString();
                        }
                        const borderColor = isExpired ? 'bg-red-500' : (scan.actualCases !== scan.casesOnPallet ? 'bg-yellow-500' : 'bg-emerald-500');
                        const escapedId = scan.id.toString().replace(/'/g, "\\'");
                        return `
                                <div onclick="app.editScan('${escapedId}')" class="cursor-pointer bg-white rounded-2xl p-4 shadow-sm border ${isExpired ? 'border-red-200 bg-red-50' : 'border-slate-100'} relative overflow-hidden group hover-lift transition-all active:scale-[0.98]">
                                    <div class="absolute top-0 left-0 w-1 h-full ${borderColor}"></div>
                                    <div class="pl-3 flex items-start justify-between">
                                        <div class="flex-1 min-w-0">
                                            <div class="flex items-center gap-2 mb-1 flex-wrap">
                                                <span class="font-mono text-xs font-bold text-slate-500 bg-slate-100 px-2 py-0.5 rounded">
                                                    ${scan.batchNumber || 'N/A'}
                                                </span>
                                                <span class="text-sm font-bold ${this.activeStockTake?.sessionType === 'RM' ? 'text-teal-600' : 'text-blue-600'} truncate">${scan.stockCode}</span>
                                                ${isExpired ? `
                                                    <span class="px-2 py-0.5 text-xs font-bold bg-red-500 text-white rounded-full animate-pulse">
                                                        EXPIRED
                                                    </span>
                                                ` : ''}
                                                <span class="ml-auto text-xs text-blue-500 font-medium">
                                                     Tap to edit
                                                </span>
                                            </div>
                                            
                                            <div class="text-slate-900 font-medium text-sm mb-3 line-clamp-2">${scan.description}</div>
                                            
                                            <div class="flex items-center gap-3 text-xs text-slate-500 flex-wrap">
                                                ${scan.sessionType !== 'RM' && scan.palletNumber ? `
                                                <div class="flex items-center gap-1">
                                                    <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 7l-8-4-8 4m16 0l-8 4m8-4v10l-8 4m0-10L4 7m8 4v10M4 7v10l8 4"/>
                                                    </svg>
                                                    <span>Pallet ${scan.palletNumber}</span>
                                                </div>
                                                ` : ''}
                                                ${scan.location ? `
                                                    <div class="flex items-center gap-1 text-blue-600">
                                                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"/>
                                                        </svg>
                                                        <span>${scan.location}</span>
                                                    </div>
                                                ` : ''}
                                                <div class="flex items-center gap-1">
                                                    <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"/>
                                                    </svg>
                                                    <span>${scan.scannedBy || 'Unknown'}</span>
                                                </div>
                                                <div class="flex items-center gap-1">
                                                    <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                                    </svg>
                                                    <span>${scan.time}</span>
                                                </div>
                                                ${expiryDisplay ? `
                                                    <div class="flex items-center gap-1 ${isExpired ? 'text-red-600 font-bold' : 'text-slate-500'}">
                                                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"/>
                                                        </svg>
                                                        <span>Exp: ${expiryDisplay}</span>
                                                    </div>
                                                ` : ''}
                                            </div>
                                        </div>
                                        
                                        <div class="flex flex-col items-end gap-3 ml-3">
                                            <div class="text-right">
                                                <div class="text-2xl font-black ${isExpired ? 'text-red-600' : (scan.actualCases !== scan.casesOnPallet ? 'text-yellow-600' : 'text-emerald-600')}">
                                                    ${scan.actualCases}
                                                </div>
                                                <div class="text-[10px] font-bold text-slate-400 uppercase tracking-wide">${scan.unitType === 'kg' ? 'KG' : (scan.unitType === 'units' ? 'UN' : 'Cases')}</div>
                                            </div>
                                            
                                            <button onclick="event.stopPropagation(); app.deleteScan('${escapedId}')" class="p-2 text-slate-300 hover:text-red-500 hover:bg-red-50 rounded-lg transition-colors">
                                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                                                </svg>
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            `;
                    }).join('')}
                            </div>
                        </div>
                    </div>
                `);
            }
        }

        const app = new ScannerApp();
        window.app = app;

        // On startup, check for pending offline scans and sync if online
        (async () => {
            const pendingCount = offlineSyncQueue.getPendingCount();
            if (pendingCount > 0 && navigator.onLine && supabase) {
                console.log(`Found ${pendingCount} offline scans on startup, syncing...`);
                const result = await syncOfflineScans();
                if (result.synced > 0) {
                    console.log(`Startup sync: synced ${result.synced} scans`);
                    // Reload scans if we're in a session
                    if (app.activeStockTake?.id) {
                        await app.loadScans();
                        app.render();
                    }
                }
            }
        })();

        window.addEventListener('online', () => {
            if (window.app?.handleConnectivityChange) {
                window.app.handleConnectivityChange(true);
            }
        });

        window.addEventListener('offline', () => {
            if (window.app?.handleConnectivityChange) {
                window.app.handleConnectivityChange(false);
            }
        });
    </script>
</body>

</html>